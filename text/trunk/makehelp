#!/usr/bin/python

#----------------------------------------------------------------------------
# Script to compile monolithic help .txt files from individual, categorized
# files. Run with no args to see details on usage.
#
# This script is very inefficient. If you know of a better, iterative
# way to do it, please be my guest.
#
# - Greg
#----------------------------------------------------------------------------

import os, glob, sys
from stat import *

# Routine for recursing the directories and subdirectories of the build
# target. Theoretically can be of unlimited depth at the expense of
# host machine resources.
#
# Copies each file to the 'build' directory for assembly by assemble_files.
#----------------------------------------------------------------------------
def recurse_dir(dir, fixdos=0):
	if not os.path.isdir(dir):
		print 'Not a directory!'

	textdir_contents = glob.glob(dir + "/*")

	for file in textdir_contents:
		if os.path.isdir(file):
			# We're dealing with a directory, recurse it.
			recurse_dir(file, fixdos)
		else:
			# We've got a file, move to build dir.
			if fixdos:
				os.system('fromdos "' + file + '"')
			else:
				os.system('cp "' + file + '" build')

# Assembles the target file from the contents of the build dir.
#----------------------------------------------------------------------------
def assemble_files(targetfile):
	entry_list = glob.glob('build/*') 
	entry_list.sort()

	for file in entry_list:
		# We've got a file, cat it into our final .txt.
		os.popen('cat "' + file + '" >> ' + targetfile)

# Clean up our build dir.
#----------------------------------------------------------------------------
def clean_builddir():
	os.system('rm -rf build/*')

# Top level function that calls recurse_dir() on the build target.
#----------------------------------------------------------------------------
def build_help(build_targ):
	# build_targ is without the .txt, IE: 'wizhelp', 'help', etc. Tack
	# the .txt on the end and this is our target file.
        buildfile = build_targ + '.txt'

	# Clean up the build target file and build dir.
        os.system('rm -rf ' + buildfile)
	clean_builddir()

        print 'Building ' + buildfile + '...'
	# Transfers our help files into the build dir.
        recurse_dir(build_targ)
	# Assemble our build target from the contents of build dir.
	assemble_files(buildfile)

	clean_builddir()

        print 'Finished building ' + buildfile + '.'

# Calls mkindx assuming it's in ../bin/mkindx. We may need to adjust this
# once we start packaging BTMux. Right now this is called every time we
# build a help file.
#----------------------------------------------------------------------------
def build_mkindx(buildfile):
	print 'mkindx target ' + buildfile + '.txt'
	os.popen('../bin/mkindx ' + buildfile + '.txt ' + buildfile + '.indx')

#----------------------------------------------------------------------------
# Begin Main Program Logic
#----------------------------------------------------------------------------

# List of targets. Safe to add on to without further modification.
valid_targets = ['help', 'wizhelp', 'news', 'wiznews', 'plushelp']
other_files = ['connect', 'down', 'newuser']
mkindx_note = "Don't forget to @readcache if your game is still running!"

# Show this if no arguments are given.
if len(sys.argv) < 2:
	print '-'*78
	print ' Syntax: makehelp <helptarget>\n'
	print ' Input desired helpfile to build. May be any of the following:'
	for target in valid_targets:
		print '  ' + target
	print '  all (Builds all of the above targets)'
	print '  fixdos (Fixes Windows-polluted files, requires frodo)'
	print '-'*78
	print ' NOTE: You will need @readcache if your game is running.'
	print '-'*78
	sys.exit(2)

# Grab the first argument and check against it.
build_targ = sys.argv[1]

if build_targ == 'all':
# ----> Build everything from valid_targets.
	for buildfile in valid_targets:
		build_help(buildfile)
elif build_targ == 'mkindx':
# ----> Call mkindx on everything.
	mkindx_list = valid_targets + other_files
	for buildfile in mkindx_list:
		build_mkindx(buildfile)
	print mkindx_note
elif build_targ in valid_targets:
# ----> Build only the specified target.
	build_help(build_targ)
	build_mkindx(build_targ)
	print mkindx_note
elif build_targ == 'fixdos':
# ----> Fix the stupid DOS/Windows linebreaks.
	for buildfile in valid_targets:
		recurse_dir(buildfile,1)
else:
# ----> Invalid argument.
	print 'Invalid build target! Issue the command with no arguments for syntax.'
	sys.exit(2)
