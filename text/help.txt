 
& @@
 
  Syntax: @@ <args>
 
  This command does nothing, therefore it is useful for putting
  comments into a MUX program.  Be careful that ()'s and {}'s in the
  (otherwise ignored) arguments are nested correctly, lest your
  command-ending ; be trapped inside.
 
  Example:
  @va me=$foobar *:@fo #1234=%0;@@ This controls my foobar puppet.
  
& @@()
 
  FUNCTION: @@(<text>)

  The <text> is not evaluated and returns nothing.

  Example:
    > think @@(pemit(me,Hello))
    > think @@(abc)

  Related Topics: @@  
& @aahear
 
  Syntax: @aahear <object> = <command-list>
  Attribute: Aahear
 
  An Aahear on an object is activated whenever the listen pattern
  matches anything done/said by anything else in the room, including
  itself. The Ahear ignores itself, helpful for keeping machines
  from triggering itself)
 
  Example:
  @aahear listener = "I heard someone (maybe me?) say the word!
 
  See also: @ahear, @amhear, @listen
  
& @aclone
 
  Syntax: @aclone <object> = <command-list>
  Attribute: Aclone
 
  Sets the actions to be taken by a new object that has just been
  created as the result of a @clone command.  The contents of the
  Aclone attribute are run by the new object and not by the old
  object.
 
  This attribute is only meaningful for things, and will never be
  automatically triggered on other object types.
 
  It is also possible to check the zone object/objects in the zone
  parent room for an @adisconnect. If one is found, it will be
  executed when a player disconnects in that zone.
 
  Example:
  @aclone Time bomb = @wait 600=@trig me/va;@wait 10=@trig me/vb
  @va time bomb = :EXPLODES with a thundering roar;@destroy me
  @vb time bomb = :ticks.; @wait 10=@trig me/vb
 
  See also: @clone
  
& @aconnect
 
  Syntax: @aconnect <object> = <command-list>
  Attribute: Aconnect
 
  Sets the actions to be taken by a player right after connecting to
  the game.  This attribute is only meaningful for players, and will
  never be automatically triggered on other object types.
 
  It is also possible to check the zone object/objects in the zone
  parent room for an @aconnect. If one is found, it will be executed
  when a player connects in that zone.
 
  Example: @aconnect me = check.my.mailbox
 
  See also: @adisconnect.
  
& @adescribe
 
  Syntax: @adescribe <object> = <command-list>
  Attribute: Adescribe
 
  Sets the actions to be taken when <object> is looked at.
 
  Example:
  @adesc kitten = :rubs against %n's legs affectionately.
 
  See also: look, @desc, @idesc, @odesc, think.
  
& @adfail
 
  Syntax: @adfail <object> = <command-list>
  Attribute: Adfail
 
  Sets the action to be taken by an object when someone tries to drop
  it but fails because they didn't pass the object's drop lock.
 
  Example:
  @adfail sword = @name me=Cursed Sword;:laughs maniacally.
 
  See also: drop, @dfail, @odfail, @lock
  
& @adisconnect
 
  Syntax: @adisconnect <object> = <command-list>
  Attribute: Adisconnect
 
  Sets the actions to be taken by a player right after disconnecting
  from the game.
 
  This attribute is only meaningful for players, and will never be
  automatically triggered on other object types.
 
  Example:
  @adisconnect me = home
 
  See also: @aconnect
  
& @adrop
 
  Syntax: @adrop <object> = <command-list>
  Attribute: Adrop
 
  Sets the action to be taken by an object when it is dropped, or by
  an exit when it is successfully used.
 
  Example:
  @adrop plastique = kill %n=100; @destroy me
 
  See also: drop, @drop, @odrop, DROP-TO, EXITS
  
& @aefail
 
  Syntax: @aefail <object> = <command-list>
  Attribute: Aefail
 
  Sets the action to be taken by an object when someone tries to enter
  it but fails because the object is not ENTER_OK or the player
  fails the object's enter lock.
 
  The enter lock only affects the 'enter' command and its aliases (set
  via the @ealias command), it does not affect exits that lead to
  the object or teleporting in.
 
  This attribute is meaningful for players and things, and will never
  be automatically triggered on rooms or exits.
 
  Example:
  @aefail car = @emit ;'s alarm starts wailing when %n tries
  to break in.
 
  See also: @aenter, @efail, @ealias, @enter, @oefail, @oenter, enter,
  ENTER_OK
  
& @aenter
 
  Syntax: @aenter <object> = <command-list>
  Attribute: Aenter
 
  Sets the action to be taken by an object or room when someone enters
  it, whether by using an exit, the enter or leave commands, or by
  teleporting.
 
  This attribute is meaningful for players, things, and rooms, and
  will never be automatically triggered on exits.
 
  Example:
  @aenter car = :starts its engine.; "Beep Beep!
 
  See also: enter, @enter, @oenter, ENTER_OK
  
& @afail
 
  Syntax: @afail <object> = <command-list>
  Attribute: Afail
 
  Sets the commands to be performed by <object> when one of these
  events occurs:
 
  - For exits: Someone tries to traverse the exit but cannot because
    they fail the exit's default lock or the exit is not linked.
  - For players and things: Someone tries to pick up the object but
    cannot because they fail the object's default lock.
  - For rooms, players, and things: Someone looks around inside the
    room, player, or thing and fails the object's default lock.
 
  Example:
  > @afail vase = :falls and smashes to pieces.;@destroy me
 
  See also: @fail, @ofail, FAILURE
  
& @agfail
 
  Syntax: @agfail <object> = <command-list>
  Attribute: Agfail
 
  Sets the action to be taken by an object when someone tries to give
  it away but fails because they didn't pass the object's give lock.
 
  Example:
  @agfail sword = @name me=Cursed Sword;:laughs maniacally.
 
  See also: give, @gfail, @ogfail, @lock
  
& @ahear
 
  Syntax: @ahear <object> = <command-list>
  Attribute: Ahear
 
  Sets the actions to be taken after the object hears a string that
  matches the pattern in the Listen attribute which was not produced
  by the object itself.  Messages that are produced by the object
  itself are ignored.
 
  Example:
  @ahear clock = "The time is now [time()].  >> BONNNNGGGGG <<
 
  See also: @aahear, @amhear, @listen
  
& @akill
 
  Syntax: @akill <object> = <command-list>
  Attribute: Akill
 
  Sets the actions to be taken by an object after it is killed and has
  returned to its home.
 
  This attribute is only meaningful for players and things, and will
  never be automatically triggered on other object types.
 
  Example:
  @akill lion = south; :leaps onto %n, roaring loudly.;kill %n=100
 
  See also: kill, @kill and @okill, BEING KILLED, IMMORTAL, WIZARD
  
& @aleave
 
  Syntax: @aleave <object> = <command-list>
  Attribute: Aleave
 
  Sets the action to be taken by an object or room when someone leaves
  it, whether by using an exit, the enter or leave commands, or by
  teleporting.
 
  This attribute is meaningful for players, things, and rooms, and
  will never be automatically triggered on exits.
 
  Example:
  @aleave car = :stops to let %n out.;:revs its engine, hoping
  another brave soul would like a ride.
 
  See also: leave, @leave, @oleave
  
& @alfail
 
  Syntax: @alfail <object> = <command-list>
  Attribute: Alfail
 
  Sets the action to be taken by an object when someone tries to leave
  it but fails because the player fails the object's leave lock.
 
  The leave lock only affects the 'leave' command and its aliases (set
  via the @ealias command), it does not affect going home, using an
  exit in the location, or teleporting out.
 
  This attribute is meaningful for players and things, and will never
  be automatically triggered on rooms or exits.
 
  Example:
  @alfail box = :rattles around as %n tries to escape.
 
  See also: @aleave, @lalias, @leave, @lfail, @oleave, @olfail, leave
  
& @alias
 
  Syntax: @alias <player> = <name>
  Attribute: Alias
 
  Provides an alternate name by which the player is known.  The
  alternate name is only used for players when referenced as
  '*<name>' or by commands that only take playernames (such as page
  or @stats).  You may not set an alias on any other object type.
 
  When setting an alias, the alias is checked to see that it is both a
  legal player name and not already in use.  Only if both checks
  succeed is the alias set.
  
& @amail
 
  Syntax: @amail <player> = <command-list>
  Attribute: Amail
 
  Sets the actions to be taken after a player receives @mail. This
 should *never* @mail another player, as this could cause an
 infinite loop.
 
  Example:
  @amail me=@mail/file [mail()]=2
 
  This would place all incoming messages in folder #2.
 
  See also: @mailsucc, @signature, @mail
  
& @amhear
 
  Syntax: @amhear <object> = <command-list>
  Attribute: Amhear
 
  Sets the actions to be taken after the object hears a string that
  matches  the pattern in the Listen attribute which was produced by
  the object itself.
 
  Messages that are produced by anything other than the object itself
  are ignored.
 
  Example:
  @amhear listener = "Wait a minute.  I said the trigger word!
 
  See also: @aahear, @ahear, @listen
  
& @amove
 
  Syntax: @amove <object> = <command-list>
  Attribute: Amove
 
  Sets the action to be taken by an object whenever it moves from one
  location to another, whether by using an exit, entering or leaving
  an object, teleporting, or going home.
 
  This attribute is meaningful for players, and things and will never
  be automatically triggered on other object types.
 
  Example:
  @amove car = @vz me=[extract(%vz,1,19)] [loc(me)]
 
  See also: @move, @omove
  
& @apay
 
  Syntax: @apay <object> = <command-list>
  Attribute: Apay
 
  Sets the actions to be taken after the object is given the number of
  coins specified in its Cost attribute.  If the giver tries to give
  more than that number of coins, the excess is refunded, and if
  less than the necessary  amount is given then it is all given back
  and a snide message is sent to the giver.
 
  This attribute is only meaningful for players and things, and will
  never be automatically triggered on other object types.
 
  Example:
  @apay Coke machine = @clone Can of Coke; :drops a can on the
  floor.
 
  See also: give, @cost, @opay, @pay
  
& @arfail
 
  Syntax: @arfail <object> = <command-list>
  Attribute: Arfail
 
  Sets the action to be taken by an object when someone tries to give
  it something that fails its give lock.
 
  Example:
  @arfail merchant = "I don't buy junk.  Begone!; @tel
  %#=cheater_exit
 
  See also: give, @agfail, @gfail, @ogfail, @orfail, @rfail, @lock
  
& @asuccess
 
  Syntax: @asuccess <object> = <command-list>
  Attribute: Asucc
 
  Sets the actions to be taken by an object when someone successfully
  picks it up (because they passed the lock), by an exit when
  someone passes through it, or when someone looks at a room and
  passes the room's lock.
 
  Example:
  @asucc kitten = :climbs up your sleeve and nuzzles your face.
 
  See also: @osucc, @success, SUCCESS
  
& @atfail
 
  Syntax: @atfail <object> = <command-list>
  Attribute: Atfail
 
  Sets the action to be taken by an object when someone tries to
  teleport there but fails.
 
  Example:
  @atfail here = @page [owner(me)]=%N tried to teleport here.
 
  See also: @teleport, @tfail, @otfail, @lock
  
& @atofail
 
  Syntax: @atofail <object> = <command-list>
  Attribute: Atofail
 
  Sets the action to be taken by an object when someone tries to
  teleport out but fails.
 
  Example: @atofail here = @page [owner(me)]=%N tried to teleport out.
 
  See also: @teleport, @tofail, @otofail, @lock
  
& @atport
 
  Syntax: @atport <object> = <command-list>
  Attribute: Atport
 
  Sets the actions to be performed by object whenever it teleports.
  The actions are performed after the object moves to its new
  location.
 
  This attribute is only meaningful for players and things, and will
  never be automatically triggered on other object types.
 
  Example:
  @atport me = &TEL.COUNT me=add(v(TEL.COUNT),1)
 
  See also: @otport, @oxtport, @tport, @teleport
  
& @aufail
 
  Syntax: @aufail <object> = <command-list>
  Attribute: Aufail
 
  Sets the list of commands to be run when someone 'use's the object
  but fails the object's use lock.  Note that the other functions
  controlled  by the use lock (paying, listening, and $-commands) do
  not trigger Aufail.
 
  Example:
  @aufail robot = "I _told_ you to leave me alone; kill %n=100
 
  See also: @oufail, @ufail, @use
  
& @ause
 
  Syntax: @ause <object> = <command-list>
  Attribute: Ause
 
  Sets the actions to be taken when someone uses the object with the
  use command.
 
  This attribute is only meaningful for players and things, and will
  never be automatically triggered on other object types.
 
  Example:
  @ause grenade = :EXPLODES; kill %n=100; @destroy me
 
  See also: use, @ouse, @use
  
& @away
 
  Syntax: @away <object> = <message>
  Attribute: Away
 
  This attribute is sent as a message to anyone who tries to page you
  when you are not connected.
 
  This attribute is only meaningful for players, and will never be
  automatically referenced on other object types.
 
  Example:
  @away me = Hey, I'm not even connected.  So why are you paging me?
 
  See also: @idle, @reject, page
  
& @cboot
 
  Syntax: @cboot <channel>=<object>
 
  Only wizards, or the owner of the channel can use this command. It
  forcefully removes an object from that channel.
 
  Note: You may specify a player name as <object> if you prefix it
  with an '*'. Otherwise, <object> should be a dbref, or a name of
  an object if you   are nearby it.
 
  See also: comsys
  
& @ccharge
 
  Syntax: @ccharge <channel>=<amount>
 
  This command imposes a charge of <amount> coins on transmitting over
  a channel. The default fee when a channel is created is 0. All
  proceeds benefit the channel owner.
  
& @cchown
 
  Syntax: @cchown <channel>=<player>
 
  Changes ownership of <channel> to <player>.
 
  See also: @clist, @cwho.
  
& @ccreate
 
  Syntax: @ccreate <channel name>
 
  Creates a channel with default settings. Only wizards can create a
  channel.
 
  See also: @cdestroy, @clist, @cchown
  
& @cdestroy
 
  Syntax: @cdestroy <channel>
 
  Deletes <channel> permanently from the comsystem database. It does
  not destroy all aliases that exist for <channel>, which is left to
  the owners of those aliases. Players are notified at login when
  they own aliases for which a channel no longer exists.
 
  See also: @clist, @ccreate, @cchown.
  
& @cemit
 
  Syntax: @cemit[/<switches>] <channel>=<message>
 
  Sends <message> over <channel> prefixed by the channel's name. You
  must own or control the channel to do this.
 
  The following switches are available:
     /noheader - Sends the message to everyone on <channel>, without
                 the channel's name prefixed.
 
  See also: cemit()
  
& @charges
 
  Syntax: @charges <object> = <count>
  Attribute: Charges
 
  This attribute allows you to limit the number of times an object can
  be used.  If there is a charges attribute it is decremented each
  time an action on the object is triggered.  Once it reaches zero,
  normal triggering stops and the Runout attribute (if one is
  present) is run instead.
 
  Example:
  @charges Fireball wand = 5
 
  See also: @runout
  
& @chown
 
  Syntax: @chown <object>[=<player>]
          @chown <object>/<attr>[=<player>]
 
  The first form changes the ownership of <object> to <player>
  (default is to yourself).  Objects may be things, rooms or exits.
  To chown things, you have to be carrying the thing. For rooms or
  exits, you have to be in the room. Objects must have the CHOWN_OK
  flag set before they may be @chowned. In a room, the command used
  must be @chown here = <name>, and for an object, you must be very
  specific.
 
  The second form changes the ownership of the indicated attribute on
  <object> to <player> (default is the owner of the object).  You
  may only @chown unlocked attributes.  You may @chown unlocked
  attributes on objects that you own to yourself, and you may also
  @chown attributes that you own on objects owned by others to the
  owner of the object.
 
  When an object is @chowned, all unlocked attributes on the object
  are automatically @chowned as well, locked attributes remain owned
  by their original owners.
 
  The HALTED flag is automatically set on the new copy of the object.
  Players can't be @chowned; they always own themselves.
 
  See also: @lock, @Unlock, CHOWN_OK, ATTRIBUTE OWNERSHIP
  
& @chzone
 
  Syntax: @chzone <object>=<zone object>.
 
  Changes the zone of <object> to <zone object>. If <zone object> is
  "none", the zone is reset to NOTHING.
 
  @chzone'ing a player does not automatically change the zone of their
  objects. Anyone may reset the zone of an object they own; <zone
  object> must either be "none", or must be owned by them. Only
  wizards may @chzone an object to an arbitrary zone object. Players
  may @chzone themselves to an object they own; otherwise, only
  wizards may @chzone players.
 
  @chzone'ing resets the WIZARD, ROYALTY, and INHERIT flags on
  non-player objects.
 
  See also: ZONE OBJECTS
  
& @clist
 
  Syntax: @clist[/full]
 
  Without any switches, it will display the list of public channels
  with their owner, and description. It will also display all
  channels you own.
 
  With the /full switch, it will display the various channel
  statistics.
 
  See also: @ccreate, @cdestroy, @cchown
  
& @clone
 
  Syntax: @clone[/<switches>] <object>[=<newname/cost>]
 
  Creates an exact duplicate of <object> that is owned by you and (for
  things and exits) puts it in your current location.  You may have
  the object put in your inventory (or your exitlist in the case of
  cloning exits) by using the /inventory switch.
 
  You may clone your own objects, plus VISUAL objects owned by others.
  The INHERIT and WIZARD bits of the (new) object are cleared when the
  object is cloned.  If <newname> is specified, it is used as the
  name instead of the original name.
 
  If you clone a linked exit, an attempt is made to link the clone to
  the same location.  Except when using the /inventory switch, you
  can only clone exits when you own your current location.
 
  If you clone a room with a drop-to, an attempt is made to link the
  drop-to to the same location.
 
  If the original object was owned by you, then the ACLONE attribute
  is run in the new attribute, otherwise the new object is set
  HALTED.  Exits and contents of cloned objects are not cloned, and
  LOCKED attributes are not copied.
 
  { 'help @clone2' for more}
  
& @clone2
 
  The following switches are available:
 
  /cost       - Treat the argument after the = as the cost of the new
                object, not the name.
  /inherit    - Don't reset the INHERIT bit on the new object.
  /inventory  - Create the new object in your inventory (or your
                exitlist, in the case of cloning exits).
  /location   - Create the new object in your location (default).
  /parent     - Set the new object's parent to be the template
                object and don't copy the attributes.
 
  See also: @create, @decompile, @destroy, VISUAL.
  
& @coflags
 
  Syntax: @coflags <channel>=[!]flag
 
  Sets object flags for that channel. The flag can be one of: join,
  transmit, or receive.
 
  Transmit: Whether an object can broadcast things over the channel.
  Join: Whether an object can join the channel.
  Receive: Whether a object can receive messages over the channel.
 
  If it is !flag, then that flag is reset. Note that channel flags
  ALWAYS override locks on channel objects.
 
  See also: @coflags, @clist, CHANNEL OBJECT
  
& @cost
 
  Syntax: @cost <object> = <amount>
  Attribute: Cost
 
  Sets the number of coins that need to be given to an object to
  trigger the Pay, Opay, and Apay attributes.  If the object is
  given more than this amount, the excess is returned to the giver,
  while if less than this amount is given the entire amount is
  returned, a snide message is sent to the giver, and the Apay,
  Opay, and Pay attributes are not used.
 
  This attribute is only meaningful for things, and will never be
  automatically triggered on other object types.
 
  Example:
  @cost Coke machine = 25
 
  See also: give, @apay, @opay, @pay
  
& @cpattr
 
  @cpattr <obj>/<attr> = <obj1>/<attr1> [,<obj2>/<attr2>,
  <obj3>/<attr3>,...]
  @cpattr <obj>/<attr> = <obj1> [,<obj2>,<obj3>,...]
  @cpattr <attr> = <obj1>/<attr1> [,<obj2>/<attr2>,<obj3>/<attr3>,...]
  @cpattr <attr> = <obj1> [,<obj2>,<obj3>,...]
 
  The first form of this command is used to copy <attr> on <obj> to
  the object-attribute pairs in a comma-separated list. For example:
 
  @cpattr test/va = test/vb, cube/va, tribble/foo
 
  would copy the VA attribute from object "test" to VB on "test",
  VA on "cube", and FOO on "tribble".  <objN> is matched as if
  you were performing a @set on it.
 
  The second form copies <attr> to the list of objects, with the name
  <attr>. The third form copies <attr> from the object that executes
  the @cpattr, to the object-attribute pairs in the list. Finally,
  the third form copies <attr> from the object that executes the
  @cpattr to the objects in the list, with the name <attr>.
  
& @cpflags
 
  Syntax: @cpflags <channel>=[!]flag
 
  Sets player flags for that channel. The flag can be one of: join,
  transmit, or receive.
 
  Transmit: Whether a player can broadcast things over the channel.
  Join: Whether a player can join the channel.
  Receive: Whether a player can receive messages over the channel.
 
  If it is !flag, then that flag is reset. Note that channel flags
  ALWAYS override locks on channel objects.
 
  See also: @coflags, @clist, CHANNEL OBJECT
  
& @create
 
  Syntax: @create <name> [=<cost>]
 
  Creates a thing with the specified name.  Creation costs either
  <cost> or 10 coins, whichever is greater. The value of a thing is
  proportional to its cost, specifically, value=(cost/5)-1.  The
  value may not be greater than 100, values that would be greater
  than 100 are rounded down to 100.
 
  See also: @destroy, TYPES OF OBJECTS
  
& @cset
 
  Syntax: @cset/<option> <channel>
 
  Changes the way a channel behaves.  <option> can be one of the
  following: public, private, loud, mute, quiet, object.
 
  Public makes it show up on everyone's @clist, private hides it.
  Loud makes it announce connects/disconnects.  Mute/quiet, shuts
  them off.
 
  The object switch sets the channel object to whatever you specify.
  It will allow you to set a description for the @clist, by @descing
  the  object.  Also, the lock will be used to check to see if people
  should be able to join the channel or not.
 
  See help channel object for more.
  
& @cstatus
 
  Syntax: @cstatus[/full] <channel>
  
  Returns status details of the specified channel.
  
  With the /full switch it will display the various statistics.
  
  Example
  >@cstatus Public
  ** Channel       Owner           Description
  P- Public        World           General discussion
  -- End of list of Channels --
  
  See Also: comsys 
& @cwho
 
  Syntax: @cwho <channel>[/all]
 
  For channels that you own, identifies all connected players on the
  channel and their stats for the channel. If switch is /all, then
  it also displays unconnected players.
 
  See also: @clist
  
& @daily
 
  Syntax: @daily <object>=<command-list>
  Attribute: Daily
 
  This attribute is automatically triggered once per day. No
  guarantees are made as to what time it will execute.
  
& @decompile
 
  Syntax: @decompile[/dbref] <thing>[/attr] [=<newname>]
 
  Dumps the sequence of commands you would have to type to clone
  <thing>. This is handy for saving your objects in a text file in
  case the MUX dies a horrible death, or for moving your pride-and-
  joy creation from one MUX to another.  @decompile works on all
  object types.
 
  If you specify <newname>, then the commands emitted will set
  attributes, locks, and flags on an object named <newname> and will
  omit the command to create the object.
  If you specify <thing>/<attr>, <attr> accepts wildcards.
  If you specify the /dbref switch, you will get output using the
  dbref number instead of the object name.
 
  See also: examine, look.
  
& @describe
 
  Syntax: @describe <object> = <description>
  Attribute: Desc
 
  Sets the description for <object>, which others see when they look
  at the object.  Giving all your objects, rooms, and exits good
  descriptions is considered to be good building practice.
 
  Function references and %-substitutions are allowed in descriptions,
  and are evaluated when someone looks at the object.  In function
  references, 'me' refers to the object being looked at, while %-
  substitutions that refer to the enactor (such as %n, %#, %p, etc)
  refer to the looker.
 
  Examples:
    <object> @desc vase = You see a delicate Ming vase.
    <exit>   @desc elevator = There is an elevator to the east.
 
  See also: look, @adescribe, @odescribe
  
& @destroy
 
  Syntax: @destroy[/<switches>] <object>
 
  This command destroys <object> and refunds its cost of creation to
  its owner.  You must own <object> in order to @destroy it, unless
  its DESTROY_OK flag is set, in which case anyone holding it may
  @destroy it.
 
  Rooms, exits, and objects may be destroyed, although the the actual
  destruction of rooms is delayed for up to ten minutes and the GOING
  flag is set on the victim room.  Clearing the GOING flag on the
  room spares it from destruction.
 
  If a thing OR it's owner is set DESTROY_OK, the thing will be
  destroyed with no delay.
 
  The @destroy command will not destroy objects with the SAFE flag set
  unless the /override switch is specified.  The DESTROY_OK flag
  overrides the protection given by the SAFE flag.
 
  The following switches are available:
    /override  - Negate protection offered by the SAFE flag.
 
  See also: DESTROY_OK, SAFE
  
& @dfail
 
  Syntax: @dfail <object> = <message>
  Attribute: Dfail
 
  Sets the message that a player sees when he tries to drop the object
  but fails because he didn't pass the object's drop lock.
 
  Function references and %-substitutions are allowed in drop failure
  messages, and are evaluated when someone drops the object.  In
  function references, 'me' refers to the object being dropped,
  while %-substitutions that refer to the enactor (such as %n, %#,
  %p, etc) refer to the dropper.
 
  This attribute is only meaningful for players and things, and will
  never be automatically triggered on other object types.
 
  Example:
  @dfail sword = The sword has welded itself to your hand.
 
  See also: drop, @adfail, @odfail, @lock
  
& @dig
 
  Syntax: @dig[/<switches>] <name> [= <exitlist> [, <exitlist>] ]
 
  Creates a new room with the specified name and displays its number.
  This command costs 10 coins. If the [= <exitlist>] option is used,
  an exit will be opened from the current room to the new room
  automatically.  If the second <exitlist> option (after the comma)
  is specified, an exit from the new room back to the current room
  with the specified [Exits] name is opened.  Either exit creation
  may fail if you do not have sufficient rights to the current room
  to open or link the new exit.
 
  Example: The command
 
     @dig Kitchen = Kitchen;k;north;n,south;s
 
  will dig a room called Kitchen, and open an exit called 'Kitchen' in
  your current room.  The ; symbol means that you may enter the exit
  by typing 'k', 'north' or 'n' also.  This command also opens the
  exit 'south;s' from 'Kitchen' back to where you are.  Only the
  first Exit name is displayed in the Obvious exits list.
 
  If you specify the /teleport switch, then you are @teleported to the
  room after it is created and any exits are opened.
 
  See also: @destroy, @link, @open, LINKING, TYPES OF OBJECTS
  
& @doing
 
  Syntax: @doing[/<switches>] [<message>]
 
  Sets your doing message, which appears after your name in the WHO
  report.
 
  The following switches are available:
     /message - Sets your Doing string in the WHO report. (default)
     /poll    - Displays the current Doing poll from the WHO report.
 
  See also: WHO, @poll
  
& @dolist
 
  Syntax: @dolist[/<switch>] [<delimiter>] <list>=<action>
 
  <list> is a list of strings, which can be object numbers,
  attributes, or arbitrary words.  <action> is a command to perform
  once for each item in <list>, replacing the special symbol ## with
  the corresponding item from <list>, and the symbol #@ with the
  position in the list, starting with one. By default, @dolist
  considers each item in <list> to be separated with spaces. If you
  specify the /delimit switch, then each item is considered to be
  separated by <delimiter>. <delimiter> must be a single character.
 
  If present, <switch> can be any of:
    /space   - (Default) List elements are separated by spaces.
    /delimit - List elements are separated by <delimiter>.
 
  This command is particularly handy with lcon() and lexits(). A few
  examples:
 
    @dolist [lcon(here)] = "[name(##)](##)
    @dolist [lcon(here)] = @switch [get(##/last)]=*1990*,"[name(##)]
    @va me = va vb vc
    @dolist [get(me/va)] = @emit [get(me/##)]
    @dolist Frodo Bilbo Gandalf = page ## = HELP!!!!  I've fallen into
    a pit.
    @dolist/delimit , {Frodo, Bilbo Baggins, Gandalf} = page ## =
    HELP!!!!
 
  See also: iter(), parse()
  
& @drain
 
  Syntax: @drain <object>
 
  Discards all commands waiting on the semaphore <object> and resets
  the semaphore to its initial state.
 
  See also: @notify, @ps, SEMAPHORES
  
& @drop
 
  Syntax: @drop <object> = <message>
  Attribute: Drop
 
  Sets the message that a player sees when he drops the object, or
  after he goes through the exit.
 
  Function references and %-substitutions are allowed in drop
  messages, and are evaluated when someone drops the object.  In
  function references, 'me' refers to the object being dropped,
  while %-substitutions that refer to the enactor (such as %n, %#,
  %p, etc) refer to the dropper.
 
  This attribute is only meaningful for players and things, and will
  never be automatically triggered on other object types.
 
  Examples:
  <object> @drop vase = You gently put down the delicate vase.
  <exit>   @drop elevator = The elevator doors close behind you.
 
  See also: drop, @adrop, @odrop, DROP-TO, EXITS
  
& @ealias
 
  Syntax: @ealias <object> = <entrance-list>
  Attribute: Ealias
 
  Sets up a set of alternate commands that may be used as synonynms
  for the command 'enter <object>' when you are in the same location
  as the object.
 
  The alternate commands are separated by semicolons just like in exit
  names.
 
  Entry aliases are checked for after exitnames, builtin MUX commands,
  and leave aliases for the current location, but before $-commands.
  If more than one object has an entry alias that matches a player's
  command, the one on the object that occurs first in the location
  contents list is used.
 
  This attribute is meaningful for players and things, and will never
  be automatically looked at on rooms or exits.
 
  Example:
  @ealias car = get in car; car; climb in; go for a ride
 
  See also: @lalias, enter, leave
  
& @edit
 
  Syntax: @edit <object>/<wild-attr> = <search>,<replace>
          @edit <object>/<wild-attr> = ^,<text>
          @edit <object>/<wild-attr> = $,<text>
 
  This command edits the contents of one or more attributes of an
  object, eliminating the need to retype a long attribute in order
  to make a simple change.  In the first form, all occurrences of
  <search> in the specified attribute of the named object are
  replaced with <replace>.  Use curly braces ({ and }) around
  <search> or <replace> if they contain commas.
 
  The second and third form prepend and append <text> to the selected
  attributes, respectively.
 
  If <wild-attr> contains wildcard characters, then all attributes
  that match are edited.
  
& @efail
 
  Syntax: @efail <object> = <command-list>
  Attribute: Efail
 
  Sets the message that a player sees when he tries to enter the
  object but fails because the object is not ENTER_OK or the player
  fails the object's enter lock.
 
  Function references and %-substitutions are allowed in efail
  messages, and are evaluated when someone fails to enter the
  object.  In function references, 'me' refers to the object that
  the enactor tried to enter, while %-substitutions that refer to
  the enactor (such as %n, %#, %p, etc) refer to the the player who
  tried (and failed) to enter.
 
  The enter lock only affects the 'enter' command and its aliases (set
  via the @ealias command), it does not affect exits that lead to
  the object or teleporting in.
 
  This attribute is meaningful for players and things, and will never
  be automatically triggered on rooms or exits.
 
  Example:
  @efail car = The car's door is locked.
 
  See also: @aefail, @aenter, @ealias, @enter, @oefail, @oenter,
  enter, ENTER_OK
  
& @emit
 
  Syntax: @emit[/<switches>] <message>
 
  Sends <message> to everyone in your current location without
  prefixing it by your character name.  You can also send the
  message to everyone in the room that contains the object you are
  inside with the /room switch.
 
  The following switches are available:
  /here  - Sends the message to everyone in the same location as you.
  /room  - Sends the message to everyone in the room that contains the
           object you are in.  Starting from your location, this
           switch 'leaves' objects until it reaches a
           room, and @emits the message there.
 
  If both switches are specified, the message is sent to both places.
 
  If neither is specified, /here is assumed.
 
  Some MUXes may restrict the use of this command.
 
  See also: @femit, @oemit, @pemit, @npemit, @remit, SPOOFING
  
& @enter
 
  Syntax: @enter <object> = <message>
  Attribute: Enter
 
  Sets the message that a player sees when entering an object or room,
  whether by using an exit, the enter or leave commands, or by
  teleporting.
 
  Function references and %-substitutions are allowed in enter
  messages, and are evaluated when someone enters the object.  In
  function references, 'me' refers to the object being entered, while
  %-substitutions that refer to the enactor (such as %n, %#, %p,
  etc) refer to the player entering the object.
 
  This attribute is meaningful for players, things, and rooms, and
  will never be automatically triggered on exits.
 
  Example:
  @enter car = You climb into the car and buckle your seatbelt.
 
  See also: enter, @aenter, @oenter, ENTER_OK
  
& @entrances
 
  Syntax: @entrances [[<object>][,<low>[,<high>]]]
 
  Lists links from elsewhere to the specified object (default: your
  current room).  For rooms, exits and drop-to's, leading to the
  room and players and objects whose home is in the room are listed.
  For players and objects, lists exits leading to them.  Because
  this command is computationally expensive, it costs 100 coins.
  <low> and <high> can be used to indicate where to start and stop
  the search, respectively.
 
  Examples:
    > @entrances             <- all links to here
    > @entrances object      <- all links to object
    > @entrances ,100,200    <- all links to here from #100 to #200
    > @entrances me,1000     <- all links to me from #1000 and above.
 
  See also: @link, @unlink
  
& @fail
 
  Syntax: @fail <object> = <message>
  Attribute: Fail
 
  Sets the failure message for <object>.  This message is seen by the
  actor when one of these events occurs:
 
    - For exits: Someone tries to traverse the exit but cannot because
      they fail the exit's default lock or the exit is not linked.
    - For players and things: Someone tries to pick up the object but
      cannot because they fail the object's default lock.
    - For rooms, players, and things: Someone looks around inside the
      room, player, or thing and fails the object's default lock.
 
  Substitution and evaluation is performed on the message before it is
  shown.
 
  Example:
    <thing>
    > @fail table = It's too heavy to lift!                       
 
    <exit>
    > @fail doorway = The doorknob does not turn.                  
 
  See also: get, @afail, @ofail, FAILURE
  
& @femit
 
  Syntax: @femit[/<switches>] <object>=<message>
 
  Forces <object> to emit <message>.  This command is similar to the
  command '@force <object> = @emit <message>', except that it will
  work so long as you own the object, whereas @force may fail if the
  object has its INHERIT flag set and the object performing the
  @force does not.
 
  The following switches are available:
     /here  - Sends the message to everyone in the same location as
              <object>.
     /room  - Sends the message to everyone in the room that contains
              the object that <object> is in.  Starting from your
              location, this switch 'leaves' objects until it reaches
              a room, and @emits the message there.
 
  If both switches are specified, the message is sent to both places.
 
  If neither is specified, /here is assumed.
 
  Some MUXes may restrict the use of this command.
 
  See also: @remit, @emit, @fpose, @fsay, INHERIT, SPOOFING
  
& @filter
 
  Syntax: @filter <object> = <pattern>[, <pattern>...]
  Attribute: Filter
 
  This attribute specifies a series of patterns to be used to suppress
  text normally forwarded by the AUDIBLE flag.  If the desired pattern
  contains a comma, the pattern may be enclosed in curly braces {}.
 
  Example:
    > @fo test=out
    > @set #378=puppet
    test> test grows ears and can now hear.
    > @filter out = {* has arrived.},{* has left.}
    Set.
    > :has not arrived.
    Wizard has not arrived.
    test> From a distance, Wizard has not arrived.
    > :has arrived.
    Wizard has arrived.
 
  See also:  AUDIBLE, @forwardlist, @infilter, @inprefix, @prefix
  
& @find
 
  Syntax: @find <name>[,<low>[,<high>]]
 
  Displays the name and number of every room, thing, or player that
  you control whose name matches <name>. Because the command is
  computationally expensive, it costs 100 coins.
 
  <low> and <high> may be used to restrict the range of objects that
  are searched, if they are given then the search starts at object
  #<low> And ends t object #<high>.
 
  Examples:
    > @find Lost Room
    > @find Secret Device,12000,14000
 
  See also: @search
  
& @force
 
  Syntax: @force <player/object>=<command>
 
  Forces the game to act as though <player/object> had entered
  <command>.
 
  You may only force objects that you control.  Objects may not force
  players unless either the object or the player has their INHERIT
  flag set, and objects that do not have their INHERIT flag set may
  not force objects that do.  If the victim is specified by number,
  you may use an alternate form of the command, '#<number> <command>'.
 
  See also: puppets
  
& @forwardlist
 
  Syntax: @forwardlist <object> = <dbref-list>
  Attribute: Forwardlist
 
  Specifies a list of locations (specified by their db numbers) that
  are to receive messages heard by <object> (filtered by the @filter
  attribute and prefixed by the @prefix attribute).  The messages
  are only forwarded if object> has its AUDIBLE flag set.
 
  See also: @filter, @prefix, AUDIBLE
  
& @fpose
 
  Syntax: @fpose[/<switches>] <object>=<message>
 
  Forces <object> to pose <message>.  This command is similar to the
  command '@force <object> = :<message>', except that it will work
  so long as you own the object, whereas @force may fail if the
  object has its INHERIT flag set and the object performing the
  @force does not.
 
  The following switches are available:
     /default - (default) Put a space between the name of the object
                and the message (ie, send '<name> <message>').
     /nospace - Don't put a space between the name of the object and
               the message (ie, send '<name><message>').
 
  See also: @femit, @fsay, pose, :, ;, INHERIT
  
& @fsay
 
  Syntax: @fsay <object>=<message>
 
  Forces <object> to say <message>.  This command is similar to the command
  '@force <object> = say <message>', except that it will work so long as you
  own the object, whereas @force may fail if the object has its INHERIT flag
  set and the object performing the @force does not.
 
  See Also: @femit, @fpose, INHERIT, say.
  
& @gfail
 
  Syntax: @gfail <object> = <message>
  Attribute: Gfail
 
  Sets the message that a player sees when he tries to give away the
  object but fails because he didn't pass the object's give lock.
 
  Function references and %-substitutions are allowed in give failure
  messages, and are evaluated when someone tries to give away the
  object.
 
  In function references, 'me' refers to the object being given away,
  while %-substitutions that refer to the enactor (such as %n, %#,
  %p, etc) refer o the (attempted) giver.
 
  This attribute is only meaningful for players and things, and will
  never be utomatically triggered on other object types.
 
  Example:
  @gfail sword = You can't give away a cursed sword!
 
  See also: give, @agfail, @ogfail, @lock
  
& @halt
 
  Syntax: @halt [<object>]
 
  Halts all commands being run by <object>, or by the object running
  the command if no <object> is given.  If the object to be halted
  is a player, then all commands being run by objects owned by that
  player are halted.
 
  Use this command to stop runaway objects and infinite loops.
 
  The process of halting an object involves removing all commands
  waiting to be run by the object from the queue and refunding the
  queue deposit.
 
  Halting an object does not affect commands waiting on it as a
  semaphore.
 
  See also: @drain, @notify, kill, HALTED, SEMAPHORES
  
& @idesc
 
  Syntax: @idesc <object> = <message>
  Attribute: Idesc
 
  Sets the internal description for <object>.  The internal
  description of an bject will be shown to any player entering it.
  If not set, the regular description in the Desc attribute is shown
  instead.
 
  Function references and %-substitutions are allowed in inside
  descriptions, and are evaluated when someone fails to get or look
  at the object.
 
  In function references, 'me' refers to the object being looked at,
  while %-substitutions that refer to the enactor (such as %n, %#,
  %p, etc) refer to the player doing the looking.
 
  This attribute is only meaningful for players and things, and will
  never be automatically triggered on other object types.
 
  Example:
  @idesc car = You are sitting in the driver's seat of a Volkswagen
  Beetle.
 
  See also: enter, @describe, ENTER_OK
  
& @idle
 
  Syntax: @idle <object> = <message>
  Attribute: Idle
 
  This attribute is sent as a message to anyone who successfully pages
  you.
 
  It can be used to tell someone who pages you when you will return
  (if you are going to be away for a while).
 
  This attribute is only meaningful for players, and will never be
  automatically referenced on other object types.
 
  Example: @idle me = At dinner.  Back about 7PM.
 
  See also: @away, @reject, page
  
& @infilter
 
  Syntax: @infilter <object> = <pattern>[, <pattern>...]
  Attribute: Infilter
 
  This attribute specifies a series of patterns to be used to suppress
  text normally sent to the contents of <object> by @listen.  If the
  desired pattern contains a comma, the pattern may be enclosed in
  curly braces {}.
 
  Example:
    > @listen sports car=*
    > @fo test=enter sports car
    test has left.
    test> Sports Car(#383Q)
    > :waves.
    test> Wizard waves.
    Wizard waves.
    > @infilter sports = *waves*
    > :waves.
    Wizard waves.
    > :knocks on the window.
    test> Wizard knocks on the window.
    Wizard knocks on the window.
 
  See also:  @filter, @inprefix, @listen, @prefix
  
& @inprefix
 
  Syntax: @inprefix <object> = <prefix text>
  Attribute: Inprefix
 
  This attribute, when set, will prefix all text that is sent to the
  contents of <object> by @listen.  The default is to have no
  prefix, the text is forwarded unadorned.
 
  Example:
    > @listen sports car=*
    > @fo test=enter sports car
    test has left.
    test> Sports Car(#383Q)
    > :waves.
    test> Wizard waves.
    Wizard waves.
    > @inprefix sports car = In the mundane world outside,
    test> In the mundane world outside, Wizard waves some more.
    Wizard waves some more.
 
  See also: @filter, @infilter, @listen, @prefix
  
& @kill
 
  Syntax: @kill <object> = <message>
  Attribute: Kill
 
  This command sets the message that is shown to anyone who kills
  <object>.
 
  This attribute is only meaningful for players and things, and will
  never be automatically triggered on other object types.
 
  Function references and %-substitutions are allowed in kill
  messages, and are evaluated when someone kills the object.  In
  function references, 'me' refers to the object that was killed,
  while %-substitutions that refer to the enactor (such as %n, %#,
  %p, etc) refer to the player doing the killing.
 
  Example:
  @kill guard = The guard says "I'll get.. you... for...this... %n"
  as he falls down and dies.
 
  See also: kill, @akill, @okill, BEING KILLED, IMMORTAL, WIZARD
  
& @Lalias
 
  Syntax: @lalias <object> = <entrance-list>
  Attribute: Lalias
 
  Sets up a set of alternate commands that may be used as synonynms
  for the command 'leave' when you are inside a player or a thing.
  The alternate commands are separated by semicolons just like in
  exit names.
 
  Leave aliases are checked for after exitnames and builtin MUX
  commands, but before enter aliases and $-commands.
 
  This attribute is meaningful for players and things, and will never
  be automatically looked at on rooms or exits.
 
  Example: @lalias car = get out;climb out;out;open door;outside
 
  See also: @ealias, enter, leave
  
& @last
 
  Syntax: @last <player>
 
  This command displays a short 'connection history' for <player>,
  showing recent successful and failed connection attempts, as well
  as the total number of successful and failed connections.
  You can only display information about yourself.
  
& @leave
 
  Syntax: @leave <object> = <message>
  Attribute: Leave
 
  Sets the message that a player sees when leaving an object or room,
  whether by using an exit, the enter or leave commands, or by
  teleporting.
 
  Function references and %-substitutions are allowed in leave
  messages, and are evaluated when someone leaves the object.  In
  function references, 'me' refers to the object being left, while %
  -substitutions that refer to the enactor (such as %n, %#, %p, etc)
  refer to the player leaving the object.
 
  This attribute is meaningful for players, things, and rooms, and
  will never be automatically triggered on exits.
 
  Example:
  @leave car = You unbuckle your seatbelt and climb out of the car.
 
  See also: leave, @aleave, @oleave
  
& @lfail
 
  Syntax: @lfail <object> = <command-list>
  Attribute: Lfail
 
  Sets the message that a player sees when he tries to leave it but
  fails because the player fails the object's leave lock.
 
  The leave lock only affects the 'leave' command and its aliases (set
  via the @ealias command), it does not affect going home, using an
  exit in the location, or teleporting out.
 
  This attribute is meaningful for players and things, and will never
  be automatically triggered on rooms or exits.
 
  Example:
  @lfail plane = You don't have a parachute!
 
  See also: @aleave, @alfail, @lalias, @leave, @oleave, @olfail, leave
  
& @link
 
  Syntax: @link <object>=#<number>/here/home
 
  When used on a player or a thing, this command sets the object's
  home to the indicated location.  The destination must be owned by
  you or be an ABODE room, and you must pass the destination's
  LinkLock.
 
  When used on a room, this command sets the room's drop-to, where
  objects dropped in the room go.  The destination must be a room
  that is either owned by you or is LINK_OK, and you must pass the
  destination's LinkLock.
 
  For exits, this command sets the destination if the exit is
  currently unlinked, you control the destination or it is set
  LINK_OK, and you pass the destination's LinkLock.  You can @link
  an unlinked exit regardless of who owns it or the lock set on it,
  you are made the owner if you successfully link to the destination.
 
  Linking an exit costs 1 coin, and if the exit was owned by someone
  else, you also reimburse the the former owner 1 coin (making the
  total cost to you 2 coins).
 
{ 'help @link2' for more }
 
& @link2
 
  Note that in all the above cases that it is the player performing
  the @link command that must pass the LinkLock, not the object
  being linked. Therefore, you should use the '$' lock qualifier if
  you want to prevent specific players from linking to your LINK_OK
  locations, as simply locking against '*<playername>' does not lock
  out their puppets.
 
  See also: @dig, @open, @unlink, DROP-TOS, HOMES, LINKING.
 
& @list
 
  Syntax: @list [<option>]
 
  Lists information from internal databases.  Information is available
  about the following options:
    attributes      - Valid object attributes.
    commands        - Commands that you may use (excluding the
                      attribute-setting commands as well as any exits,
                      and $-commands available).
    costs           - Lists the costs associated with many commands
                      and actions.
    default_flags   - Lists the flags that new objects receive by
                      default when created.
    flags           - Lists the name and letter of all the flags.
    functions       - Lists all the available functions.
    options         - Lists several global options and limits.
    powers          - Lists all powers.
    switches        - Lists what commands support switches and the
                      switches that they do support.
  The information provided by the @list command is definitive, as it
  reads the internal tables to produce the information it displays.
 
  Specifying @list with no argument lists the options you may use.
  
& @listen
 
  Syntax: @listen <object> = <string>
  Attribute: Listen
 
  This attribute contains a wildcard pattern that the object listens
  for. Anything spoken, posed, emitted, or whispered in the room
  that <object> is in, as well as messages resulting from using
  objects (such as Opay and Succ messages) are checked against the
  Listen attribute.  When the object hears something that matches
  the pattern, it triggers the Ahear attribute, as well as either
  the Amhear or Aahear attributes, as appropriate, substituting %0
  the string that matched the first wildcard character in the
  Listen, %1 for the second. etc.  If the pattern in the Listen
  attribute is matched, objects in <object>'s inventory will also
  hear the message and have a chance to match it.  Objects whose
  Listen attribute is set to anything will be listed when a @sweep
  command is run by someone in the same room.
 
  If the @listen pattern is matched, then the object's contents will
  hear the message also, prefixed by the text in @inprefix if it is
  set.  Any  text that matches any pattern specified in @infilter
  will not be sent to the contents.
 
  Example:
      @listen camera = * has arrived.
      @ahear camera = @va me = %va %0
 
  See also: @aahear, @ahear, @amhear, @sweep, @inprefix, @infilter
  
& @listmotd
 
  Syntax: @listmotd
 
  Displays the current message-of-the-day.  Note that it is displayed
  when you connect to your character. This will also display the
  "motd.txt" file.
  
& @lock
 
  Syntax: @lock[/<whichlock>] <object>=<key>
           @lock <object>/<attrib>
 
  The first form locks <object> to a specific key(s).  Type 'help
  @lock keys' for a list of the keys you may use.
 
  <whichlock> indicates which lock you want to set on the object.
  If you don't specify one, you set the Default lock. Type 'help
  @lock locks' for a list of the locks you may set and what they are
  used for.
 
  The second form locks the indicated attribute of the named object,
  so that when the object is @chowned, the attribute will remain
  owned by you. It may also be used when you own an attribute on an
  object that you do not own, in this case it prevents the object's
  owner from @chowning the attribute to himself, and prevents anyone
  from modifying or removing the attribute.
 
  See also: @chown, @unlock, @lock locks, @lock keys, @lock attribute,
  @lock evaluation, @lock indirect, @lock normal, @lock is,
  @lock carry, @lock ownership, @lock compound
 
& @lock attribute

  ATTRIBUTE LOCKS:

  Key: <attribute>:<pattern>
       +<attribute>:<wildcard-pattern>
       =<attribute>:<wildcard-pattern>

  You may lock on whether a specific attribute on the player
  attempting to pass the lock matches a pattern.  Example: '@lock
  thing=sex:m*' will lock thing to anyone whose sex starts with an M.
  Wild cards, greater than and less than may be used, for example:
  '@lock a-f=name:<g' will lock the exit a-f against any one whose
  name is higher than f.

  Both the player testing the lock and every object in his inventory
  is checked, the player passes the lock if any of those objects
  passes the lock. If the attribute name is prefixed by a = then
  only the player is checked. Similarly, if the attribute name is
  prefixed by a + then only objects in the player's inventory are
  tested.

{ 'help @lock attribute2' for more}
. 
& @lock attribute2
 
  Note: you may lock against any attribute, but the locked object
  must be able to read the attribute from the player attempting to
  pass the lock or the lock will fail.
 
  Examples:
    > @lock men's room=sex:m*
    > @lock a-f=name:<g
    > @lock post office=email:*@*
  See also: ATTRIBUTE OWNERSHIP, @lock evaluation.
. 
& @lock carry
 
  CARRY LOCKS:
 
  Key: +<object>
 
  You pass a carry lock if you are carrying the named object.
 
  Example:
    > @lock secret passage = +magic bus
    You can only traverse the secret passage if you are carrying the
    magic bus.  The bus cannot enter the passage on its own (perhaps
    when you are driving it).
  See also: @lock is, @lock normal.
. 
& @lock compound
 
  COMPOUND LOCKS:
 
  Key: <key> & <key>
       <key> | <key>
       !<key>
       ( <key> )
 
  You can make complex locks by combining keys with the logical AND
  and OR operators (& and ! respectively), or by using the NOT
  operator.  You may also group complex locks with parentheses.
 
  Examples:
    > @lock exit = me & !me
    An impossible lock, nothing can be both you and not you.
 
    > @lock message = me | *recipient
    Both you and the player recipient may get the msssage.
. 
& @lock evaluation
 
  EVALUATION LOCKS:
 
  Key: <attribute>/<value>
 
  Evaluation locks let you evaluate one of your attributes and compare
  the result against a value stored in the lock.  The result must be
  an exact match (no wildcarding allowed, but uppercase and lowercase
  are considered to be the same).  When evaluating the attribute the
  enactor substitutions (%#/%n/etc) are replaced with information
  about the player trying to pass the lock, and 'me' and %! refer to
  the locked object or exit.
 
  If you call an indirect lock and the indirect lock is an evaluation
  lock (or is a compound lock that includes an evaluation lock),
  then the original lock object is checked for the attribute first,
  followed by the object that has the actual evaluation lock.  If
  there are multiple levels of indirection the intermediate locks
  are not checked.
 
{ 'help @lock evaluation2' for more }
. 
& @lock evaluation2
 
  Examples:
    > @lock bank=checkmoney/1
    > &checkmoney bank=[gt(money(%#),5000)]
    Only people and objects with more than 5000 pennies may pass.
    Note: this lock requires wizard privileges to read the worth of
    other players.
 
    > @lock divisible_by_five_club = checkdiv/0
    > &checkdiv divisible_by_five_club = [mod(mid(%#,2,20),5)]
    Only objects whose db-number is divisible by 5 may pass.
  See also: @lock attributes.
.
& @lock indirect

  INDIRECT LOCKS:

  Key: @<object>

  You may reference the lock on another object and use the result of
  evaluating that other object's lock.    You pass an indirect lock if
  you pass the default lock on <object>.  This is especially useful
  if you have a large number of objects or exits that want to have
  the same lock, and you want to be able to update one object and
  have all the other locks change at the same time.

  <object> is searched for when you enter the @lock command and its
  database number is stored in the lock, so something like
  '@Lock north=@master.lock' is safe even if you are going to move
  master.lock to another location.

  Examples:
    > @lock master.lock = me
    > @lock north = @master.lock
    > @lock south = @master.lock
    North and south all reference the lock on master.lock, so you may
    change the lock on all three exits by changing master.lock.
  See also: @lock normal.

& @lock is

  IS LOCKS:

  Key: =<object>

  You pass an is lock only if you are the named object.

  Example:
    > @lock mystical highway = =magic bus
  Only the magic bus may travel down the mystical highway.  You
  cannot travel the highway if you are carrying the bus.

  See also: @lock carry, @lock normal.

& @Lock keys

  You may use the following keys when setting locks.  For information
  about a particular type of key, type 'help @lock <keytype>'.

  Key Type    Form in @Lock Command
  ----------  ------------------------------
  Normal      <object>
  Is          =<object>
  Carry       +<object>
  Ownership   $<object>
  Indirect    @<object>
  Attribute   <attribute>:<wildcard-pattern>
              +<attribute>:<wildcard-pattern>
              =<attribute>:<wildcard-pattern>
  Evaluation  <attribute>/<value>
  Compound    <key> & <key>
              <key> | <key>
              !<key>
              ( <key> )

& @lock locks

  You can set the following locks:

     DefaultLock:  Exits:          controls who may traverse the exit
                                   to its destination.
                   Rooms:          controls whether the player sees
                                   the SUCC or FAIL message for the
                                   room following the room
                                   description when looking at the
                                   room.
                   Players/Things: controls who may GET the object.
     EnterLock:    Players/Things: controls who may ENTER the object
                                   if the object is ENTER_OK. Also,
                                   the enter lock of an object being
                                   used as a Zone Master Object
                                   determines control of that zone.
     GiveLock:     Players/Things: controls who may give the object.
     LeaveLock:    Players/Things: controls who may LEAVE the object.
 
     LinkLock:     All but Exits:  controls who may link to the
                                   location if the location is LINK_OK
                                   (for linking exits or setting drop-
                                   tos) or ABODE (for setting homes)
     PageLock:     Players:        controls who may page the player.
     ParentLock:   All:            controls who may make @parent links
                                   to the object.
     ReceiveLock:  Players/Things: controls who may give things to the
                                   object.
{ 'help @lock locks2' for more}
 
& @lock locks2

     SpeechLock:   All but Exits:  controls who may speak in that
                                   location (only checked if
                                   AUDITORIUM flag is set on that
                                   location)
     TeloutLock:   All but Exits:  controls who may teleport out of
                                   the location.
     TportLock:    Rooms/Things:   controls who may teleport there if
                                   the location is JUMP_OK.
     UseLock:      All but Exits:  controls who may USE the object,
                                   GIVE the object money and have the
                                   PAY attributes run, have their
                                   messages heard and possibly acted
                                   on by LISTEN and AxHEAR, and invoke
                                   $-commands stored on the object.
     DropLock:     All but rooms:  controls who may drop that object.
     UserLock:     All:            Not used by MUX, is intended to be
                                   used in MUX programming where a
                                   user-defined lock is needed.

  Note: If a player fails the UseLock on a parent of an object being
  searched for $-commands, then the search for attributes stops and
  the parent chain is not searched further for matches.
 
& @lock normal

  NORMAL LOCKS:

  Key: <object>

  You pass a normal lock if you either are the named object or if you
  carry the named object.  <object> may be the name or #number of a
  thing, a playername prefixed by an asterisk (*<playername>), 'me',
  or 'here'.

  Examples:
    > @lock treasure room = secret key
    > @lock private area = me
  See also: @lock is, @lock carry.
 
& @lock ownership

  OWNERSHIP LOCKS:

  Key: $<object>

  You pass an ownership lock if you have the same owner as <object>.

  Examples:
    > @lock mystuff=$me
    Only objects you own may use the mystuff exit.

    > @lock/page me = !$*TinyJerk
    Neither TinyJerk nor any of his objects may page you.

  See also: @lock normal.
  
& @mail
 
  @mail[/<switches>] <player-list> = <subject>
  @mail[/<switches>] [<msg-list> [= <target>]]
 
  @mail invokes the built-in MUX mailer, which allows players to send
  and receive mail. Pronoun/function substitution is performed on
  any messages you may try to send.
 
  A <player-list> is a space-separated list of recipients, which may
  be:
        Player names (names with spaces in them should be put in
        double quotes, ex: "Foo Bar")
        Player dbref #'s
	
	Message numbers to be replied to.
	A mix of the above, and mail aliases (see @malias)
 
  A <msg-list> is one of the following:
        A single msg # (ex: 3)
        A message range (ex: 2-5, -7, 3-)
        A sender (ex: *lauren)
        An age of mail in days (ex: ~3 (exactly 3), <2, >1)
        "days" here means 24-hour periods from the current time.
        One of the following: "read", "unread", "cleared", "tagged",
        "urgent"
        For certain commands, "all".
 
  See the following topics:
    mail-sending    mail-reading     mail-folders      mail-other
    mail-admin      @malias          mail-reviewing    mail-examples
  
& @mailsucc
 
  Syntax: @mailsucc <player> = <message>
  Attribute: Mailsucc
 
  Sets a message to be displayed to the sender whenever <player>
  receives mail.
 
  Example:
  @mailsucc me=Thanks for the mail.
 
  See also: @amail, @signature, @mail
  
& @malias
 
  Syntax: @malias
 
  This allows you to generate and maintain mailing lists with the mail
  system. All mail aliases start with '*', and are case-sensitive.
  (*dir is different than *Dir).  There are two kinds of mail
  aliases, Personnal and Global. Global mailing lists are owned and
  maintained by the god (#1) char and are available for anyone to
  use.  Generally there will be *Wizards, *Admin, *Roleplay, and
  things of that nature.  Personal mailing aliases are mailing lists
  that you have defined with the @malias commad.
 
  Currently there is no limit to the number of people you can have on
  a mailing alias.
 
  To begin sending mail to a mailing list, use @mail *<alias>=subject.
 
  Usage:
 
  @malias                   Displays a list of all mail aliases.
  @malias *<alias>          Displays a list of people on that alias.
  @malias *<alias>=<list>   Creates that mailing list, using <list>.
 
  { 'help @malias2' for more}
  
& @malias2
 
  You can add, remove, rename, chown, redescribe, and delete mailing
  lists with a switch.
 
  @malias/remove *<alias>=<player>     Removes <player> from *<alias>.
  @malias/desc *<alias>=<description>  Changes the description for
                                       *<alias>.
  @malias/add *<alias>=<player>        Adds <player> to *<alias>.
  @malias/rename *<alias>=<name>       Renames that alias. Names must
                                       always begin with '*'.
  @malias/delete <alias>               Deletes <alias>. This is the
                                       only alias command that does
                                       not require the '*' in front of
                                       the alias' name.
  @malias/chown *<alias>=<player>      Changes the owner of <alias> to
                                       <player>.
 
  Wizards can use all of the malias commands on any mail alias.
  Instead of trying to figure out different mailing lists with the
  same name, wizards may use #<MALIAS NUMBER> instead of *alias in
  regards to the command.
 
  Remember that the alias commands will only recognize aliases owned
  by #1, owned by you, or by number.
 
  @malias/list                         When invoked by a wizard, it
                                       will list all mailing aliases
                                       currently defined by their
                                       number.
  
& @move
 
  Syntax: @move <object> = <command-list>
  Attribute: Move
 
  Sets the message that an object sees after it moves from one
  location to another, whether by using an exit, entering or leaving
  an object, teleporting, or going home.
 
  This attribute is meaningful for players, and things and will never
  be automatically triggered on other object types.
 
  Example: @move bopper = OK.  You're there now.
 
  See also: @amove, @omove
  
& @mvattr
 
  Syntax: @mvattr <object>=<old>,<new>[,<copy1>]...
 
  This command moves attributes around on an object.  The attribute
  <old> is renamed <new> (and is copied to <copy1>, <copy2> and so
  on if specified).
 
  If you cannot modify the <old> attribute (for instance if you are
  trying to move the Last attribute, or if it were owned by another
  player), then a new copy is made and the original is not removed.
 
  See also: @cpattr, @set
  
& @name
 
  Syntax: @name <object> = <new name>
 
  Changes the name of <object>.  <object> can be a thing, player,
  exit, or room, specified as <name> or #<dbref> or 'me' or 'here'.
 
  See '@list options' as to whether or not a player name may contain
  spaces.
  
& @notify
 
  Syntax: @notify[/<switches>] <object>[/<attribute>][=<count>]
 
  Notifies the semaphore <object>, running the first command that
  waited on <object> using the '@wait <object>=<command>' or '
  @wait <object>/<time>=<command>' forms of the @wait command.  If
  <count> is specified, it indicates the number of times the
  semaphore is notified.
 
  If there are no commands (or less than <count> commands) pending for
  <object>, then subsequent @waits will not block until the semaphore
  count reaches zero again. @notify may also take an argument of the
  form <object>/<attribute>, which notifies commands that are being
  blocked on an attribute other than the default 'Semaphore'. This
  allows blocking of muliple sets of commands on a single object,
  using different attributes.
 
  The following switches are available:
     /first - (default) Notify the first command waiting on the
              indicated semaphore (or the first <count> commands).
     /all   - Notify all commands waiting on the semaphore and reset
              the semaphore count to zero.  <count> is ignored.
 
  See also: @drain, @ps, @wait, SEMAPHORES
  
& @npemit
 
  Syntax: @npemit[/switches] <what>=<message>
  No parse @pemit. Exactly like @pemit, takes the same switches,
  except it does not evaluate <message>.
 
  See also: page, @pemit, @remit, @emit, @oemit, SPOOFING
  
& @odescribe
 
  Syntax: @odescribe <object> = <message>
  Attribute: Odesc
 
  Sets the message (prefixed by the player's name) that is shown to
  others in the room when someone looks at <object>.
 
  Example:
  @odesc vase = carefully inspects the vase.
 
  See also: look, @adescribe, @describe, @idesc
  
& @odfail
 
  Syntax: @odfail <object> = <message>
  Attribute: Odfail
 
  Sets the message (prefixed by the player's name) that is shown to
  others in  the same room when someone tries to drop <object> but
  fails because they didn't pass the object's drop lock.
 
  Function references and %-substitutions are allowed in drop failure
  messages, and are evaluated when someone drops the object.  In
  function references, 'me' refers to the object being dropped,
  while %-substitutions that refer to the enactor (such as %n, %#,
  %p, etc) refer to the dropper.
 
  Example:
  @odfail sword = tries to put down the sword but it leaps back
  into %p hand.
 
  See also: drop, @adfail, @dfail, @lock
  
& @odrop
 
  Syntax: @odrop <object> = <message>
  Attribute: Odrop
 
  Sets the message (prefixed by the player's name) that is shown to
  others in  the room when someone drops <object>, or to others in
  the room that the player arrives in after taking an exit.
 
  Example:
 
  <object>
  @odrop loadstone = puts down the loadstone and then wipes sweat
  from %p brow.
 
  <exit>
  @odrop elevator = enters the elevator from the lobby.
 
  See also: drop, @adrop, @drop, DROP-TO, EXITS
  
& @oefail
 
  Syntax: @oefail <object> = <command-list>
  Attribute: Oefail
 
  Sets the message (prefixed by the player's name) that is shown to
  others in the same room as the player when he tries to enter the
  object but fails because the object is not ENTER_OK or the player
  fails the object's enter lock.
 
  The enter lock only affects the 'enter' command and its aliases (set
  via the @ealias command), it does not affect exits that lead to
  the object or teleporting in.
 
  This attribute is meaningful for players and things, and will never
  be automatically triggered on rooms or exits.
 
  Example: @oefail car = tries to open the car's door, but it is
  locked.
 
  See also: @aefail, @aenter, @ealias, @efail, @enter, @oenter, enter,
  ENTER_OK
  
& @oemit
 
  Syntax: @oemit <player>=<message>
 
  Emits <message> to everyone in the current location of <player>
  except <player>.
 
  See also:  @remit, @emit, @pemit, @npemit, SPOOFING
  
& @oenter
 
  Syntax: @oenter <object> = <message>
  Attribute: Oenter
 
  Sets the message (prefixed by the player's name) that is shown to
  others in the location being entered when someone enters <object>.
  Note that the message is shown to those inside the object, not
  those outside.
 
  This attribute is meaningful for players, things, and rooms, and
  will never be automatically triggered on exits.
 
  Example:
  @oxenter wormhole = enters the wormhole from normal space.
 
  See also: enter, @aenter, @enter, @oxenter
  
& @ofail
 
  Syntax: @ofail <object> = <message>
  Attribute: Ofail
 
  Sets the others failure message for <object>.  This message is seen
  others in the same location as the actor when one of these events
  occurs:
 
    - For exits: Someone tries to traverse the exit but cannot because
      they fail the exit's default lock or the exit is not
      linked.
    - For players and things: Someone tries to pick up the object but
      cannot because they fail the object's default lock.
    - For rooms, players, and things: Someone looks around inside the
      room, player, or thing and fails the object's default
      lock.
 
  Substitution and evaluation is performed on the message before it is
  shown.
 
  Examples:
  <thing>
  > @ofail table = tries to pick up the table, but it is too heavy.
 
  <exit>
  > @ofail doorway = tries the knob on the door, to no avail.    
 
  See also: get, look, @afail, @fail, FAILURE
  
& @okill
 
  Syntax: @okill <object> = <message>
  Attribute: Okill
 
  Sets the message (prefixed by the player's name) that is shown to
  others in the room when someone kills <object>.
 
  This attribute is meaningful for players, things, and rooms, and
  will never be automatically triggered on exits.
 
  Example:
  @okill guard = bashes in the guard's skull, killing him.
 
  See also: kill, @akill, @kill, BEING KILLED, IMMORTAL, WIZARD
  
& @oleave
 
  Syntax: @oleave <object> = <message>
  Attribute: Oleave
 
  Sets the message (prefixed by the player's name) that is shown to
  others in the location being left when someone leaves <object>.
  Note that the message is shown to those inside the object, not
  those outside.
 
  This attribute is meaningful for players, things, and rooms, and
  will never be automatically triggered on exits.
 
  Example: @oleave wormhole = departs the wormhole to return to normal
  space.
 
  See also: leave, @aleave, @leave, @oxleave
  
& @olfail
 
  Syntax: @olfail <object> = <command-list>
  Attribute: Olfail
 
  Sets the message (prefixed by the player's name) that is shown to
  others in the same room as the player when he tries to leave it
  but fails because the player fails the object's leave lock.
 
  The leave lock only affects the 'leave' command and its aliases (set
  via the @ealias command), it does not affect going home, using an
  exit in the location, or teleporting out.
 
  This attribute is meaningful for players and things, and will never
  be automatically triggered on rooms or exits.
 
  Example:
  @olfail plane = thinks about jumping out of the plane without a
  parachute, but wisely reconsiders.
 
  See also: @aleave, @alfail, @lalias, @leave, @lfail, @oleave, leave.
  
& @omove
 
  Syntax: @omove <object> = <command-list>
  Attribute: Move
 
  Sets the message that others in the same location see after the
  object has moved to that location from somewhere else, whether by
  using an exit, entering or leaving an object, teleporting, or
  going home.
 
  This attribute is meaningful for players, and things and will never
  be automatically triggered on other object types.
 
  Example:
  @omove car = coasts to a stop.
 
  See also: @amove, @move
  
& @opay
 
  @opay <object> = <message>
  Attribute: Opay
 
  Sets the message (prefixed by the player's name) that is shown to
  others in the room when someone pays <object> enough to satisfy
  its Cost attribute.
 
  This attribute is only meaningful for players and things, and will
  never be automatically triggered on other object types.
 
  Example:
  @opay Coke machine = slips some change into the coin slot on the
  Coke machine.  You hear some rumbling from inside the machine and a
  can of Coke appears in the tray at the bottom of the machine.
 
  See also: give, @cost, @apay, @pay
  
& @open
 
  Syntax: @open[/<switches>] <direction list> [=<number>[,<direction
  list>]]
 
  Creates an exit in the specified direction(s). If <number> is
  specified, it is linked to that room. Otherwise, it is created
  unlinked. You or anyone else may use the '@link' command to
  specify where the unlinked exit leads.
 
  Opening an exit costs 1 coin. If you specify <number>, linking costs
  1 more coin.  You can specify a second direction list (after the
  comma), which is automatically opened in the room that the new
  exit goes TO and which is linked back to where you are.  I.e.
  @open north;n=#1234,south;s would open exit 'north;n' from here to
  #1234, and an exit 'south;s' from #1234 to here, assuming you have
  rights to open exits and link to the rooms in question.
 
  The following switches are available:
     /location  - Create the exit in your location (default).
     /inventory - Create the exit on yourself.
 
  See also: @dig, @link, LINKING
  
& @orfail
 
  Syntax: @orfail <object> = <message>
  Attribute: Orfail
 
  Sets the message (prefixed by the player's name) that is shown to
  others in the same room when someone tries to give <object> a
  thing that does not pass <object>'s receive lock.
 
  Function references and %-substitutions are allowed in receive
  failure messages, and are evaluated when someone tries to give
  away the object. In function references, 'me' refers to the
  intended recipient of the object, while %-substitutions that refer
  to the enactor (such as %n, %#, %p, etc) refer to the (attempted)
  giver.
 
  Example:
  @orfail merchant = tries to unload some worthless trash on Astinous.
 
  See also: give, @agfail, @arfail, @gfail, @ogfail, @rfail, @lock
  
& @osuccess
 
  Syntax: @osuccess <object> = <message>]
  Attribute: Osucc
 
  Sets the message (prefixed by the player's name) that is shown to
  others in the room when someone picks up the named player or
  thing, goes through the named exit, or looks at the room and
  passes the room's lock.
 
  Setting Osuccess messages on all takeable objects and usable exits
  is considered good building practice.
 
  Examples:
  <object>
  @osucc vase = carefully picks up the vase.
 
  <exit>
  @osucc doorway = opens the door and leaves the room. The door closes
  behind %o with a click.
 
  See also: get, look, @asuccess, @success, SUCCESS
  
& @otfail
 
  Syntax: @otfail <object> = <message>
  Attribute: Otfail
 
  Sets the message (prefixed by the player's name) that is shown to
  others in the same room when someone tries to teleport to
  somewhere he does not have permission.  You do not see this
  message if they couldn't teleport out of their present location.
 
  Function references and %-substitutions are allowed in teleport
  failure messages, and are evaluated when someone attempts to
  teleport to the specified destination.  In function references,
  'me' refers to the teleport destination, while %-substitutions
  that refer to the enactor (such as %n, %#, %p, etc) refer to the
  player attempting the teleport.
 
  When a player teleports another object (@tel <object> =
  <destination>), the lock is checked against the player, not the
  object.
 
  Example:
  @otfail here = thinks about teleporting to the Magic Room,
  but decides against it at the last moment.
 
  See also: @teleport, @atfail, @tfail, @lock
  
& @otofail
 
  Syntax: @otofail <object> = <message>
  Attribute: Otofail
 
  Sets the message (prefixed by the player's name) that is shown to
  others in  the same room when someone tries to teleport out of
  somewhere they do not have permission.
 
  Function references and %-substitutions are allowed in teleport
  failure messages, and are evaluated when someone attempts to
  teleport from their location.  In function references, 'me' refers
  to the player's location, while %-substitutions that refer to the
  enactor (such as %n, %#, %p, etc) refer to the player attempting
  the teleport.
 
  Example:
  @otofail here = thinks about teleporting from the Magic Room, but
  decides against it at the last moment.
 
  See also: @teleport, @atofail, @tofail, @lock
  
& @otport
 
  Syntax: @otport <object> = <message>
  Attribute: Otport
 
  Sets the message (prefixed by your name) that others in the room to
  which the object goes see when the object teleports there.
 
  This attribute is only meaningful for players and things, and will
  never be automatically triggered on other object types.
 
  Example:
  @otport me = appears in a flash of non-wizardly brilliance.
 
  See also: @atport, @oxtport, @tport, @teleport
  
& @oufail
 
  Syntax: @oufail <object> = <message>
  Attribute: Oufail
 
  Sets the message that others in the same room see when someone tries
  to use object but fails the object's use lock.  Note that the
  other functions controlled by the use lock (paying, listening, and
  $-commands) do not trigger Oufail.
 
  Example:
  @oufail robot = tries to activate the robot, but to no avail.
 
  See also: @aufail, @ufail, @use
  
& @ouse
 
  Syntax: @ouse <object> = <message>
  Attribute: Ouse
 
  Sets the message (prefixed by the player's name) that is shown to
  others in the room when someone uses <object>.
 
  This attribute is only meaningful for players and things, and will
  never be automatically triggered on other object types.
 
  Example:
  @ouse camera = takes a picture with the camera.
 
  See also: use, @ause, @use
  
& @oxenter
 
  Syntax: @oxenter <object> = <message>
  Attribute: Oxenter
 
  Sets the message (prefixed by the player's name) that is shown to
  others in the location being left when someone enters <object>.
  Note that the message is shown to those outside the object, not
  those inside.
 
  This attribute is meaningful for players, things, and rooms, and
  will never be automatically triggered on exits.
 
  Example:
  @oxenter wormhole = climbs into the wormhole and vanishes.
 
  See also: enter, @aenter, @enter, @oenter
  
& @oxleave
 
  Syntax: @oxleave <object> = <message>
  Attribute: Oxleave
 
  Sets the message (prefixed by the player's name) that is shown to
  others in the location being entered when someone leaves <object>.
  Note that the message is shown to those outside the object, not
  those inside.
 
  This attribute is meaningful for players, things, and rooms, and
  will never be automatically triggered on exits.
 
  Example:
  @oxleave wormhole = steps out of a hyperspatial wormhole.
 
  See also: leave, @aleave, @leave, @oleave
  
& @oxtport
 
  Syntax: @oxtport <object> = <message>
  Attribute: Oxtport
 
  Sets the message (prefixed by your name) that others in the room
  from which the object comes see when the object teleports out.
 
  This attribute is only meaningful for players and things, and will
  never be automatically triggered on other object types.
 
  Example:
  @oxtport me = disappears in a flash of non-wizardly brilliance.
 
  See also: @atport, @otport, @tport, @teleport
  
& @parent
 
  Syntax: @parent <object> [=<parent>]
 
  This command sets the parent of <object> to <parent> (or clears the
  parent if <parent> is omitted.  You must control <object>, and
  must own <parent>.
 
  See also: PARENT OBJECTS
  
& @password
 
  Syntax: @password <old password> = <new password>
 
  This command changes your password.
  
& @pay
 
  Syntax: @pay <object> = <message>
  Attribute: Pay
 
  Sets the message that is shown to the player who gives <object>
  enough money to satisfy its Cost attribute.
 
  This attribute is only meaningful for things, and will never be
  automatically triggered on other object types.
 
  Example:
  @pay Coke machine = You slip some change into the slot.
 
  See also: give, @apay, @cost, @opay
 
& @power

  COMMAND: @power <object>=[!]<power> [[!]<power> [...]]

  This command allows the granting of special powers to objects of any type.

  Related Topics: powers list 
& @prefix
 
  Syntax: @prefix <object> = <prefix text>
  Attribute: Prefix
 
  This attribute, when set, will be used as a prefix for all text
  forwarded by the 'audible' flag on an object or exit.  The default
  if this attribute is not set is 'From <object name>,' for objects,
  and 'From a distance,' for exits.
 
  Example:
    > @fo test=out
    > @set #378=puppet
    test> test grows ears and can now hear.
    > :does something silly.
    Wizard does something silly.
    test> From a distance, Wizard does something silly.
    > @prefix out=From some strange place
    Set.
    > :does something even sillier.
    Wizard does something even sillier.
    test> From some strange place Wizard does something even sillier.
 
  See also: AUDIBLE, @filter, @forwardlist, @infilter, @inprefix
  
& @program
 
  Syntax: @program <player>=<obj/attr>[:<prefix>]
 
  This command allows for small 'programs' within MUX. To understand
  this command, you must first understand the fact that it
  completely bypasses any commands, built-in or otherwise, and
  allows you to send user-input directly into your code.
 
  A simple example:
 
  @vb me=$start:@prog %#=me/vb:Please enter a word:
  @vb me=@emit You entered %0!;@prog %#=me/vc:Please enter another
  word:
  @vc me=@emit This time, you entered %0. You're done!
 
  > start
  Please enter a word:
  > foobar		(Note that @program literally gives you a '>' prompt.)
  You entered foobar!
  Please enter another word:
  > hoopla
  This time you entered hoopla. You're done!
 
{ 'help @program2' for more }
 
 
& @program2
 
  As you can see, this command basically takes what a user types at
  the prompt, stuffs it into %0 in the code in <obj/attr>, and then
  triggers that attribute. Note that when @program triggers an
  attribute, the enactor of that triggered attribute is <player>,
  and is inserted into %#. r-registers are preserved when @program
  triggers an attribute.
 
  An optional message, <prefix>, may be specified and will be output
  before   the @program prompt. This is useful for telling the user
  what information they need to supply.
 
  A player caught in @program may send a command through to the normal
  command processor at the @program prompt by prefixing it with the
  '|'  character, for example, '|WHO'.
 
  See also: @quitprogram
  
& @ps
 
  Syntax: @ps[/<switches>] [<object>]
 
  Lists information about the commands you have on each of the queues.
  Unless the /summary switch is used, this command lists all the
  commands you have on the queues, optionally along with their
  enactor and arguments.
 
  Commands scheduled to be executed at a later time (by the @wait
  command) also show the number of seconds until they will be
  executed and/or the semaphore on which they are waiting.  If
  <object> is specified, only commands run by <object> are listed,
  otherwise all commands run by any of your objects is listed.  A
  summary of the number of commands listed and the total number of
  commands in the queues is also displayed.  This command is
  useful for identifying infinite loops in programs.
 
  The following switches are available:
     /brief   - (default) Display a brief summary that shows the
                semaphore number, time-to-wait, object running the
                command, and the command to be run.
     /long    - In addition to the information in the /brief report,
                display the name and number of the object that caused
                the command to be run (the enactor) and the arguments
                to the command.
     /summary - Display just the queue counts.
 
  See also: @notify, @wait
  
& @quitprogram
 
  Syntax: @quitprogram <player>
 
  Terminates the @program for player. If <player> is not specified,
  then it works upon the enactor (a player may quit a program while
  they are in it by piping out @quitprogram, see 'help @program').
 
  See also: @program
  
& @quota
 
  Syntax: @quota
 
  Lists your total building quota and the amount you have remaining.
  Creating objects, digging rooms, and opening exits all consume
  quota.
 
  See also: @create, @dig, @open
  
& @reject
 
  Syntax: @reject <object> = <message>
  Attribute: Reject
 
  This attribute is sent as a message to anyone who tries to page you
  but   you have prevented them from paging you via your page lock
  (@lock/page).
 
  This attribute is only meaningful for players, and will never be
  automatically referenced on other object types.
 
  Example:
  @reject me = I _told_ you not to page me anymore...
 
  See also: @away, @idle, page.
  
& @remit
 
  Syntax: @remit <room dbref#> = <message>
 
  Sends <message> to the contents of <room>.
 
  See also: @femit, @oemit, @pemit, @npemit, @emit, SPOOFING
  
& @rfail
 
  Syntax: @rfail <object> = <message>
  Attribute: Rfail
 
  Sets the message that a player sees when he tries to give an object
  to someone else, but the receiver refuses to accept the object
  because the object didn't pass its receive lock.
 
  Function references and %-substitutions are allowed in receive
  failure  messages, and are evaluated when someone tries to give
  away the object. In function references, 'me' refers to the
  intended recipient of the object, while %-substitutions that refer
  to the enactor (such as %n, %#, %p, etc) refer to the (attempted)
  giver.
 
  This attribute is only meaningful for players and things, and will
  never be automatically triggered on other object types.
 
  Example:
  @gfail merchant = The merchant doesn't want your worthless trash.
 
  See also: give, @agfail, @arfail, @gfail, @ogfail, @orfail, @lock
  
& @robot
 
  Syntax: @robot <name>=<password>
 
  Creates a robot player owned by you.  The robot has its ROBOT flag
  set, so it may use the OUTPUTPREFIX and OUTPUTSUFFIX commands that
  most publicly available robot programs require.  This command
  costs 1000 coins.
 
  Note that some sites do not restrict OUTPUTSUFFIX and OUTPUTPREFIX
  to robots.
 
  See also: OUTPUTPREFIX, OUTPUTSUFFIX, ROBOT, TYPES OF OBJECTS
  
& @runout
 
  Syntax: @runout <object> = <command list>
  Attribute: Runout
 
  Sets the actions to be taken by <object> when another of its
  attributes is triggered (either automatically or via the @trigger
  command) and its Charges attribute is zero.  When this occurs, the
  Runout attribute is run INSTEAD OF the attribute that would have
  run normally.
 
  Example:
  @runout magic wand = :fizzles and turns to dust.; @destroy me
 
  See also: @charges
  
& @search
 
  Syntax: @search [<player>] [<class>=<restriction>[,<low>[,<high>]]]
 
  Displays information about objects that meet the search criteria.
  Because this command is computationally expensive, it costs 100
  coins.  <player> restricts the search to the named player, while
  <class> and <restriction> control the objects listed.  Type 'help
  search classes' for a list of the classes you may use.
 
  Except when getting lists of players ('@search type=player' or
  '@search flags=P'), you may only search for objects that you own.
  You may limit the range of the search with <low> and <high>, which
  specify the objects to start and stop the search at, respectively.
  The default for <low> is #0 and the default for <high> is the last
  object in the database.
 
  Examples:
    @search flags=PWc              <-- search for connected wizards.
    @search type=room              <-- list all rooms owned by me.
    @search eval=gt(money(##),10)  <-- search for things worth more
                                       than 10.
    @search type=room,100,300      <-- Rooms between #100 and #300,
                                       inclusive
    @search object=Test,5000       <-- Things starting with Test from
                                       object #5000 to the end of the
                                       database.
 
  See also: @find, search()
  
& @set
 
  Syntax: @set[/<switch>] <object>=[!]<flag>
           @set[/<switch>] <object>=<attribute>:<value>
           @set[/<switch>] <object>=<attribute>:_<fromobj>/<fromattr>
           @set[/<switch>] <object>/<attr>=[!]<attrflag>
 
  The first form sets (or clears) the indicated flag on <object>, the
  second form sets the <attribute> attribute on <object> to <value>,
  creating a new user-named attribute if there is no attribute named
  <attribute>.  The third form copies an attribute from another
  object, and the fourth form sets (or clears) an attribute flag on
  the <attr> attribute of <object>.
 
  When setting attributes on an object, you may also use the command
  '@<attribute> <object> = <value>' if the attribute is a predefined
  attribute.  You may also use the command '&<attribute> <object> =
  <value>' to set either predefined attributes or user-named
  attributes. Either of these is equivalent to the second form of
  the @set command.
 
{ 'help @set2' for more}
  
& @set2
 
  The following flags may be set using the fourth form of the @set
  command:
     no_command - Prevent $-commands and ^-patterns defined in the
     attribute
                  from being performed.
     no_inherit - Prevents children of the object from obtaining the
                  attribute.  From their perspective the attribute
                  does not exist.
     visual     - Anyone may see the attribute when they examine you,
                  and may get the attribute with get().
     hidden     - The attribute is only visable to wizards.
     regexp     - When $-commands are matched, treat the pattern as a
                  regular expression rather than a wildcard glob
                  pattern.
     wizard     - The attribute may only be changed by wizards.
 
  The @set command takes the following switch:
     quiet      - Inhibit 'Set.' acknowledgement messages.
 
  See also: @lock, @lock, examine, FLAGS,&
  
& @sex
 
  Syntax: @sex <object> = <gender>
  Attribute: Sex
 
  Sets the gender for <object>, which is used to determine which
  pronouns to use when replacing %p, %o, %s, and %a parameters in
  messages that apply to <object>.  Genders that start with M or m
  are considered male, those starting with F, f, W, or w are
  considered female, those starting with P or p are considered
  plural, and anything else is considered neuter.
 
  Example:
  @sex me = female
  @sex me = No thank you (Silly, but possible.  Treated as neuter)
 
  See also: GENDER
  
& @signature
 
  Syntax: @signature <player> = <message>
  Attribute: Signature
 
  Sets a message to be appended to ever @mail message you send. It is
  appended directly at the end of the message, so if you wish to start
  the signature on a new line you should begin it with a %r.
 
  Example: @signature me=%rThis is a mail signature. (Note: You might
  want to include the %r at the front of the signature, other wise
  it will be combined with the @mail message.)
 
  See also: @mailsucc, @amail, @mail
  
& @startup
 
  Syntax: @startup <object> = <command list>
  Attribute: Startup
 
  Sets a list of commands to be performed by <object> when the game is
  started up.  Typical actions include going home, cleaning visitors
  out of a room, resetting a puzzle or complex object to its initial
  state, or starting up an object that wants to run continuously.
 
  Example:
  @startup me = @vz me=MUX was last restarted at [time()].
  @startup me = home
 
  See also: @hhourly, @daily
  
& @stats
 
  Syntax: @stats[/all] [<player>]
 
  Display the number of objects in the game.  @stats/all gives a
  breakdown by object types.  If <player> is specified, the breakdown
  for the named player is given.  You may only list individual counts
  for yourself.  If invoked with no arguments or switches this command
  is free, but if you specify either /all or <player>, then this
  command costs 100 coins to run, because it is computationally
  expensive.
 
  See also: stats()
  
& @success
 
  Syntax: @success <object> = <message>
  Attribute: Succ
 
  Sets the message that is shown to the player who successfully picks
  up the named player or thing, goes through the named exit, or
  looks at the room and passes the room's lock.
 
  Example:
  <object>
  @succ vase = You carefully pick up the delicate vase.
 
  <exit>
  @succ doorway = You open the door and walk through the
  doorway.
 
  See also: get, look, @asuccess, @osuccess, SUCCESS
  
& @sweep
 
  Syntax: @sweep[/<switches>]
 
  This command tells you all of the objects, players, and exits that
  are listening in the room you are currently in, as well as the
  objects you are  carrying.  Most objects only listen for a
  particular string or phrase, so they normally do not pose a
  problem if you need privacy.  You will have to be careful of
  players, puppets, and audible exits since they will hear
  everything you say and do.  There are several switches that may be
  used to limit the type of listeners that are checked for.  They
  are:
     /here      - Check the room I am in.
     /inventory - Check my inventory.
     /exits     - Check exits in the room.
 
     /commands  - Check for objects that have $-commands set on them.
     /connected - Check for connected players and their puppets.
     /listeners - Check for objects with @listen set to something.
     /players   - Check for players and their puppets, whether or not
                  they are connected.
 
  The default is to search for everything.  If you specify one or more
  switches from either category (either location or listener type then
  only that location or listener type is checked.
 
  See also: @listen, AUDIBLE, PUPPETS
  
& @switch
 
  Syntax: @switch[/<switches>] <string>=<t1>,<c1> [,<tN>,<cN>]...
          [,<cD>]
 
  Compares <string> against the targets <t1>, <t2>, etc, until a match
  is found, at which time the corresponding list of commands is
  performed.
 
  Wildcards, and the < and > operators are allowed in the targets.  By
  default, any list whose target matches the string is executed (the
  targets are not mutually exclusive). If no target matches, the
  default list <cD> is executed.
 
  The following switches are available:
     /all   - (default) Perform the actionlists associated with all
              targets that match <string>.
     /first - Perform only the actionlist associated with the first
              target that matches <string>.
  
& @teleport
 
  Syntax: @teleport [<object>=] <room/thing>
           @teleport [<object>=] <exit>
           @teleport [<object>=] home
 
  The first form of the @teleport command moves <object> (or you) to
  the named room or thing.  The second form sends <object> (or you)
  to the destination of the named exit, while the third form sends
  <object> (or you) home.
 
  If the destination room has a drop-to, the object will go to the
  drop-to instead of the named location.
 
  For the first form of the @teleport command, the object being
  teleported must pass its location's TeloutLock; and you must
  control the destination, or it must be JUMP_OK and you must pass
  the destination's TportLock.
 
  The second and third forms let you remove any object from locations
  you control by sending them through an exit or to their home.
 
  The following switch is available:
     /quiet - Teleports without setting off success or failure
              messages.
 
  See also: JUMP_OK, @lock (tport and telout), @tfail, @otfail,
  @atfail, @tofail, @otofail, @atofail
  
& @tfail
 
  Syntax: @tfail <object> = <message>
  Attribute: Tfail
 
  Sets the message that a player sees when he tries to teleport to
  somewhere he does not have permission.  You do not see this
  message if you couldn't teleport out of your present location.
 
  Function references and %-substitutions are allowed in teleport
  failure messages, and are evaluated when someone attempts to
  teleport to the specified destination.  In function references,
  'me' refers to the teleport destination, while %-substitutions
  that refer to the enactor (such as %n, %#, %p, etc) refer to the
  player attempting the teleport.
 
  When a player teleports another object (@tel <object> =
  <destination>), the lock is checked against the player, not the
  object.
 
  Example:
  @tfail here = A psychic barrier prevents you from teleporting there.
 
  See also: @teleport, @atfail, @otfail, @lock
  
& @tofail
 
  Syntax: @tofail <object> = <message>
  Attribute: Tofail
 
  Sets the message that a player sees when he tries to teleport from
  somewhere he does not have permission.
 
  Function references and %-substitutions are allowed in teleport
  failure messages, and are evaluated when someone attempts to
  teleport out of their location.  In function references, 'me'
  refers to the player's current location, while %-substitutions
  that refer to the enactor (such as %n, %#, %p, etc) refer to the
  player attempting the teleport.
 
  Example:
  @tofail here = A psychic barrier prevents you from teleporting     
  out.
 
  See also: @teleport, @atofail, @otofail, @lock
  
& @tport
 
  Syntax: @tport <object> = <message>
  Attribute: Tport
 
  Sets the message that an object sees whenever it teleports.
  The message is displayed after the object moves to its new location.
 
  This attribute is only meaningful for players and things, and will
  never be automatically triggered on other object types.
 
  Example:
  @tport me = Hey! I teleported. Wow!
 
  See also: @atport, @otport, @oxtport, @teleport
  
& @trigger
 
  Syntax: @trigger[/<switch>] <object>/<attr> [=<param>[, <param>]...]
 
  Invokes an action list stored in an attribute on an object.  The
  triggering object becomes the enactor and the positional
  parameters %0 through %9 are set to the supplied parameters.
 
  The @trigger command supports the following switch:
     quiet      - Inhibit 'Triggered.' acknowledgement messages.
 
  See also: LOOPING
  
& @ufail
 
  Syntax: @ufail <object> = <message>
  Attribute: Ufail
 
  Sets the message that someone sees when they try to use object but
  fail the object's use lock.  Note that the other functions
  controlled by the use lock (paying, listening, and $-commands) do
  not trigger Oufail.
 
  Example:
  @ufail robot = The robot pointedly ignores you.
 
  See also: @aufail, @oufail, @use
  
& @unlink
 
  Syntax: @unlink <room/exit>
 
  This command removes drop-tos on rooms and clears the destination on
  exits.
 
  Once unlinked, an exit may be taken over by anyone with the @link
  command.
 
  See also: @link, LINKING
  
& @unlock
 
  Syntax: @unlock <object>
          @unlock <object>/<attrib>
 
  The first form removes the lock on <object>, so that anyone may pass
  through (if an exit) or pick it up (if a player or an object).
 
  The second form clears the locked flag on the indicated attribute of
  the named object.  This allows the attribute to change ownership
  to the new owner automatically when the object is @chowned, and
  allows the owner of the object to @chown the attribute to themself
  or to overwrite it.
 
  You must own the attribute to be unlocked, but you do not need to
  own the object.
 
  See also: @chown, @lock, ATTRIBUTE OWNERSHIP
  
& @use
 
  Syntax: @use <object> = <message>
  Attribute: Use
 
  Sets the message that is shown to the player who uses <object>.
 
  This attribute is only meaningful for players and things, and will
  never be automatically triggered on other object types.
 
  Example:
  @use camera = You take a picture with the camera.  Click.
 
  See also: use, @ause, @ouse
  
& @verb
 
  Syntax: @verb <victim>=<actor>, <what>, <def>, <owhat>, <odef>,
  <awhat>, <args>
 
  This command provides a way to do user-defined verbs with associated
  @attr/@oattr/@aattr groups. Invoking it does the following:
 
  <actor> sees the contents of <victim>'s <what> attribute, or
  the <def> string if you can't read <victim>'s <what>   
  attribute.
 
  Everyone in the same room as <actor> sees the contents of
  <victim>'s <owhat> attribute, with <actor>'s name prepended,
  or <odef>, also with <actor>'s name prepended, if you can't read
  <victim>'s <owhat> attribute.
 
  If you control <victim>, then he executes the contents of his
  <awhat> attribute.
 
  By supplying up to nine <args>, you may pass those values on
  the stack (i.e. %0, %1, %2, etc. up through %9).
 
  You must control the actor, but need not control the victim.  Note
  that if you don't have the ability to read the appropriate
  attributes (whether because you control the victim, he is VISUAL,
  or the attributes are set VISUAL), the default messages will be
  used.
 
{ 'help @verb2' for more }
  
& @verb2
 
  Here is a description of the arguments to @verb:
    victim - The object that is searched for attributes, and which
             runs the <awhat> attribute if it is found.
    actor  - The object that 'did' the verb, this is the value for
             %#/%n/etc in substitutions, and this object's name is
             included in the message to others in the same location.
    what   - The name of the attribute containing the message to be
             delivered to the actor.
    whatd  - The message to deliver to the actor if the victim does
             not have a <what> attribute, or if it cannot be read.
    owhat  - The name of the attribute containing the message
             (prefixed by the actor's name) that is sent to everyone
             in the room with the actor.
    owhatd - The message (prefixed by the actor's name) to deliver to
             others in the room with the actor if the victim does not
             have an <owhat> attribute, or it cannot be read.
    awhat  - The name of the attribute that is to be executed by the
             victim.
         
    args   - The comma-separated arguments to be passed for
             substitution (%0-%9).  If there is more than one
              argument,
             enclose all the arguments within curly  braces.
             Any argument that contains an embedded comma needs to be
             enclosed in curly braces as well.
 
{ 'help @verb3' for more}
  
& @verb3
 
  Examples:
    > &xtest test1=You just xtested test1.
    > &oxtest test1=just xtested test1.
    > &axtest test1="I was xtested.  Yikes.  Arg1=%0, Arg2=%1,
    Arg3=%2.
    > @verb test1=me,xtest,XTEST DFLT,oxtest,OXTEST DFLT,axtest,{a,b
    c,de}
    You just xtested test1.
    test1 says "I was xtested. Yikes. Arg1=a, Arg2=b c, Arg3=de."
    > &xtest test1
    > @verb test1=me,xtest,XTEST DFLT,oxtest,OXTEST DFLT,axtest,{a,b
    c,de}
    XTEST DFLT
    test1 says "I was xtested. Yikes. Arg1=a, Arg2=b c, Arg3=de."
    > @fo test1={@verb test1=me,xtest,XTEST D,oxtest,OXTEST
    D,axtest,{a,b,de}}
    test1 just xtested test1.
    test1 says "I was xtested. Yikes. Arg1=a, Arg2=b, Arg3=de."
 
  See also: locate()
  
& @wait
 
  Syntax: @wait <seconds>=<command>
           @wait <object>[/<seconds>]=<command>
           @wait <object>/<attribute>=<command>
 
  The first form of @wait executes <command> after <seconds> seconds.
  The second form increments the semaphore count for <object> and
  executes <command> after <object> is notified with the @notify
  command.  If the semaphore count for <object> is negative (because
  it has been notified more times than it has been waited on), then
  <command> is run immediately.
 
  If <seconds> is specified in the second form, the command is
  automatically run after <seconds> seconds even if the semaphore
  isn't notified.
 
  The third form allows for blocking multiple sets of commands on
  the same object, using seperate attributes to keep track of the
  semaphore.
 
  This command charges a deposit of 10 coins, which is refunded when
  <command> is executed.
 
  See also: @drain, @notify, @ps, SEMAPHORES
  
& @wipe
 
  Syntax: @wipe <object>[/<wild-attr>]
 
  This command erases attributes from an object.  All attributes that
  match <wild-attr> (or all attributes, if <wild-attr> is not
  specified) are removed from <object>.  Attributes that you do not
  have permission to modify (such as read-only or locked attributes)
  are not removed.
  
& ABODE

Flag: ABODE (A)

  If a room is set ABODE, players can set their homes there,
  and can set the homes of objects there.  It does not mean that a
  player can open an exit to that room, however.

  See also: HOMES
  
& abs()
 
  Syntax: abs(<number>)
 
  This function returns the absolute value of its argument.
  The <number> may be a floating point number, as well as return a
  floating point number.
 
  Example:
 
  > say abs(4)
  You say "4"
  > say abs(-4)
  You say "4"
  > say abs(0)
  You say "0"
  
& acos()
 
  Syntax: acos(<number>)
 
  This function returns the arc-cosine of <number>, expressed in
  radians.
 
  Example:
 
  > say acos(0)
  You say "1.570796"
  > say acos(1)
  You say "0"
  > say acos(0.707101)
  You say "0.785406"
  > say acos(0.866025)
  You say "0.5236"
 
  See also: asin(), atan(), cos(), pi(), sin(), tan().
  
& add()
 
  Syntax: add(<number1>,<number2>[,<numberN>]...)
 
  This function returns the result of adding its arguments together.
  You may add up to 30 numbers in one add() call.
  The <numberN> may be a floating point number, and a floating point
  result is returned.
 
  Example:
 
  > say add(2,4)
  You say "6"
  > say add(5,3,7,-4)
  You say "11"
 
  See also: inc(), dec(), div(), mod(), mul(), sub().
  
& addcom
 
  Syntax: addcom <alias>=<channel>
 
  This command joins you to an existing channel with <alias>. You
  should avoid having multiple aliases for a channel, although it is
  allowed.
 
  See also: delcom, comlist, alias, comtitle.
  
& addtic
 
  RS Command: addtic  <num> <weapnum [,weapnum] | lownum-highnum >
 
  This command adds a weapon or weapons to the specified tic.
  
  Arguments:
  
  * num - valid TIC's are 0 through 3
  * weapnum - this is the number for the weapon as shown in by the 
              status command. More that one weapon can be specified by 
              separating the weapnums with commas.
  * lownum-highnum - this adds weapons from lownum to highnum 
                     inclusive.
                     
  
  Continued in addtic2
 
  See Also: deltic, listic, cleartic
  
& addtic2
 
  Example:
  Given an EXT-4D there are 3 ways to add the 4 mediumlasers to one 
  TIC.
  
  Individually:
  >addtic 0 0
  Weapon #0 added to TIC 0!
  >addtic 0 1
  Weapon #1 added to TIC 0!
  <etc>
  
  Individually in one command:
  >addtic 0 0,1,2,3
  Weapon #0 added to TIC 0!
  Weapon #1 added to TIC 0!
  Weapon #2 added to TIC 0!
  Weapon #3 added to TIC 0!
  
  Inclusively:
  >addtic 0 0-3
  Weapons #0 - #3 added to TIC 0!
  
  See Also: deltic, listic, cleartic
  
& adescribe
 
  Syntax: @adescribe <object> = <command-list>
  Attribute: Adesc
 
  Sets the actions to be taken when <object> is looked at.
 
  Example:
  @adesc kitten = :rubs against %n's legs affectionately.
 
  See also: look, @desc, @idesc, @odesc, think.
  
& advantages
 
 >> Help: Advantages
 -----------------------------------------------------------------------------
 Advantages serve as special augmentations for your character. Each one
 makes your character more powerful or useful in some aspect. You may view
 which advantages you have by typing 'stats'
 
 [_Combat Advantages_]
 Sixth_Sense		Toughness		Dodge_Maneuver
 Maneuvering_Ace	Melee_Specialist	Pain_Resistance
 Speed_Demon

 [_Other Advantages_]
 Ambidextrous		Bloodname		Combat_Sense
 Contact		Dropship		EI_Implant
 Exceptional_Attribute	Extra_Edge		Land_Grant
 Reputation		Title			Wealth
 Well-Connected		Well_Equipped		Tech_Aptitude
 -----------------------------------------------------------------------------
 To view info on an advantage, use 'help <advantage>' without the <>'s.
 
 
& after()
 
  Syntax: after(<string1>, <string2>)
 
  This function returns the portion of <string1> that occurs after <
  string2>. If <string2> does not occur in <string1>, a null string is
  returned.
 
  If you want to return the portion of the string after the first
  space, use the rest() function instead.
 
  Example:
 
  > say after(This is a test,a)
  You say " test"
  > say after(This is a test,is)
  You say " is a test"
  > say after(This is a test, nope)
  You say ""
 
  See also: before(), first(), rest().
 
& agreement
 
 >> Help: Agreement
 -----------------------------------------------------------------------------
  Insert agreement here.
 -----------------------------------------------------------------------------
 
 
& allcom
 
  Syntax: allcom <on|off|who>
     
  This works like using a single alias, except it does an action for
  every alias you have. You can turn every alias on, or off, or see
  who is on every channel you subscribe to.
 
  See also: alias, comtitle, delcom, addcom
  
& alphamax()
 
  Syntax: alphamax(<word1>, <word2>, <word3>, ...)
 
  Takes up to ten word arguments, and returns the word which is
  lexicographically biggest.
 
  See Also: alphamin().
  
& alphamin()
 
  Syntax: alphamin(<word1>, <word2>, <word3>, ...)
 
  Takes up to ten word arguments, and returns the word which is
  lexicographically smallest.
 
  See Also: alphamax().
  
& &
 
  Command: &<attribute> <object>[=<value>]
  Synonym: @set <object> = <attribute>:[<value>]
 
  Sets the attribute named <attribute> on <object> to <value>.  If
  <attribute> is not a predefined attribute (like ofail or va), then
  it is created.  Attributes so created are called user-named
  attributes.

  Attribute names may only contain letters, numbers, and the
  characters < -_.@#$^&*~?=+| >, and must start with a letter.  The
  names of user-named attributes may not be abbreviated (an attempt
  to get the value of the attribute will fail, and an attempt to set
  will create a new attribute).

  The & command may be used to set predefined attributes (in this
  instance, '&<attr> <object>=<value>' is equivalent to '@<attr>
  <object>=<value>').
 
  See also: @set
  
& ams
 
  RS Command: ams <weapnum>
  
  The command toggles the state of the  anti-missile system on and 
  off.
  
& analog mode
 
  setchannelmode: Analog mode:
  Flag: A, a or -
 
  This mode transmits further than digital mode - however it is 
  susceptible to scanning by enemy units.
 
  Analog mode is indicated by parentheses (ie '()') around the channel
  and bearing indicator.
  
  Example: 
  Given that UnitID [TT] (calltitle MechJock) is within range
  and transmitting on channel A in anaolog mode
 
  (A:054) <MechJock> Can you guys hear me?
  
& and()
 
  Syntax: and(<boolean1>,<boolean2>[,<booleanN>]...)
 
  Takes two or more booleans, and returns 1 if they are all each
  equivalent to true(1).
 
  See Also: BOOLEAN VALUES, or(), not(), xor().
  
& andflags()
 
  Syntax: andflags(<object>,<list of flags>)
 
  This function returns 1 if <object> has all the flags specified,
  and 0 if it does not. The list is specified with a single letter
  standing for each flag, like the output of the flags() function.
  A '!' preceding a flag letter means "not flag".
 
  If a letter does not correspond to any flag, <object> doesn't have
  it, so the function returns 0.
 
  There can be an arbitrary number of flags. Do not put spaces between
  flag letters.
 
  Example:
  Given that #1234 is a character with the WIZARD and DARK flags set
 
  >ANDFLAGS(#1234,WD)
  1
  >ANDFLAGS(#1234,W!D)
  0
 
  See Also: orflags(), hasflag(), flags().
  
& angeleccm
 
  RS Command: angeleccm
  
  The command puts your ECM suite into ECCM mode, which enables it 
  to counteract enemy ECM.
  
  
   
& angelecm
 
  RS Command: angelecm
  
  This command toggles the ECM status of your Angel ECM suite.
  
  ECM interferes with the communications and certain sensors of enemy 
  units within ranage of your 'ECM Umbrella'.
  
  See Also: angeleccm 
& ANSI
 
  Flag: ANSI (X)
 
  When set on a player, it will enable the player to see ANSI color.
 
  If you have TinyFugue and you do not wish to see ANSI color, please
  leave this flag set and /set catch_ctrls=ansi. The reason for this
  is when the ANSI flag is unset, the server must go through every 
  line of text you see and strip the ANSI codes from it. With the 
  ANSI flag set and /set catch_ctrls=ansi, TinyFugue will strip the 
  ANSI and save the MUX from having to do it, resulting in less lag 
  for everyone.
 
  See also: ansi()
  
& ansi()
 
  Syntax: ansi(<codes>,<string>)
 
  This function allows you to highlight a string using ANSI terminal
  effects.
  The string is terminated with a "return to normal" code, and the
  codes are utilized in the order they are specified.
 
 The codes are:
 
        f - flash                       i - inverse
        h - hilite                      n - normal
 
        x - black foreground            X - black background
        r - red foreground              R - red background
        g - green foreground            G - green background
        y - yellow foreground           Y - yellow background
        b - blue foreground             B - blue background
        m - magenta foreground          M - magenta background
        c - cyan foreground             C - cyan background
        w - white foreground            W - white background
 
  For example, "ansi(fc, Test)" would hilight "Test" in flashing cyan.
 
  {help ansi()2 for more}
  
& ansi2
 
  The percent substitution %c<color code> can be used instead of
  ansi(), and is more efficient.
 
  For example, the equivalent to [ansi(rBf,Color!)] would be:
  %cr%cB%cfColor!%cn
 
  The %cn (to return to normal) is not necessary, but if it is not
  specified the ansi color codes will continue to the end of the
  string.
 
  See also: ANSI.
  
& ANSIMAP
 
  Flag: ANSIMAP (P)
 
  When set on yourself, this flag causes you to see the RS map in
  color.
  
& ansisecure()
 
  Syntax: ansisecure(string)
 
  Works exactly like 'secure(<string>)', but does not eradicate ANSI
  escape sequences.
 
  See Also: secure(), stripansi(), ansi().
  
& ap
 
  RS Command: ap <weapnum>
  
  This command toggles the state of <weapnum>, causing it to fire 
  Armor Piercing ammunition or normal ammunition.
  
  AP ammo is available for AutoCannons only.
  
& aposs()
 
  Syntax: aposs(<object>)
 
  Returns the proper absolute possessive pronoun (his, hers, its,
  theirs) for referring to <object>, based on the object's Sex
  attribute.
 
  You must either control or be near <object>.
 
  See Also: art().
  
& art()
 
  Fuction: art(<string>)
 
  This function returns the proper article, "a" or "an", based on
  whether or not <string> begins with a vowel.
 
  See also: apos().
  
& artemis
 
  RS Command: artemis <weapnum>
  
  This command toggles the state of <weapnum>, causing it to fire 
  ArtemisIV ammunition or normal ammunition 
  
  Artemis ammo is only used for missile launchers and requires an 
  ArtemisIV fire control system be installed on the RS Unit.
  
& asin()
 
  Syntax: asin(<number>)
 
  Returns the arcsine of <number>, expressed in radians.
 
  Example:
 
  > say asin(0)
  You say "0"
  > say asin(1)
  You say "1.570796"
  > say asin(0.707101)
  You say "0.78539"
  > say asin(0.5)
  You say "0.523599"
 
  See Also: acos(), atan(), cos(), pi(), sin(), tan().
  
& asuccess
 
  Syntax: @asuccess <object> = <command-list>
  Attribute: Asucc
 
  Sets the actions to be taken by an object when someone successfully
  picks it up (because they passed the lock), by an exit when
  someone passes through it, or when someone looks at a room and
  passes the room's lock.
 
  Example:
  @asucc kitten = :climbs up your sleeve and nuzzles your face.
 
  See also: @osucc, @success, SUCCESS
  
& atan()
 
  Syntax: atan(<number>)
 
  Returns the arctangent of <number>, expressed in radians.
 
  Example:
 
  > say atan(0)
  You say "0"
  > say atan(1)
  You say "0.785398"
  > say atan(1.557408)
  You say "1"
  
  See Also: acos(), asin(), cos(), pi(), sin(), tan().
  
& attachcables
 
  RS Command: attachcables <tow-UnitID> <towed-UnitID>
  
  This command permits an RS Unit without hands to tow another RS 
  Unit.
  
  NOTE - To use this command you must exit the RS Unit and execute the 
  command from the RS map.
  
  Example:
  Given that UnitID: OE is the unit you wish to tow with UnitID: DD
  
  >shutdown
  Mech has been shutdown!
  >disembark
  MechWarrior - Fred
  You climb out of the unit.
  attachcables DD OE
  You attach Exterminator [DD]'s tow lines to Falcon [OE].
  >embark
  You climb into Exterminator [DD].
  startup
  
  Once the RS Unit has started up, you are ready to tow the attached 
  unit.
 
  See Also: pickup, dropoff, detachcables
  
& AUDIBLE
 
  Flag: AUDIBLE (a)
 
  When set on an object, player, or room, everything from a say, pose,
  or emit inside the object will be sent to every object in the 
  location of that object (except for rooms which have no location) 
  as well as to all objects mentioned in the object's Forwardlist 
  attribute.  When set on an exit, everything from a say, pose, or 
  emit in the room the exit is in will be forwarded to the room the 
  exit points to.  In both cases the @prefix attribute will be 
  inserted in front of the text, or a default prefix if no @prefix 
  attribute is set.  If the @filter attribute is present, it
  will be used to suppress those messages matching any of the 
  patterns specified.
 
  See also: @filter, @forwardlist, @prefix
  
& AUDITORIUM
 
  Flag: AUDITORIUM (b)
 
  When set on a room, object, or player, it enables the checking
  of speechlocks.
 
  See also: @lock, say
  
& autoturret
 
  RS Command: autoturret
  
  This command toggles the status of the Turret Auto-Turn system.
  
  When engaged, the turret will automatically turn to face the 
  currently locked target. When disengaged the turret responds to 
  manual control.
  
  See Also: turret, lock
 
& available
 
 >> Help: Available (Misc Command)
 -----------------------------------------------------------------------------
 Syntax: Available
 
 This toggles between available and unavailable status. It lets your
 faction-mates know whether you are able to assist in real-space matters by
 displaying a green '+' beside your name on 'census'.
 
 Along with being informational, the total number of people available in
 each faction may be evaluated to when a TinyPlot is being considered.
 
 
& axe
 
  RS Command: axe [R|L|B] [ID]
  
  This command causes your 'Mech to attack another RS Unit with an 
  axe. Naturally, this requires that your unit be equipped with an 
  axe.
  
  As with all physical attacks you must be within the same hex as the 
  unit you are attacking.
  
  Arguments:
  none - if a target is locked, attempt to attack that target
  * R - attempt to use the axe equipped on your Right arm
  * L - attempt to use the axe equipped on your Left arm
  * B - 
  * ID - specify a unit to trip
  
  See Also: charge, chop, club, grabclub, kick, mace, punch, saw,   
            trip 
 & bearing
 
  RS Command: bearing [x y] [x y]
 
  This command returns the bearing to the hex specified.
 
  If only one hex is specified the bearing returned is from your
  current location.
 
  If two hexes are specified the command returns the bearing from the
  first hex to the second hex.
 
  The hex argument may be omitted if the unit is locked to the target
  hex.
  
& beep()
 
  Syntax: beep()
 
  This function simply outputs the beep character, which on most
  terminals with sound, will emit a short beep. Only wizards may use
  this function.
  
& before()
 
  Syntax: before(<string1>, <string2>)
 
  Returns the portion of <string1> that occurs before <string2>. If
  <string2> does not occur in <string1>, the entire string is
  returned. If you want to return the portion of the string after the
  first space, use the first() function instead.
 
  Example:
 
  > say before(This is a test,a)
  You say "This is "
  > say before(This is a test,is)
  You say "Th"
  > say before(This is a test, nope)
  You say "This is a test"
 
  See Also: after(), first(), rest().
  
& BLIND
 
  Flag: BLIND (()
 
  This flag, set on yourself, causes the MUX to send you output
  intended for use with screen-readers.  BLIND deployment is still 
  spotty, so if you are a visually-impaired player and encounter 
  poorly-written commands, please report them to the staff.
  
& bootlegger
 
  RS Command: bootlegger <r/l>
  
  This command causes a mech to execute an immediate 90 degree turn in 
  the direction specified.
  
  Arguments:
  r - right
  l - left
  
  A pilot skill roll is required to successfully carry out this 
  command.
  
& brief
 
  RS Command: brief [a <0-6> | c <0-3>]
  
  This command sets what is displayed for the 'contacts' command and 
  what is displayed when your RS Unit gets a contact.
  
  Arguments:
  none - displays the current settings
  * a - set autocontact option:
      0 - See enemies and friends, long text, color.
      1 - See enemies and friends, short text, color.
      2 - See enemies only, long text, color.
      3 - See enemies only, short text, color.
      4 - See enemies and friends, short text, no color.
      5 - See enemies only, short text, no color.
      6 - Disabled.
  * c - set contact option
       0 - Very verbose.
       1 - Short form, the usual one.
       2 - Short form, the usual one, but do not see buildings.
       3 - Shorter form.
  
  See Also: contacts
 
& btmuxcredits
 
 >> Help: BTMux Credits
 ----------------------------------------------------------------------------
 BattletechMUX is a project maintained by the community. A number of people
 are involved in the production, maintenance, and improvement of the
 codebase. While it would be difficult to name every person taking a role
 in what you now see before you, below are the individuals that have
 made large contributions towards the progression of BTMux. 
 
 * Dany@Frontier - Hardcode
 * Fingon@3030 - Hardcode
 * Focus@3030 - Hardcode
 * Hagbard@Frontier - Hardcode
 * Kelvin McCorvin@Frontier - Project Director, Softcode, Documentation
 * Null@3029 - Original Exile codebase developer
 * Power_Shaper@Frontier - Hardcode
 * Scotty@Frontier - Documentation
  
 
& c3

  RS Command: c3 [ID|-]

  This command initialises or terminates connection to a C3 network.
  
  Arguments:
  
  * ID - Connects you to the C3 network of which ID is a part.
  * '-' - Disconnects you from a C3 network.
  
& c3i

  RS Command: c3i [ID|-]
  
  This command initialises or terminates connection to a C3i network.
  
  Arguments:
  
  * ID - Connects you to the C3i network of which ID is a part.
  * '-' - Disconnects you from a C3i network.
  
& c3imessage

  RS Command: c3imessage <message>
  
  This command sends a message to all others in your C3i network. The 
  communication cannot be scanned or intercepted.
. 
& c3inetwork
 
  RS Command: c3inetwork
  
  This command displays details of the units which share a C3i network 
  with you.
  
& c3itargets
 
  RS Command: c3itargets
  
  This command displays targetting information on all units 'viewable' 
  by the sensors of all the units within the C3i Network.
  
& c3message

  RS Command: c3message <message>
  
  This command sends a message to all others in your C3 network. The 
  communication cannot be scanned or intercepted.
. 
& c3network
 
  RS Command: c3network
  
  This command displays details of the units which share a C3 network 
  with you.
  
& c3targets
 
  RS Command: c3targets
  
  This command displays targetting information on all units 'viewable' 
  by the sensors of all the units within the C3 Network.
  
& capstr()
 
  Syntax: capstr(<string>)
 
  Returns <string> with the first character capitalized. If the first
  character is not a letter, this function returns the string
  unmodified.
 
  Example:
 
  > say capstr(this is a string I want capitalized)
  You say "This is a string I want capitalized"
 
  See Also: lcstr(), ucstr().
  
& case()
 
  Syntax: case(<str>[,<pat1>,<res1>]...[,<dflt>])
 
  case() is like switch() but does not do wildcard matching (i.e.,
using *).
  In cases where wildcards are not needed, it performs marginally
faster.
 
  See also: @switch, match(), ifelse(), switch()
  
& caseless
 
  RS Command: caseless <weaponum>
  
  This command toggles the state of <weapnum>, causing it to fire 
  Caseless ammunition or normal ammunition.
  
  Caseless ammo is available for AutoCannons only.
  
& cat()
 
  Syntax: cat(<string>[,<stringN>])
 
  This function returns a string made up of the contents of <string1>
  through <stringN>, with each string separated from its neighbors by
  a space.
 
  Example:
 
  > say cat(this is, a test)
  You say "this is a test"
  > say cat(This is,another,test of the,CAT function)
  You say "This is another test of the CAT function"
 
  See Also: setunion(), setdiff(), setinter().
 @aahear
@aclone
@aconnect
@adesc
@adfail
@adisconnect
@adrop
@aefail
@aenter
@afail
@agfail
@ahear
@akill
@aleave
@alfail
@alias
@amail
@amhear
@amove
@apay
@arfail
@asucc
@atfail
@atofail
@atport
@aufail
@ause
@away
@charges
@contactopt
@cost
@daily
@desc
@dfail
@drop
@ealias
@efail
@enter
@fail
@filter
@forwardlist
@gfail
@idesc
@idle
@infilter
@inprefix
@kill
@lalias
@last
@lastsite
@leave
@lfail
@listen
@lrsheight
@mailsucc
@mechdesc
@move
@odesc
@odfail
@odrop
@oefail
@oenter
@ofail
@ogfail
@okill
@oleave
@olfail
@omove
@opay
@orfail
@osucc
@otfail
@otofail
@otport
@oufail
@ouse
@oxenter
@oxleave
@oxtport
@pay
@prefix
@reject
@rfail
@runout
@sex
@signature
@startup
@succ
@tacsize
@tfail
@tofail
@tport
@ufail
@use
@ 
& ceil()
 
  Syntax: ceil(<number>)
 
  Returns the smallest integer greater than or equal to <number>.
  <number> may be a floating point number, and an integer result is
  returned.
 
  Examples:
 
  > say ceil(5)
  You say "5"
  > say ceil(5.2)
  You say "6"
  > say ceil(5.8)
  You say "6"
  > say ceil(-5)
  You say "-5"
  > say ceil(-5.2)
  You say "-5"
 
  See Also: div(), floor(), mod(), round(), trunc().
  
& cemit()
 
  Syntax: cemit(<channel>, <message>)
 
  This function emits <message> on <channel>
 
  Note: The function does not prepend anything to the emitted message
 
  Example:
 
  > think cemit(Public,is open for people to talk on.)
  [Public] is now open for people to talk on.  ???
 
  This function is also avaliable as a command @cemit which performs
  as @cemit <channel>=<message>
  
& census
 
 >> Help: Census (Factional Command)
 -----------------------------------------------------------------------------
 Syntax: Census
 Syntax: Census/Spawn
 Syntax: Census/Squad
 
 The 'Census' command displays all currently connected members of your
 faction along with their ranks and current mechs.
 
 The second form, 'Census/Spawn' shows where each pilot that is currently out
 in RS was last spawned from. Please keep in mind the pilot may have moved
 far from what is listed.
 
 The third form is similar to the first but shows people in your squad. All
 members are shown whether they're connected or not, but those who aren't
 appear in dark gray and have a dark red DC in their 'RS' field.

 
& center()
 
  Syntax: center(<string>,<width>[,<fill>])
 
  This function will center a string in a string <width> characters
  wide, using <fil> characters for padding on either end of the string
  for centering. If no fill character is specified then a space is
  used. If <string> is longer than <width> characters, the string is
  returned unmodified.
 
  Example:
 
  > say center(a,5,-)
  You say "--a--"
  > say center(*BAMF*,15)
  You say "    *BAMF*     "
  
  See Also: ljust(), rjust().
  
& channel object
 
  In the comsystem, you may specify a channel object for each channel.
  (@cset/object channel=<object>).
  
  Channel objects allow you to specify a description for a channel,
  and place certain restrictions on joining, transmitting, and 
  receiving.
 
  NOTE: If a channel flag is set by @cpflags/@coflags, it will ALWAYS
  override the equivalent lock. The flags are set by default, so you
  will have to clear them before your locks work.
 
  The join lock for a channel is a normal @lock on the channel object. 
  The transmit lock for a channel is a use @lock on the channel
  object.
  The receive lock for a channel is an enter @lock on the channel
  object.
  The description of a channel is the @desc of the channel object.
  
& charge
 
  RS Command: charge [ID | -]
  
  This command attampts to crash your unit into another unit.
  
  As with all physical attacks you must be within the same hex as the 
  unit you are attacking.
  
  Arguments:
  none - attempt to charge your locked target
  * ID - attempt to charge the specified unit
  * - - abort a charge
  
  See Also: axe, chop, club, grabclub, kick, mace, punch, saw, trip
 import os

f = open("cat_attributes.txt","r")

line = f.readline()
while line:
	line = line.rstrip('\n')
	if os.path.exists(line):
		pass
	else:
		print line + " is not ok!"
	line = f.readline()
	
 
& checkstatus
 
  RS Command: checkstatus
  
  This command checks the RS unit and ascertains the amount of time 
  before repairs currently underway (if any) will be complete.
  
& children()
 
  Syntax: children(<object>)
 
  Returns a list of objects that are parented to <object>. Currently
  a WIZARD/ROYALTY only function.
 
  See Also: parent().
  
& chop
 
  RS Command: axe [R|L|B] [ID]
  
  This command causes your 'Mech to attack another RS Unit with an 
  sword. Naturally, this requires that your unit be equipped with an 
  sword.
  
  As with all physical attacks you must be within the same hex as the 
  unit you are attacking.
  
  Arguments:
  none - if a target is locked, attempt to attack that target
  * R - attempt to use the sword equipped on your Right arm
  * L - attempt to use the sword equipped on your Left arm
  * B - 
  * ID - specify a unit to trip
  
  See Also: axe, charge, club, grabclub, kick, mace, punch, saw,   
            trip 
& CHOWN_OK
 
  Flag: CHOWN_OK (C)
 
  This flag, when set, allows you to transfer ownership to
  another player. To set it, you must be carrying the object. You
  also have to be in the room if you want to set this flag on rooms
  or exits.  After this flag is set, the new player may gain
  ownership of the object by using the @chown command.
 
  See also: @chown, owner()
  
& clearcom
 
  Syntax: clearcom
 
  Removes all your aliases for channels. You should be extremely
  careful about this command, as it will wipe out all of your
  channel information.
 
  See also: addcom, delcom
  
& cleartic
 
  RS Command: cleartic <num>
  
  This command removes all weapons from the specified TIC.
  
  See Also: addtic, deltic, listtic
  
& climb
 
  RS Command: climb [angle]
  
  This command controls the angle of climb for Aero type RS Units.
  
  Arguments:
  none - displays the current climb angle
  angle - sets the climb angle
  
  NOTE - Aero units are currently non-functional within the codebase.
  
  See Also: thrust, dive
  
& clist()
 
  Syntax: Clist(<channel>)
 
  Gives you a listing of Connected users on the channel selected.
  Limited to WIZARDs only.
 
  See Also: cwho(), cobj(), cemit().
  
& club
 
  RS Command: club [ID]
  
  This command attempts to attack an RS Unit with your club. Naturally 
  this requires that your 'Mech have a club. A club can be obtained 
  using the grabclub command.
  
  As with all physical attacks you must be within the same hex as the 
  unit you are attacking.
  
  Arguments:
  none - attempt to club your locked target
  * ID - attempt to club the unit specified
  
  See Also: axe, charge, chop, grabclub, kick, mace, punch, saw, trip
  
& cobj()
 
  Syntax: cobj(<Channel>)
 
  This function returns the #dbref of the channel object for
<Channel>.
 
  Example:
 
  > think cobj(FAQ)
  #103
  
  See Also: cwho(), cemit().
  
& :
 
  Syntax: :<message>
 
  Displays <message> to everyone in your current room, preceded by
  your name and a space.  Example: the command ':jumps for joy'
  produces '<yourname> jumps for joy'.
 
  See also: page, pose, say, whisper, ;,"
  
& colorpairs()
 
  Syntax: colorpairs(obj/attr)
 
  This function returns the specified attribute on object with all
  'brackets' colored.
 
    * { and } are returned in red
    * [ and ] are returned in amber
    * ( and ) are returned in green
 
  Error Messages:
 
    * If the attribute does not exist on object the function returns
      an empty string
    * If the object is invalid the function returns #1 - NO MATCH
  
& columns()
 
  Syntax: columns(<list>, <width>[, <delim>])
 
  This function displays <list> formatted into columns containing
  <width> number of characters. As many columns as possible will be
  fit onto the screen.
 
  Columns takes an optional delimiter.
  
& alias
 
  Syntax: <channel alias> <on|off|who|message|:pose|;pose>
 
  'on' allows you to turn an alias on.
  'off' lets you temporarily leave that channel.
  'who' shows you who is on that channel.
 
  You may send a message over the channel with <alias> <text>, where
  <text> is the message to be sent, or you can pose on a channel
  with <alias> :<text> or <alias> ;<text>
 
  See also: allcom, comlist, addcom, delcom.
 
& combat 
 
 >> Help: Combat
 -----------------------------------------------------------------------------
 Unit Types		Technologies		Weapons		Ammo
 Piloting		Skills			Heat		Radio
 -----------------------------------------------------------------------------
 To view specifics about each topic, use 'help <topic>' without the <>'s.
 
 
& comlist
 
  Syntax: comlist
 
  Displays a list of all the aliases you are using, whether you are
  'on' or 'off' the channel, and some information about them, such
  as your channel title and status.
 
  See also: comtitle, addcom, alias, delcom
  
& comm-conventional
 
 >> Help: Comm-Conventional (Skills-Combat, Communication)
 -----------------------------------------------------------------------------
 Used for sending and deciphering analog transmissions
 
 
& comm-hyperpulse
 
 >> Help: Comm-Hyperpulse (Skills-Combat, Communication)
 -----------------------------------------------------------------------------
 
 
 
& commands
 
  Help available for MUX Commands:
  Note: Some commands are @-related.
 
  drop         enter        examine      get          give    
  goto         help         inventory    kill         leave    
  LOGOUT       look         move         news         OUTPUTPREFIX
  OUTPUTSUFFIX page         pose         QUIT         read     
  say          score        SESSION      take         think    
  throw        use          version      whisper      WHO
  "            :            ;            &            #        
  \\           @@           @cemit       @chown       @chzone  
  @clone       @cpattr      @create      @decompile   @destroy 
  @dig         @doing       @dolist      @drain       @edit    
  @emit        @entrances   @femit       @find        @force   
  @fpose       @fsay        @halt        @last        @link
  @list        @listmotd    @lock        @mail        @mvattr 
  @name        @notify      @npemit      @oemit       @open    
  @parent      @password    @pemit       @power       @program 
  @ps          @quitprogram @quota       @remit       @robot   
  @search      @set         @stats       @sweep       @switch  
  @teleport    @trigger     @unlink      @unlock      @verb
  @wait        @wipe  
 
  { 'help commands2' for more}
  
& commands2
 
  Help available for MUX Commands (continued):
 
  @aahear      @aclone      @aconnect    @adescribe   @adfail 
  @adisconnect @adrop       @aefail      @aenter      @afail   
  @agfail      @ahear       @akill       @aleave      @alfail  
  @alias       @amail       @amhear      @amove       @apay    
  @arfail      @asuccess    @atfail      @atofail     @atport  
  @aufail      @ause        @away        @charges     @cost
  @daily       @describe    @dfail       @drop        @ealias 
  @efail       @enter       @fail        @filter      @forwardlist
  @gfail       @idesc       @idle        @infilter    @inprefix
  @kill        @lalias      @leave       @lfail       @listen  
  @mailsucc    @move        @odescribe   @odfail      @odrop   
  @oefail      @oenter      @ofail       @ogfail      @okill
  @oleave      @olfail      @omove       @opay        @orfail 
  @osuccess    @otfail      @otofail     @otport      @oufail  
  @ouse        @oxenter     @oxleave     @oxtport     @pay     
  @prefix      @reject      @rfail       @runout      @sex     
  @signature   @startup     @success     @tfail       @tofail  
  @tport       @ufail       @use
  
& comp()
 
  Syntax: comp(<string1>, <string2>)
 
  This function compares two strings. It returns 0 if they are the
  same, 1 if <string2> is less than/precedes alphabetically <string1>,
  and -1 otherwise.
 
  See Also: sortby()
  
& COMPRESS
 
  Flag: COMPRESS (.)
 
  This flag is currently unused.
  
& computer
 
 >> Help: Computer (Skills-Combat, Misc.)
 -----------------------------------------------------------------------------
 Unit research
 Improves overheating rolls to avoid shutdowns
 
 
& comsys
 
  This is the help for the MUX comsystem. Note that the channel
  names and aliases are case-sensitive. Upon creation, new players
  automatically join the "Public" channel, while guest characters join
  channel "Guests" when they connect.
 
  Note: <alias> is the alias you choose for the channel.
  The "Public" channel for new players is aliased to "pub".
  The "Guests" channel for guests is aliases to "g".
 
  Aliases are the most common way to manipulate channels, and may be
  used in 2 different ways:
        <alias> <who|on|off>
        <alias> <message>
 
  { 'help comsys2' for more}
  
& comsys2
 
  For example:
  > pub off
  [Public] Foobar has left this channel.
 
  > pub on
  You have joined channel Public.
  [Public] Foobar has joined this channel.
 
  > pub who
  -- Players --
  Foobar(#23PWc)
  Wizard(#1PWc)
  -- Objects --
  -- Public --
 
  > pub Hello world! 
  [Public] Foobar says, "Hello world!"
 
  { 'help comsys commands' for more}
 & comsys commands
 
  These are the topics for the MUX comsystem:
  
  addcom       allcom       alias        comlist      comtitle     clearcom
  delcom
 
  @ccreate     @cboot       @ccharge     @cchown      @cdestroy    @clist
  @coflags     @cpflags     @cset        @cwho 
& comtitle
 
  Syntax: comtitle <alias>=<title>
 
  This command allows you to prefix your name on a channel with a
  title.
 
  For example:
  > comtitle pub=The Great and Powerful
  Title set to 'The Great and Powerful' on channel Public.
  > pub :waves to everyone.
  [Public] The Great and Powerful Foobar waves to everyone.
 
  See also: comlist, addcom, alias, delcom
  
& con()
 
  Syntax: con(<object>)
 
  This function returns the first object in the list of objects
carried
  by thing. Just the first, and only the first.
 
  See Also: next(), lcon(), lexits().
  
& config()
 
  Syntax: config(<directive>)
 
  This function returns the value set in the Mux configuration file
  for the directive specified.
 
  Example:
  >Say config(mail_database)
  You say "data/mail.db"
 
& conn()
 
  Syntax: conn(<player>)
 
  Returns the number of seconds that <player> has been connected.
  If <player> is not connected then -1 is returned. If <player> is
  connected more than once, the longest connect time is returned.
 
  Example:
 
  > WHO
  Player Name          On For Idle  Doing
  Wizard                00:04   1m
  Mortal                00:11   0s
  Evinar                00:12   6m  Idle. :)
  frobozz               00:32   6s
  4 Players logged in.
  > say conn(wiz)
  You say "251"
  > say conn(e)
  You say "770"
  > say conn(frobozz)
  You say "-1"
 
  See Also: WHO, idle(), lwho().
 
 
& CONNECTED
 
  Flag: CONNECTED (c)
 
  This flag applies only to players and it shows if the
  player is connected or not. Thus, each time you are connected to
  the game, you should see the 'c' flag set; otherwise, you are DEAD!
  You cannot reset this flag, and it is used internally by the code
  for things like tabulating players for the WHO list.
  
& connrecord()
 
  syntax: connrecord()
 
  This function returns the record number of connections to the game
  since the database was created.
 
  Example:
 
  >say connrecord()
  You say "85"
  
& contactoptions
 
  Attribute: contactoptions
  
  Depreciated. To be eliminated.
 
& contacts

  RS Command: contacts [Prefix/UnitID]
  
  This command returns a list of RS Units which are 'visible' to the 
  sensors of the RS Unit using the command.
  
  The command returns a single line for each RS Unit.
  
  Example:
  Given that you are in a unit a 0,0 with a heading of 180 degrees, 
  and an EXT-4D is at 4,2
  
  >contacts
  PS*[se]B T1 Extermina x:  4 y:  2 z:  0 r: 4.0 b:120 s:  0.0 h:  0 S:
  
  Continued in contacts2
  See Also: report, view, scan, brief
 
& contacts2

  The string returned is comprised of the following:
 
  * Sensor Flags:
     P - 'visible' to primary sensors
     S - 'visible' to secondary sensors
     * - located in front arc
     v - located in rear arc
     l - located in left arc
     r - located in right arc
  * UnitID
  * Unit Type:
     B - Biped
     F - Aerospace (including Dropships)
     H - Hover
     N - None
     Q - Quad
     T - Tracked
     V - VTOL
     W - Wheeled
  * Unit name
    (normally the first 2 characters of this are the faction ID)
  * X coordinate
  * Y coordinate
  * Range from your current location
  * Bearing from your current location
  * Speed of the unit
  * Heading of the unit
  * Unit status flags:
** D - Destroyed
** F - Fallen or prone
** f - standing
** J - Jumping
** S - Shutdown
** s - starting up
** T - Being towed
** t - Towing a unit
** H - unit is hulldown
** h - unit is raising or lowering
** L - unit's spotlight is on
** l - unit is lit by a spotlight
** E - Unit's ECM is active
** e - Unit is effected by ECM
** P - Unit's ECCM is active
** p - Unit is eccm protected
** + - Unit is Overheating
** M - Unit is using Special Movment - sprint
** m - Unit is using Special Movement - evade
** W - Battlesuits' with this flag are Mounted on another unit
** C - Unit is carrying a club
** O - Unit is OODing
** X - Unit is spinning
** I - Unit is infernoed
** B - Unit is burning
** G - Unit is staggered
** N - Unit is narc'ed
  
    See Also: report, view, scan, brief
  
& CONTROL_OK
 
  Flag: CONTROL_OK (z)
 
  There's a pretty good chance this flag doesn't exist.
  
& controls()

  Syntax: controls(<object>,<victim>)

  Returns 1 if <object> controls <victim>, 0 otherwise.

  Examples:

  > say controls(me,me)
  You say "1"
  > say controls(me,#1)
  You say "0"
  > say controls(#1,me)
  You say "1"
  
& convsecs()

  Syntax: convsecs(<seconds>)

  This function converts seconds to a time string, based on how many
  seconds the number is after Jan 1, 1970.

  Note: This function may also be called as secs2time()

  Example:

  > say secs()
  You say "709395750"
  > say convsecs(709395750)
  You say "Wed Jun 24 10:22:54 1992"

  See Also: convtime(), secs(), time().
  
& convtime()

  Syntax: convtime(<time string>)

  This functions converts a time string to the number of seconds since
  Jan 1, 1970. A time string is formatted: Ddd MMM DD HH:MM:SS YYYY
  where

  Ddd is the day of the week,
  MMM is the month, DD is the day of the month,
  HH is the hour in 24-hour time,
  MM is the minutes, SS is the seconds, and
  YYYY is the year.

  If you supply an incorrectly formatted string, it will return -1.

  Note: This function may also be called as time2secs().

  Example:

  > say time()
  You say "Wed Jun 24 10:22:54 1992"
  > say convtime(Wed Jun 24 10:22:54 1992)
  You say "709395774"

  See Also: convsecs(), secs(), time(), starttime().
  
& convuptime()

  Syntax: Convuptime(<Number of seconds to be converted>)

  This function converts the passed value from seconds to a worded
  representation of said time.

  Example:

  say convuptime(100)
  >You say "1 minute and 40 seconds"
  
  See Also: secs(), starttime().
  
& cos()

  Syntax: cos(<number>)

  Returns the cosine of <number>, expressed in radians.

  Examples:

  > say cos(0)
  You say "1"
  > say cos(fdiv(pi(),2))
  You say "0"
  > say cos(fdiv(pi(),4))
  You say "0.707107"
  > say cos(fdiv(pi(),6))
  You say "0.866025"
  
  See Also: acos(), asin(), atan(), pi(), sin(), tan().
  
& create()

  Syntax: create(<object>, <cost>[, <type>])

  Works the same as @create <object>, but returns the database number
  of the object created. <cost> is the cost of making the object.
  <type> is an optional parameter:

  'r' for rooms,
  't' for things, and
  'e' for exits.

  If no <type> is specified, then a thing will be created by default.

  See Also: @create.
  
& critstatus
 
  RS Command: critstatus <loc>
  
  This command displays the items installed in the specified <loc> and 
  the status of those items.
  
  Example:
  >critstatus lt
------------------------------------------------------------------------------
                             Left Torso Criticals                             
------------------------------------------------------------------------------
 1 Engine                               7 ERLargeLaser                        
 2 Engine                               8 ERLargeLaser                        
 3 Engine                               9 StreakSRM-6                         
 4 HeatSink                            10 StreakSRM-6                         
 5 HeatSink                            11 StreakSRM-6 Ammo (15)               
 6 HeatSink (Destroyed)                12 Case                                
------------------------------------------------------------------------------
  
  Continued in critstatus2
  
& critstatus2
 
  Locations:
  
  Biped Mech:
  * LA - Left Arm
  * RA - Right Arm
  * LT - Left Torso
  * RT - Right Torso
  * CT - Center Torso
  * LL - Left Leg
  * RL - Right Leg
  * H - Head
  
  Quad Mech:
  * FLL - Front Left Leg
  * FRL - Front Right Leg
  * LT - Left Torso
  * RT - Right Torso
  * CT - Center Torso
  * RLL - Rear Left Leg
  * RRL - Rear Right Leg
  
  Battle Suit:
  * S1 - Suit 1
  <to>
  * Sn - Suit n ... where n is the number of the last suit
  
  Vehicle:
  * LS - Left Side
  * RS - Right Side
  * FS - Front Side
  * AS - Aft Side
  * TU - Turret
  * R - Rotor
  
  Aerospace:
  * N - Nose
  * LW - Left Wing
  * RW - Right Wing
  * AS - Aft Side
  
  Aerodyne Dropship:
  * N - Nose
  * RW - Right Wing
  * LW - Left Wing
  * LRW - Left Rear Wing
  * RRW - Right Rear Wing
  * A - Aft
  
  Spheriod Dropship:
  * N - Nose
  * FRS - Front Right Side
  * FLS - Front Left Side
  * RLS - Rear Left Side
  * RRS - Rear Right Side
  * A - Aft 
& cwho()
 
  Syntax: cwho(<channel>)
 
  Returns a list of dbrefs who are connected, and on that channel.
  This is limited to wizards and channel owners.
  
& cwho()

  Syntax: cwho(<channel>)

  Returns a list of dbrefs who are connected, and on the specified
  channel. This is limited to WIZARD and channel owners.

  See Also: clist(), cobj(), cemit().
  
& damages
 
  RS Command: damages
  
  This command displays a report listing any damaged components on an RS Unit.
  
  As with all tech commands, this command requires a 'techbit'.
  
  Example:
  Given an undamaged unit:
  
  >damages
  The 'mech is in pristine condition!
  
  Given a damaged unit:
  >damages
  --------------------------------------------------------------------
                     Damage for Exterminator [SZ]                     
----------------------------------------------------------------------
1 :CT Repairs on armor (6 points)                                     
2 :CT Repairs on Engine                                               
3 :CT Repairs on Gyro                                                 
4 :RT Reload of Ammo Anti-MissileSystem (12 rounds)                   
5 :RA Repairs on armor (1 points)                                     
6 :RA Repairs on Lower Actuator                                       
7 :RL Repairs on Foot Actuator                                        
----------------------------------------------------------------------
(*) / Green = Job already done. Yellow = To be done.                  
 
  See Also: fix 
& DARK
 
  Flag: DARK (D)
 
  If a room is DARK, then no items are shown when a person
  'looks' there. If an object is DARK, then "look" does not list that
  object in the room's contents:, and if an exit is DARK, it doesn't
  show up in the Obvious Exits: list.  Puppets and objects that can
  listen cannot be DARK.
  
& dec()
 
  Syntax: dec(<number>)
 
  Decrements <number> - ie returns <number> minus 1. Much faster and
  more efficient than sub(<number>,1).
 
  Example:
  >Say dec(9)
  You say "8"
 
  See also: sub(), add(), inc().
  
& decrypt()
 
  Syntax: decrypt(<text>,<key>)
 
  Decrypts <text> using <key>. <key> should be the same one used to
  encrypt the text, and is case sensitive.
 
  See also encrypt()
  
& default()
 
  Syntax:  default(<obj>/<attr>,<default case>)
 
  This function returns the value of <obj>/<attr>, as if retrieved via
  the get() function, if the attribute exists and is readable by you.
  Otherwise, it evaluates the default case, and returns that.
  Note that the default case is only evaluated if the attribute does
  not exist or cannot be read.
 
  This is useful for code that needs to return the value of an
  attribute, or an error message or default case, if that attribute
  does not exist.
 
  Examples:
    > &TEST me=apple orange banana
    > say default(me/Test, No fruits!)
    You say "apple orange banana"
    > &TEST ME
    > say default(me/Test, No fruits!)
    You say "No fruits!"
 
  See also:  get(), get_eval(), u(), edefault(), udefault().
  
& delcom
 
  Syntax: delcom <alias>
 
  Deletes <alias> from your list of channel aliases. If <alias> was
  the only alias you had for a certain channel, you may no longer
  use that channel until you add a new alias for it.
 
  See also: addcom, comlist, clearcom
  
& delete()

  Syntax: delete(<string>,<first>,<len>)

  Returns <string>, but with <len> characters starting after the
  character at position <first> removed.  In other words, this
  function copies <first> characters, skips <len> characters, and
  then copies the remainder of the string.

  Example:
    > say delete(abcdefgh, 3, 2)
    You say "abcfgh"
    > say delete(Would you like coffee or perhaps tea?, 15, 18)
    You say "Would you like tea?"
  
& deltic
 
  RS Command: deltic <num> [<weapnum [,weapnum] | lownum-highnum >]
  
  This command deletes a weapon or weapons from a TIC.
  
  Arguments:
  
  * num - valid TIC's are 0 through 3
  * weapnum arguments:
    none - if no weapnum is specified the TIC is cleared of all 
           weapons.
    * weapnum - this is the number for the weapon as shown in by the
                status command. More that one weapon can be specified
                by separating the weapnums with commas.
    * lownum-highnum - this removess weapons from lownum to highnum 
                       inclusive.
                     
  Contined in deltic2
  
    See Also: addtic, listic, cleartic
  
& deltic2
 
  Example:
  Given an EXT-4D there are 3 ways to remove the 4 mediumlasers to one 
  TIC.
  
  Individually:
  >deltic 0 0
  Weapon #0 removed from TIC 0!
  >deltic 0 1
  Weapon #1 removed from TIC 0!
  <etc>
  
  Individually in one command:
  >deltic 0 0,1,2,3
  Weapon #0 removed from TIC 0!
  Weapon #1 removed from TIC 0!
  Weapon #2 removed from TIC 0!
  Weapon #3 removed from TIC 0!
  
  Inclusively:
  >deltic 0 0-3
  Weapons #0 - #3 removed from TIC 0!
  
  See Also: addtic, listic, cleartic
  
& @describe
 
  Syntax: @describe <object> = <description>
  Attribute: Desc
 
  Sets the description for <object>, which others see when they look
  at the object.  Giving all your objects, rooms, and exits good
  descriptions is considered to be good building practice.
 
  Function references and %-substitutions are allowed in descriptions,
  and are evaluated when someone looks at the object.  In function
  references, 'me' refers to the object being looked at, while %-
  substitutions that refer to the enactor (such as %n, %#, %p, etc)
  refer to the looker.
 
  Examples:
    <object> @desc vase = You see a delicate Ming vase.
    <exit>   @desc elevator = There is an elevator to the east.
 
  See also: look, @adescribe, @odescribe
  
& DESTROY_OK
 
  Flag: DESTROY_OK (d)
 
  When set on an object, it allows any player to destroy
  it as long as the object is not locked against them. This is good
  for things like notes, whereby the recipient can destroy the note
  after reading it, instead of having to look for you to destroy it.
  The DESTROY_OK flag overrides the SAFE flag, so that you do not need
  to give the /override switch to @destroy to destroy a thing that 
  is both DESTROY_OK and SAFE. When it is set on any object or the 
  owner of that object, that object can be destroyed immediately.
 
  See also: @destroy, SAFE
  
& detachcables
 
  RS Command: detachables <UnitID>
  
  This command disconnects the towing cables attached to <UnitID>
  <UnitID> must be the unit which is towing.
  
  NOTE - To use this command you must exit the RS Unit and execute 
  the command from the RS map.
  
  See Also: pickup, dropoff, attachcables
  
& die()
 
  Syntax: die(<number of rolls>, <number of sides on die>)
 
  This function simulates rolling dice. It "rolls" a die with the
  specified number of sides, the specified number of times, and sums
  the results.
    
  Example:
  > say die(2, 6)
  You say "8"
 
  The above would roll "2d6" - two six-sided dice, generating a
  result in the range 2-12.
  
& dig
 
  RS Command: dig
  
  This command causes a vehicle to dig a hole to provide additional 
  cover. Only tracked and wheeled vehicles can dig in.
  
  NOTE - Once dug-in only turret mounted weapons will be useable.
  
  To exit the hole you must move (eg speed <num> 
  
  See Also: hulldown, speed 
  
& digital mode
 
  setchannelmode: Digital mode:
  Flag: D or d
  
  This mode transmits less distance than analog, but is not 
  susceptible to scanning by enemy units. Additionally Relay and Info 
  modes can only be used in Digital mode.
  
  Digital mode is indicated by square brackets (ie '[]') around the 
  channel and bearing indicator
  
  Example: 
  Given that UnitID [TT] (calltitle MechJock) is within range and 
  transmitting on channel A in digital mode
  
  [A:054] <MechJock> Can you guys hear me?
  
& disable
 
  RS Command: disable <weapnum>
  
  This command disables the specified weapon.
  
  The command only works on gauss rifles.
  
& disembark
 
  RS Command: disembark
  
  This command causes you to exit the RS Unit you are in. 
  
  disembark only work on an RS Map ... not in a repair bay, etc.
  
& dist2d()
 
  Syntax: dist2d(x1, y1, x2, y2)
 
  This function returns the integer distance between the Cartesian
  points in two dimensions (x1,y1) and (x2,y2).
 
  Example:
    > say dist2d(0,0,3,4)
    You say "5"
 
  See also: dist3d()
  
& dist3d()

  Syntax: dist3d(x1, y1, z1, x2, y2, z2)

  This function returns the integer distance between the Cartesian
  points in three dimensions (x1,y1,z1) and (x2,y2,z2).

  Example:
    > say dist3d(0,0,0,10,15,20)
    You say "27"

  See also: dist2d()
  
& div()

  Syntax: div(<number1>,<number2>)

  This function returns the integer quotient from dividing <number1>
  by <number2>. <numberN> may be a floating point number, and an
  integer result is  returned.

  Example:
    > say div(15,3)
    You say "5"
    > say div(16,3)
    You say "5"
    > say div(15.9,2)
    You say "7"
    > say div(18,3)
    You say "6"
    > say div(-17,3)
    You say -5
 
  This function may also be called as idiv().

  See also: add(), fdiv(), mod(), mul(), round(), sub(), trunc().
  
& dive
 
  RS Command: dive [angle]
  
  This command controls the angle of dive for Aero type RS Units.
  
  Arguments:
  none - displays the current dive angle
  angle - sets the dive angle
  
  NOTE - Aero units are currently non-functional within the codebase.
  
  See Also: thrust, climb
  
 & dodge
 
  RS Command: dodge
  
  This command toggles dodge mode. This adds +2 to enemy physical 
  attack BTH.
  
  To use this command you must have the dodge_maneuver advantage.
  
  See Also: dodge_maneuver
  
& dodge_maneuver
 
 >> Help: Dodge Maneuver (Advantages)
 -----------------------------------------------------------------------------
 Syntax: Dodge
 
 +2 BTH to your enemy's physical attack rolls
 
 Result: It is harder for an enemy to hit you with physical attacks.
 
 
& doing()
 
  Syntax: doing(<player>)
 
  This function returns the value of the specified players doing, as
  set by the @doing command.
 
  Example:
  >WHO
  Player Name        On For Idle
  Fred                23:16   0s  Stuff
  Nurks            1d 00:05   0s  Other Stuff
  2 Players logged in, 85 record, no maximum.
 
  >say doing(Nurks)
  You say "Other Stuff"
 
  See Also: @doing
  
& drop
 
  Syntax: drop[/<switch>] <object>
           drop[/<switch>] <exit>
 
  The first form removes <object> from your inventory and puts it in
  your location, except for the following special cases: Dropping a
  STICKY thing sends it home, and dropping a thing in a room with a
  drop-to sends the thing to the drop-to location.
 
  The second form removes <exit> from your list of exits and adds it
  to the list of exits for the current location.  Anyone in the same
  location as you may then use the exit to travel to the exit's
  destination.  You can only drop exits when you own the location
  where you are dropping them.
 
  The following switch is recognized:
     /quiet   - Don't perform the @odrop/@adrop attributes on the
                dropped object.  This switch only works if you control
                the object.
 
  NOTE: 'throw' is the same as 'drop'.
 
  See also: get, @adrop, @drop, @odrop, DROP-TO, STICKY
  
& dropoff
 
  RS Command: dropoff
  
  This command releases a unit which you are towing.
  
  See Also: pickup, attachcables, detachcables
  
& dump
 
  RS Command: dump <weapnum|section|<loc> <pos>|all|stop> 

  This command causes the RS Unit to dump the ammunition specified.
  
  Arguments:
  * weapnum - dumps the ammunition suppy for the weapon. The number  
              used is the number ash shown in the status command.
  
  * section - dumps all ammunition in a section (eg LT, RA)
  
  * <loc> <pos> - dumps the ammunition stored in the ammo bin at 
                  <loc> <pos>
  
  * all - dumps all ammunition on the RS Unit.
  
  * stop - ceases all dumping.
  
& e()
 
  Syntax: e()
 
  Returns the value of the numeric constant e to nine decimal places.
 
  Example:
 
  > say e()
  You say "2.718281828"
 
  See Also: exp(), ln(), log(), power()
  
& eccm
 
  RS Command: eccm
  
  The command puts your ECM suite into ECCM mode, which enables it to 
  counteract enemy ECM.
 
  See Also: ecm 
& ecm
 
  RS Command: ecm
  
  This command toggles the status of your ECM suite. 
  
  ECM interferes with the communications and certain sensors of enemy 
  units within ranage of your 'ECM Umbrella'.
  
  See Also: eccm 
& edefault()
 
  Syntax: edefault(<obj>/<attr>,<default case>)
 
  This function returns the evaluated value of <obj>/<attr>, as if
  retrieved via the get_eval() function, if the attribute exists and
  is readable by you. Otherwise, it evaluates the default case, and
  returns that. The default case is only evaluated if the attribute
  does not exist or cannot be read.
 
  Example:
 
  > &TEST me=You have lost [rand(10)] marbles.
  > say edefault(me/Test,You have no marbles.)
  You say "You have lost 6 marbles."
  > &TEST me
  > say edefault(me/Test,You have no marbles.)
  You say "You have no marbles."
 
  See Also: get(), get_eval(), u(), default(), udefault()
  
& edit()
 
  Syntax: edit(<string>,<from>,<to>)
 
  This function edits <string>, replacing all occurrences of the
  substring <from> with the string <to>. If <from> is '$', then <to>
  is appended to <string>, while if <from> is '^', then it is
  prepended.
 
  Example:
 
  > say edit(This is a test,is,x)  
  You say "Thx x a test"
  > say edit(Atlantic,^,Trans)
  You say "TransAtlantic"
 
  See Also: @edit, remove()
  
& elements()
 
  Syntax: elements(<list of words>,<list of numbers>[,<delim>])
 
  This function returns the words in <list of words> that are in the
  positions specified by <list of numbers>. Optionally, a list
  delimiter other than a space can be separated.
 
  Example:
 
  > say elements(Foo Ack Beep Moo Zot,2 4)
  You say "Ack Moo"
  > say elements(Foof|Ack|Beep|Moo,3 1,|)
  You say "Beep|Foof"
  
& elock()
 
  Syntax: elock(<object>[/<whichlock>],<victim>)
 
  Checks if <victim> would pass the named lock on <object>. Only the
  object's owner may test locks other than the default lock.
  
& embark
 
  RS Command: embark <UnitID>
  
  This command causes your RS Unit to climb into a carrier unit.
  
  Upon entering the carrier your unit will be shutdown.
  
  See Also: udisembark 
& empty()
 
  Syntax: empty([<object>])
 
  This function completely empties the stack for the calling object.
  If <object> is specified, and you control it, it empties the stack
  for <object>.
 
  See Also: lstack(), items(), peek(), pop(), push(), OBJECT STACK
  
& encrypt()
 
  Syntax: encrypt(<text>,<key>)
 
  Encrypts <text> using <key>. The text can only be unlocked with
  <key>, and <key> is case-sensitive.
 
  See Also: decrypt()
  
& enter
 
  Syntax: enter[/<switch>] <object>
 
  The enter command is used to enter an object. Insides of objects are
  best used for vehicles, or storage spaces when you don't have a
  home (or even as a floating home).  In order to enter an object
  you must either own it or it must have its ENTER_OK flag set, and
  you must also pass the object's EnterLock (if it has one).
 
  The following switch is recognized:
 
     /quiet   - Don't perform the @oenter/@aenter or @oefail/@aefail
                attributes on the entered object, and don't perform
                the @oxleave attribute on your current
                location.  This switch only works if
                you control the object being entered.
 
  See also: leave, @aefail, @aenter, @efail, @enter, @idesc, @lock,
  @oefail, @oenter, @oxleave, ENTER_OK
  
& ENTER_OK
 
  Flag: ENTER_OK (e)
 
  If an object or person is ENTER_OK, other players may
  enter the object or person by using 'enter <object/person>'. Players
  must also have the ENTER_OK set if they wish to be able to receive
  things given to them by other players via 'give <player> =
  <object>'.
 
  See also: give, enter
  
& enterbase
 
  RS Command: enterbase [n|s|e|w]
  
  This command causes an RS Unit to enter a hangar/factory/etc from 
  the RS map.
  
  If a direction is specified the unit will arrive within the base at 
  the entrance associated with that direction (eg enterbase n will 
  bring your unit to the north entrance).
  
  If no direction is specified the unit will arrive at the default 
  entrance.
  
  Arguments:
  n - north
  s - south
  e - east
  w - west
  
  See Also: enterbay
  
& enterbay
 
  RS Command: enterbay [ID]
  
  The command causes an RS Unit to enter a bay of a mobile unit such 
  as a Dropship or Crawler.
  
  Arguments:
  [ID] - specifies the target ID of the unit which bay you wish to 
         enter. Normally this is optional, unless there are multiple 
         enterable objects in the hex
  
  See Also; enterbase
  
& eq()
 
  Syntax: eq(<integer1>,<integer2>)
 
  Takes two integers, and returns 1 if they are equal and 0 if they
  are not.
 
  Warning: Passing anything but integers will produce unexpected
  results, as non-numeric strings usually are treated as numeric 0.
 
  Example:
 
  > say eq(1,-1)
  You say "0"
  > say eq(5,5)
  You say "1"
  > say eq(foo, bar)
  You say "1"
 
  See Also: lt(), lte(), gte(), gt(), neq()
  
& escape()
 
  Syntax: escape(<string>)
 
  Returns <string> after adding an escape character (\) at the start
  of the string and also before each of the characters %;[]{}\ that
  appear in the string. This prevents strings entered by players from
  causing undesired side effects when used, such as making your
  object perform unintended commands or give out information to which
  you have access.
 
  Note that this function is only needed when the resulting string is
  to be passed through the @force command or be used as an attribute
  for an object (like the success message for a mail message object).
  This function has the advantage over the secure() function in that
  the string the user sees after evaluating it is the same as the
  original string.
 
  Example:
 
  You say "\Sneak a peek at Wiz's desc... \[get(#1/desc)\]"
 
  Note: 'say escape(Sneak a peek at Wiz's desc... [get(#1/desc)])'
  does not produce the expected result because the argument is
  evaluated BEFORE being processed by escape(), therefore the get()
  call has already been performed.
 
  See Also: secure()
  
 & eta
 
  RS Command: eta [x y]
 
  This command returns the range and estimated amount of time to reach
  the specified hex.
 
  The hex argument may be omitted if the unit is locked to the target
  hex.
  
 & evade
 
  RS Command: evade
  
  This command toggles evade mode.
  
  While evading the RS Unit is harder to hit, but cannot attack.
  
& eval()
 
  Syntax: eval(<object>,<attribute>)
  Syntax: eval(<string>)
 
  The first form of the eval function works exactly like the
  get_eval() function, but takes the object and attribute in two
  seperate arguments instead of an obj/attr pair. It is mainly used
  for compatibility with PennMUSH 1.50.
 
  The second form simply evaluates <string>. This is normally done
  when a function is called, however, it is useful in evaluating %q
  and %v substitutions.
 
  See Also: get_eval(), get(), xget()
  
& examine
 
  Syntax: examine[/<switches>] <object>[/<wild-attrib>]
 
  Displays all available information about <object>.  <object> may be
  an object, 'me' or 'here'. You must control the object to examine
  it, or it  must be set VISUAL.  If you do not own the object, you
  will just see the name of the object's owner, and optionally any
  public attributes and attributes owned by you set on the object.
 
  If an attribute is owned by a player other than the owner of the
  object, the number of the attribute owner is shown in parentheses
  immediately following the attribute name.  Flag letters may appear
  in parentheses also, to indicate the status of the attribute:
    + - The attribute is locked, it does not change ownership when the
        object is @chowned and may not be modified.
    $ - The attribute is not checked when looking for $-commands.
        Note that the predefined attributes DESC, IDESC, ODESC,
        FAIL, OFAIL,  SUCC, OSUCC, DROP, ODROP, SEX, and CHARGES are
        never checked.
    I - This attribute is not inherited by children of the object.
    V - The attribute is visible to anyone who examines you.  Note
        that the predefined attributes DESC, SEX, and LAST are
        always VISUAL.
 
  { 'help examine2' for more}
  
& examine2
 
  If you specify a wildcarded attribute name, then only those
  attributes that match are shown.  So, 'exam me/v?' will show all
  your attributes that start with v and are two characters long.
 
  The following switches are available:
     /brief  - Shows everything except attributes.
     /full   - When examining an object you don't control, show any
               public attributes set on the object in  addition to the
               owner's name.
     /parent - Includes attributes that are not present on the object
               itself but which are inherited from the object's
               parent.
 
  See also: look, @decompile, VISUAL, ATTRIBUTE OWNERSHIP.
  
& exit()
 
  Syntax: exit(<object>)
 
  This function returns the first exit on the list of exits in the
  object. DARK exits are not listed, unless you own the object. Unlike
  lexits(), this function does not provide information about exits in
  parent objects.
 
  See Also: con(), lcon(), lexits(), next()
  
& exp()
 
  Syntax: exp(<power>)
 
  Returns the result of raising the numeric constant e to <power>.
  <power> may be a floating point number, and a floating point result
  is returned.
 
  Example:
 
  > say exp(0)
  You say "1"
  > say exp(1)
  You say "2.718282"
  > say exp(2)
  You say "7.389056"
 
  See Also: e(), log(), ln(), power()
  
& explode
 
  RS Command: explode <ammo|reactor|stop>
  
  Arguments:
  
  * ammo - causes all the ammunition stored on your unit to be detonated.
  
  * reactor - causes the reactor to self destruct
  
  * stop - aborts the countdown (Disabled by default)
   
& explosive
 
  RS Command: explosive <weapnum>
  
  This command toggles the state of <weapnum>, causing it to fire 
  Explosive pods or normal homing pods.
  
  Explosive pods can only be used with NARC an iNARC launchers
  
& extinguish
 
  RS Command: extinguish
  
  This command permits you to put out the fires on your vehicle.
  
  Note - the unit must be shutdown before you can use this command.
  
& extract()
 
  Syntax: extract(<string>, <first>, <length>[, <delim>])
 
  Extract returns a string of length words, starting with the first
  word. Unlike letters, the first word in a string is number 1,
  instead of 0.
 
  Example:
 
  > say extract(This is a really neat example, 4, 2)
  You say "really neat"
  > say extract(Another@funky@test@for@extract, 3, 3)
  You say "test@for@extract"
 
  See Also: index(), insert(), ldelete(), replace(), first(), last(),
  rest()
 
& facroster
 
 >> Help: Facroster (Factional Command)
 -----------------------------------------------------------------------------
 Syntax: Facroster
 
 Displays a list of your faction's current active members (less than 14 days
 idle) along with their dbref, rank, XP, and last time they were connected. 


& faction
 
 >> Help: Faction (Factional Commands)
 -----------------------------------------------------------------------------
 Census			Ranklist	
 ---<Rank-Locked Commands (Require Officer/Commander Status)>-----------------
 Facroster		
 -----------------------------------------------------------------------------
 To view specifics about each command, use 'help <topic>' without the <>'s.
 

& factions
 
 >> Help: Factions (Informational Command)
 -----------------------------------------------------------------------------
 Syntax: Factions
 
 The 'Factions' command simply displays a list of the factions in the game and
 some basic information about each such as their names, abbreviations, 
 leaders, and the number of players in each.
 
 
& fdiv()
 
  Syntax: fdiv(<number1>,<number2>)
 
  Returns the floating point quotient from dividing <number1> by
  <number2>. <number> may be a floating point number, and a floating
  point result is returned.
 
  Example:
 
  > say fdiv(15,3)
  You say "5"
  > say fdiv(16,3)
  You say "5.333333"
  > say fdiv(17,3)
  You say "5.666667"
  > say fdiv(18,3)
  You say "6"
  > say fdiv(-17,3)
  You say "-5.666667"
  > say fdiv(10,3.5)
  You say "2.857143"
 
  See Also: add(), div(), mod(), mul(), round(), sub(), trunc()
  
& filter()
 
  Syntax: filter([<obj>/]<attr>, <list>[, <delim>])
 
  This function evaluates the contents of <attr> for each element of
  <list>, passing it in as %0. A <delimiter>-separated list is
  returned of those elements for which the evaluation returns the
  value 1.
 
  <delimiter> may be used to specify a delimiter other than space.
 
  Example:
 
  > &IS_ODD object=mod(%0,2)
  > say filter(object/is_odd,1 2 3 4 5)
  You say "1 3 5"
 
  Note: You can pass a %q0-9 register to a function indirectly as
  long as you don't over-write it in your filter() function.
 
  > &EXAMPLE.F object=[[setq(0,2)][filter(EXAMPLE.FIL,1 0 2 3 5 2)]
  > &EXAMPLE.FIL object=[eq(%q0,%0)]
  > say u(EXAMPLE.F)
  You say "2 2"
 
  See Also: u(), map(), fold()
  
& findable()
 
  Syntax: findable(<object>,<victim>)
 
  Returns 1 if <object> can locate <victim>, or 0 otherwise. This
  checks WIZARD status of <object>, UNFINDABLE status of <victim>, and
  other related factors.
 
  See Also: UNFINDABLE
  
 & findcenter
 
  RS Command: findcenter
 
  This command returns the range and bearing to the center of the hex
  the unit is currently in.
 
& finger
 
 >> Help: Finger (Informational Command)
 -----------------------------------------------------------------------------
 Syntax: Finger <player>
 
 Shows some information about the target player. If you're not in the
 player's faction you won't be able to see some of the fields (Unknown).
 
 You may set the following fields using these commands:
 EMail       - &FINGER_EMAIL me=<email address>
 
 
& fire
 
  RS Command: fire <weapnum> [<target-id> | <x> <y>]
  
  This command fires the specified weapon.
  
  Arguments:
  none - if no argument is specified the weapon will fire at the 
         locked target if there is one.
  * ID - fires the weapon at the specified RS object.
  * x y - fires the weapon at the specified hex.
  
& firecluster
 
  RS Command: firecluster <weapnum>
  
  This command toggles artillery weapons between firing cluster rounds 
  and normal ammunition.
  
& firemine
 
  RS Command: firemine <weapnum>
  
  This command toggles artillery weapons between firing mine rounds 
  and normal ammuntion.
  
& firesmoke
 
  RS Command: firesmoke <weapnum>
  
  This command toggles artillery weapons between firing smoke rounds 
  and normal ammunition.
  
& fireswarm
 
  RS Command: fireswarm <weapnum>
  
  This command toggles <weapnum> between firing swarm ammunition and 
  firing normal ammunition.
  
  Swarm ammunition can be fired by LRM weapons only.
  
& fireswarm1
 
  RS Command: fireswarm1 <weapnum>
  
  This command toggles <weapnum> between firing swarm1 ammunition and 
  firing normal ammunition.
  
  Swarm1 ammunition can be fired by LRM weapons only.
  
& firetic
 
  RS Command: firetic <num> [<target> or <x y>]
  
  This command instructs the weapons in the specified TIC to fire.
  
& first()
 
  Syntax: first(<string>[, <delim>])
 
  Returns the first word of a string, that is, everything to the left
  of the first space in the string, or the entire string if there are
  no spaces in the string. <delim> may be used to specify a word
  delimiter other than a space.
 
  Example:
 
  > say first(This is a test)
  You say "This"
  > say first(Would you like coffee, or perhaps tea)
  You say "Would"
  > say first(List&with&nonstandard&delimiters,&)
  You say "List"
 
  See Also: rest(), last(), extract()
  
& fix
 
  RS Command: fix [<num> | <low-high>]
  
  This command enables repair of any damage without the complexity 
  of using the correct command and specifying the location.
  
  Arguments:
  
  * <num> - starts repair of item <num> from the damages list
  * <low-high> - starts repair of numbers <low> through <high> from 
                 the damages list.
  
  Continued in fix2
  
& fix2
 
  Example:
  
  >damages
  --------------------------------------------------------------------
                         Damage for  [WH]                             
  --------------------------------------------------------------------
  1 :LA Repairs on armor (2 points)                                   
  2 :RT Repairs on armor (3 points)                                   
  3 :RA Repairs on armor (8 points)                                   
  4 :LT Repairs on armor (4 points)                                   
  --------------------------------------------------------------------
  (*) / Green = Job already done. Yellow = To be done.                
  --------------------------------------------------------------------
  
  >fix 1-3
  You start fixing the armor..
  Tech - BTH: 5(Base:4, Mod:1) Roll: 9
  You have 6 minutes of repairs pending and you're ready to do at 
  least 594 more minutes of work.
  You start fixing the armor..
  Tech - BTH: 5(Base:4, Mod:1) Roll: 7
  You have 15 minutes of repairs pending and you're ready to do at 
  least 585 more minutes of work.
  You start fixing the armor..
  Tech - BTH: 5(Base:4, Mod:1) Roll: 9
  You have 39 minutes of repairs pending and you're ready to do at 
  least 561 more minutes of work.
  
  > fix 4
  You start replacing the part..
  Tech - BTH: 6(Base:4, Mod:2) Roll: 10
  You have 45 minutes of repairs pending and you're ready to do at 
  least 555 more minutes of work.
  
& fixarmor
 
  RS Command: fixarmor <loc>
  
  This command repairs the armor on <loc>
  
  As with all tech commands, this command requires a 'techbit'.
  
  Example
  Given that you are inside a damaged RS Unit in a repairbay
  
  >damages
  --------------------------------------------------------------------
                      Damage for Exterminator [SZ]                    
  --------------------------------------------------------------------
  1 :RT Repairs on armor (2 points)                                   
  --------------------------------------------------------------------
  
  >fixarmor rt
  
  You start fixing the armor..
  BTH: 4 Roll: 7
  You have 6 minutes of repairs pending and you're ready to do at least 594 more minutes of work.
  
  See Also: fix, damages
  
& FIXED
 
  Flag: FIXED (f)
 
  No object may teleport or go home when this flag is set. This
  flag may only be set by a wizard. If set on a player, neither they
  nor any of their objects may teleport or go home.
 
  See also: @teleport, home
  
& fixinternal
 
  RS Command: fixinternal <loc>
  
  This command repairs internal structure in <loc>
  
& fixturret
 
  RS Command: fixturret
  
  This command permits you to fix a jammed turret.
  
& flags()
 
  Syntax: flags(<object>)
 
  This function returns a string consisting of the flags attached to
  the object. The string is not delimited.
 
  Example:
 
  > say [flags(me)]
  You say "PXP?IWXfces#"
 
  See Also: hasflag(), orflags(), andflags()
  
& flechette
 
  RS Command: flechette <weapnum>
  
  This command toggles the state of <weapnum>, causing it to fire 
  Flechette ammunition or normal ammuntion.
  
  Flechette ammo is available for AutoCannons only.
  
& fliparms
 
  RS Command: fliparms
  
  The command toggles the position of the arms on a mech equipped 
  with fliparms.
  
  When 'flipped' the arms point to the rear arc.
  
  Example:
  Given that you are in a mech with fliparms
  
  >fliparms
  Arms have been flipped to BACKWARD position
  >fliparms
  Arms have been flipped to FORWARD position
  
& FLOATING
 
  Flag: FLOATING (F)
 
  If a room is set floating, you will not be periodically notified
  that you have a disconnected room (i.e. one with no exits).
  
& floor()
 
  Syntax: floor(<number>)
 
  Returns the largest integer less than or equal to <number>. <number>
  may be a floating point number, and an integer result is returned.
 
  Example:
 
  > say floor(5)
  You say "5"
  > say floor(5.2)
  You say "5"
  > say floor(5.8)
  You say "5"
  > say floor(-5)
  You say "-5"
  > say floor(-5.2)
  You say "-6"
 
  See Also: ceil(), div(), mod(), round(), trunc()
  
& fold()
 
  Syntax: fold([<obj>/]<attr>, <list>[, <base-case>[, <delim>])
 
  This function iteratively processes a list through a function,
  feeding the result of one step into the next step as %0, passing in
  the next element from the list as %1. If a base case is provided, it
  is used as the initial %0. If not, the first list element is passed
  as %0 and the second is passed as %1, and subsequent iterations
  proceed normally.
 
  <delimiter> may be used to specify a delimiter other than space, but
  you must specify a base case in order to specify the delimiter.
 
  Example:
 
  > &REP_NUM object=[%0][repeat(%1,%1)]
  > say fold(object/rep_num,1 2 3 4 5,->)
  You say "->122333444455555"
  > &ADD_NUMS object=add(%0,%1)
  > say fold(object/add_nums,1 2 3 4 5)
  You say "15"
 
  See Also: u(), iter(), map(), filter()
  
& foreach()
 
  Syntax: foreach([<object>/]<attribute>,<string>[,<begin>, <end>])
 
  Maps a function onto a string.
 
  Each character in <string> has the user-defined function of the
  first argument performed on it; the character is passed to the
  function as %0. The results are concatenated. If <begin> and <end>
  are specified, only the characters between <begin> and <end> are
  parsed, other characters are concatenated as they are. This allows
  a rudimentary form of tokens and speeds up the evaluation greatly
  if tokenizing is your purpose.
 
  Example:
 
  > &add_one me=[add(%0,1)]
  > say [foreach(add_one, 54321)]
  You say, "65432"
 
  > &add_one me=[add(%0,1)]
  > say [foreach(add_one, This adds #0# to numbers in this
  string,#,#)]
  You say, "This adds 1 to numbers in this string."
 
& fullname()
 
  Syntax: fullname(<dbref>)
 
  This function returns the full name of the indicated object. This is
  the same as the name() function in all cases except when <dbref> is
  an exit, then all the aliases are returned as well.
 
  See Also: name()
  
& GAGGED
 
  Flag: GAGGED (G)
 
  When a player is set GAGGED, they cannot speak or pose under any
  circumstances.  This flag has no meaning for objects, exits, or
  rooms.
. 
& gattling
 
  RS Command: gattling <weapnum>
  
  This command toggles the weapon specified between gattling 
  (radipdfire mode) and normal mode.
  
  Only machineguns can use gattling mode.
. 
& get
 
  Syntax: get[/<switch>] <object>
           get[/<switch>] <exit>
           get[/<switch>] <object>'s <sub-object>
 
  The first form picks up <object> from your location and adds it to
  your inventory.  It will fail if the object is locked against you,
  or if you are inside a player or object that you don't control and
  which isn't set ENTER_OK.
 
  The second form takes an exit from your location and adds it to you.
  Anyone inside you may then use the exit to travel to the exit's
  destination. You may take exits that you own, and exits owned by
  others in locations that you own.
 
  The third form takes <sub-object> from <object> and adds it to your
  inventory.  <object> must be ENTER_OK and <sub-object> must not be
  locked against you for this to work.  The lock on <object> is not
  checked.
 
  { 'help get2' for more}
  
& get()
 
  Syntax: get(<object>/<attribute>)
 
  This function returns the value of <attribute> on <object>. If
  <attribute> is not present on <object> the funtion will search the
  parent of <object> for <attribute>.
 
  Example:
 
  > &TEST me=apple orange banana
  > say get(me/test)
  You say "apple orange banana"
 
  See Also: get_eval(), u(), edefault(), udefault(), xget()
  
& get2
 
  The following switch is recognized:
     /quiet   - Don't perform the @osucc/@asucc or @ofail/@afail
     attributes
                on the target object.  This switch only works if you
                control
                the object.
 
  <object> and <sub-object> may be either players or things.
 
  'take' is the same as 'get'.
 
  See also: drop, @afail, @asucc, @fail, @ofail, @osucc, @succ,
  ENTER_OK, FAILURE, SUCCESS.
  
* get_eval()
 
  Syntax: get(<object>/<attribute>)
 
  This function returns the value of <attribute> on <object>, in
  similar fashion to get(). However get_eval() performs function
  references and $-substitutions. In function references, 'me' refers
  to the object being looked at, and -substitutions that refer to the
  enactor (such as %n, %#, etc) refer to the object making the
  get_eval call. If the attribute is not present on <object>, its
  parent is searched for the attribute.
 
  Example:
 
  > @va test = This is a get_eval test on %n.  The vb is [get(me/vb)]
  > @vb test = VB from test
  > @vb me = VB from me
  > say get(test/va)
  You say "This is a get_eval test on %n. The vb is [get(me/vb)]"
  > say get_eval(test/va)
  You say "This is a get_eval test on Foobar. The vb is VB from test"
 
  See Also: get(), u(), edefault(), udefault(), xget()
  
& give
 
  Syntax: give <player>=<amount/object>
 
  Gives player the specified amount of money or <object>. You can't
  give someone money if their new total would be greater than 10000
  (No reason to get greedy).  You may also give players objects, but
  the other player must be set ENTER_OK to receive something you give.
 
  See also: @apay, @cost, @opay, @pay, ENTER_OK
  
& GOING
 
  Flag: GOING
 
  Used internally for the @destroy command, it is set on rooms that
  are about to be destroyed. In the event that a player decides they 
  don't want to destroy the room after all, they can unset it.
. 
& goto
 
  Syntax: goto[/<switch>] <direction>
           goto[/<switch>] home
           <direction>
           home
 
  Moves you in the specified direction, assuming that the direction is
  not locked against you.  'move home' is a special command that
  returns you to your home. The word 'move' may be omitted.
 
  The following switch is recognized:
     /quiet   - Don't perform the @osucc/@asucc/@odrop/@adrop or
                @ofail/@afail attributes on the exit being used.  This
                switch only works if you control the exit.
 
  NOTE: 'move' is the same as 'goto'.
 
  See also: enter, home, leave,
  
& grab()
 
  Syntax: grab(<list>, <pattern>[, <delim>])
 
  This function matches <pattern> against each word in <list>,
  returning the first word that matches. If no words match, then an
  empty string is returned. The match is not case-sensitive, and
  wildcard characters are permitted. <delim> may be used to specify a
  list delimiter other than a space.
 
  Example:
 
  > say grab(This is a new test,?e*)
  You say "new"
  > say grab(Holodeck:#10~Airlock:#58~Dorm:#12~Brig:#83,Airlock:*,~)
  You say "Airlock:#58"
 
  See Also: LISTS, match(), member()
  
& graball()

  FUNCTION: graball(<list>, <pattern>[, <idelim>])

  This function matches <pattern> against each word in <list>, returning
  all the words that match.  If no words match, then an empty string is
  returned.  The match is not case-sensitive, and wildcard characters
  are permitted in <pattern>.  <delim> may be used to specify the <list>
  delimiter other than a space.

  Examples:
    > say graball(This is a test of a test,test)
    You say, "test test"
    > say graball(This is testing a test,tes*)
    You say, "testing test"
    > say graball(It's time|To make|A party!,*party*,|)
    You say, "A party!"

  Related Topics: grab(), LISTS. 
& grabclub
 
  RS Command: grabclub [R|L|-]
  
  This command causes your unit to pick up a tree and wield it as a 
  club.
  
  To grab a club you must be in a forest hex, and your 'Mech must be 
  equipped with hand actuators.
  
  Arguments:
  * R - grab the club with your right hand
  * L - grab the club with your left hand
  * - - drop the club
  
  See Also: axe, charge, chop, club, kick, mace, punch, saw, trip
  
& grep()
 
  Syntax: grep(<object>,<attrs>,<pattern>)
 
  This function returns a list of attributes on <object> containing
  <pattern>. <attrs> is a wildcard pattern for attribute names to
  search; if you want to search all attributes, use "*".
 
  Parsing does occur before this function is invoked. Therefore,
  "special" characters will need to be escaped out. <pattern> is not
  wildcard matched. This function is case-sensitive. grepi() is a case
  insensitive version.
 
  See Also: grepi()
  
& grepi()
 
  Syntax: grepi(<object>,<attrs>,<pattern>)
 
  This function works exactly like grep(), but is case-insensitive.
 
  See Also: grep()
  
& gt()
 
  Syntax: gt(<integer1>,<integer2>)
 
  Takes two integers, and returns 1 if and only if <integer1> is
  greater than <integer2>, and 0 otherwise.
 
  Warning: passing anything but integers will produce unexpected
  results, as non-numeric strings usually are treated as numeric 0.
 
  Example:
 
  > say gt(4,5)
  You say "0"
  > say gt(5,5)
  You say "0"
  > say gt(6,5)
  You say "1"
  > say gt(foo, bar)
  You say "0"
 
  See Also: lt(), lte(), gte(), eq(), neq()
  
& gte()
 
  Syntax: gte(<integer1>,<integer2>)
 
  Takes two integers, and returns 1 if and only if <integer1> is
  greater than or equal to <integer2>, and 0 otherwise.
   
  Warning: Passing anything but integers will produce unexpected
  results, as non-numeric strings usually are treated as numeric 0.
 
  Example:
 
  > say gte(4,5)
  You say "0"
  > say gte(5,5)
  You say "1"
  > say gte(6,5)
  You say "1"
  > say gte(foo, bar)
  You say "1"
 
  See Also: lt(), lte(), gt(), eq(), neq()
  
& gunnery-artillery
 
 >> Help: Gunnery-Artillery (Skills-Combat, Gunnery)
 -----------------------------------------------------------------------------
 Used for firing artillery
 
 Example:
  * Mortar
 
 
& gunnery-ballistic
 
 >> Help: Gunnery-Ballistic (Skills-Combat, Gunnery)
 -----------------------------------------------------------------------------
 Used for firing ballistic weapons
 
 Example: 
  * AC (Auto-Cannon)
  * GR (Gauss Rifle)
  * LBX (Luxor Ballistic)
  * MG (machine gun)
 
 
& gunnery-flamer
 
 >> Help: Gunnery-Flamer (Skills-Combat, Gunnery)
 -----------------------------------------------------------------------------
 Used for firing flamers
 
 
& gunnery-laser
 
 >> Help: Gunnery-Laser (Skills-Combat, Gunnery)
 -----------------------------------------------------------------------------
 Used for firing laser weapons
 
 Example:
  * Small/Medium/Large Laser
  * Small/Medium/Large Pulse Laser
  * Small/Medium/Large ERLaser
 
 
& gunnery-missile
 
 >> Help: Gunnery-Missile (Skills-Combat, Gunnery)
 -----------------------------------------------------------------------------
 Used for firing missile weapons
 
 Example:
  * SRM (Short Range Missile)
  * MRM (Medium Range Missile)
  * LRM (Long Range Missile)
 
 
& gunnery-spotting
 
 >> Help: Gunnery-Spotting (Skills-Combat, Gunnery)
 -----------------------------------------------------------------------------
 Used when providing spotting data to someone firing artillery
 (see 'help spot')
 
 
& HALTED
 
  Flag: HALTED (h)
 
  While this flag is set, the object cannot perform any MUX
  actions, listen, be triggered, etc.
. 
& hasattr()
 
  Syntax: hasattr(<object>, <attribute name>)
 
  Returns 1 if the object has the named attribute, and 0 if it does
  not. If the object does not exist or the player does not have the
  ability to examine the object, #-1 will be returned.
 
  This function doesn't check for attributes inherited from parent
  objects, but hasattrp() does.
 
  See Also: hasattrp()
  
& hasattrp()
 
  Syntax: hasattrp(<object>, <attribute name>)
 
  Returns 1 if the object or its parent has the named attribute, and 0
  if it does not. If the object does not exist or the player does not
  have the ability to examine the object, #-1 will be returned.
  hasattr() can be used to just check objects for an attribute without
  checking their parent.
 
  See Also: hasattr()
  
& hasflag()
 
  Syntax: hasflag(<object>,<flag>)
 
  Returns true(1) if object <object> has the flag named <flag> set on
  it. You may not be able to retrieve information for objects that you
  do not own.
 
  Example:
 
  > say hasflag(me, wizard)
  You say "0"
  > say hasflag(me, connect)
  You say "1"
 
  See Also: orflags(), flags()
  
& haspower()
 
  Syntax: haspower(<object>,<power>) Returns true if object <object>
  has the power named <power> set on it. You may not be able to
  retrieve information for objects that you do not own.
 
  Example:
 
  > say haspower(me, announce)
  You say "0"
  > say hasflag(me, extended_who)
  You say "1"
 
  See Also: POWERS
  
& hastype()
 
  Syntax: hastype(<object>, <type>)
 
  Returns 1 if the object is of the named type, otherwise 0. Valid
  types are: ROOM, EXIT, PLAYER, THING. If an invalid type is given,
  #-1 is returned.
 .
& HAVEN
.
  Flag: HAVEN (H)
.
  If a location is set HAVEN, you cannot kill in that location. 
.
  See also: kill
. 
& HEAD
 
  Flag: HEAD(?)
 
  This is another marker flag, for faction heads and the like. As
  with STAFF, no powers come with it; it is purely a marker.
 
  See also: STAFF, ROYALTY, WIZARD
  
& heading
 
  RS Command: heading [<degrees>]
  
  If an argument is specified this command determines the direction 
  that an RS Unit will face.
  
  Without an argument the command returns the current heading of the 
  unit.
  
  The heading of the unit will not change immediately, as it takes 
  time for the unit to turn to another direction
  
  Example:
  Given that your unit's current heading is 120
 
  >heading 0
  Your current heading is 106.
  >heading
  Your current heading is 66.
  >heading
  Your current heading is 12.
  >heading
  Your current heading is 0.
  
& heat
 
  RS Command: heat <weapnum>
 
  This command toggles a flamer between heat and damage modes.
  
  In heat mode the flamer adds heat to the unit it strikes, 
  whereas in damage mode the weapon burns the unit it strikes causing 
  damage to the unit.
  
& heatcutoff
 
  RS Command: heatcutoff
  
  This command sets the heat dissipation of your mech to maintain 
  sufficient heat to activate TSM.
 
& help
 
                      -=< BattleTechMUX Help Index >=-
 
 You may view the help entry for any of the topics below by using the 'help'
 command followed by the topic name. The documentation provided here is
 mostly on commands, see the game's website for more information.
 
 Topics
 ------
 INFORM		- Informational commands.
 FACTION        - Factional commands.
 TEMPLATES	- Template related commands.
 MISC		- Commands that don't fit under the other categories.
 AGREEMENT      - What you agree to by completing registration.
 MUX		- The old MUX codebase help entries.
 BTMUXCREDITS   - The authors of BTMux. 

 
& hide
 
  RS Command: hide
  
  This command attempts to hide a team of battlesuits.
  
  To hide your team must be on a hex which has the following terrain 
  features:
  * forrest - may be either heavy or light
  * rough 
  * building
  
  NOTE - You cannot hide whislt in LOS of an enemy unit.
  
& home()
 
  Syntax: home(<object>)
 
  Returns the #dbref of the object's home.
 
  Example:
 
  > exam me
  Mortal(#226Pc)
  Type: PLAYER Flags: CONNECTED
  Desc:Just a plain, old boring Mortal. You know.
  Owner: Mortal  Key: VA:foobar Clams: 920
  Last:Thu Dec 19 08:57:21 1991
  Home: Mortal's Room(#367R)
  Location: The Town Square
  > say home(me)
  You say "#367"
 
  See Also: @link
  
& hotload
 
  RS Command: hotload <weapnum>
  
  This command toggles the state of an lrm launcher between hotload 
  and normal use.
  
  Hotloading missiles removes the short range penalties, however 
  there is an increased chance of jamming.
  
& HTML
 
  Flag: HTML (()
 
  This flag has been replaced with BLIND
 
& hulldown

  RS Command: hulldown [- | STOP]
 
  This command is used in a quad to lower the mech to the ground to
  gain more cover.
 
  Arguments:
  - - raises a unit which is hulldown
  STOP - cancels a change in the hulldown mode
 
  Examples:
 
  >hulldown
  You start to lower yourself to the ground.
  You finish lowering yourself to the ground.
  >hulldown -
  You start to lift yourself up.
  You finish lifting yourself up.
  >hulldown
  You start to lower yourself to the ground.
  >hulldown stop
  You start to lower yourself to the ground.
  You stop changing your hulldown mode.
  
& idle()
 
  Syntax: idle(<player>)
 
  Returns the number of seconds that <player> has been idle. If
  <player> is not connected then -1 is returned. If <player> is
  connected more than once, the smallest idle time is returned.
 
  Example:
 
  > WHO
  Player Name          On For Idle  Doing
  Wizard                00:04   1m
  Mortal                00:11   0s 
  Evinar                00:12   6m 
  frobozz               00:32   6s 
  4 Players logged in.
  > say idle(wiz)
  You say "6"
  > say idle(e)
  You say "371"
  > say idle(frobozz)
  You say "-1"
 
  See Also: WHO, conn(), lwho()
  
& ifelse()
 
  Syntax: ifelse(<expression>,<true string>,<false string>)
 
  This function returns <true string> if <expression> is true (greater
  than 0), <false string> otherwise. Much more efficient than an
  equivalent switch(). It can also return different messages based on
  whether <expression> is nothing or contains text.
 
  Example:
 
  > &TEST me=1
  >&TEST.F me=ifelse(hasattr(me,TEST),Test exists!,Test doesn't
  exist.)
  > say [u(TEST.F)]
  You say "Test exists!"
  > &TEST me=Someval
  > say [u(TEST.F)]
  You say "Test exists!"
  > @wipe me/TEST
  > say [u(TEST.F)]
  You say "Test doesn't exist!"
 
  See Also: switch()
  
& IMMORTAL
 
  Flag: IMMORTAL (i)
 
  Objects set immortal cannot be killed and don't use up money.
  Only settable by wizards.  This is useful when an object's location
  shouldn't be changed by Joe Player, but you don't want to have to
  relink it to its current location whenever it moves.
  
& IN_CHARACTER
 
  Flag: IN_CHARACTER (#)
 
  The IN_CHARACTER flag is specific to BTMux and denotes IC locations.
  These typically include units, jails, and other areas you generally
  want players to be secluded from the rest of the game. Note that 
  many games don't allow paging or comsys listening/broadcasting 
  from IC locations to prevent the flow of information.
 
  Also, units generally have to be set IC for players to be able to
  gain XP by shooting them.
  
& inarc
 
  RS Command: inarc <weapnum> <-|x|y|e>
  
  This command sets the type of pods to be fired by an INARC launcher.
  
  Arguments:
  * - - use standard (homing beacon) ammunition
  * e - use ECM ammunition
  * y - use 'haywire' ammunition
  * x - use explosive ammunition
  * z - use nemesis ammunition
  
& inc()
 
  Syntax: inc(<number>)
 
  Returns <number> plus 1. Much faster and more efficient than
  add(<number>,1).
 
  See Also: add(), sub(), dec()
  
& incendiary
 
  RS Command: incendiary <weapnum>
  
  This command toggles the state of <weapnum>, causing it to fire 
  Incendiary ammunition or normal ammunition.
  
  Incendiary ammo is available for AutoCannons only.
  
& index()
 
  Syntax: index(<list>,<character>,<first>,<length>)
 
  This function is similar to extract(), except that an item in the
  list may be more than one word; instead of a space being used to
  separate items in the list, <character> is used. The function
  returns <length> items starting from that in the <first> position.
  Trailing spaces are trimmed. The comma cannot be used as the
  <character> separator.
 
  Example:
 
  > say [index(Cup of Tea | Mug of Beer | Glass of Wine, |, 2, 1)]
  You say, "Mug of Beer"
 
  See Also: extract()
  
& inferno
 
  RS Command: inferno <weapnum>
  
  This command toggles the state of <weapnum>, causing it to fire 
  Inferno ammunition or normal ammunition.
  
  Inferno ammo is only used for missile launchers.
  
& info mode
 
  setchannelmode: Info mode
  Flag: I or i
  
  This mode indicates additional data about signals which are 
  relayed to you.
  
  Example:
  Given that you are out of radio range of UnitID [TT] but that UnitID 
  [BL] is within range of both units and has Relay enabled.
 
  [A:140] {R-path:[BL]-h:179} <MechJock> Can you guys hear me?
  
  * [A:140] indicates the bearing to UnitID [BL] from your unit.
  * (R-path:[BL]-  h:179) indicates that [BL] is relaying the 
    transmission to you and that the originating unit is at a bearing 
    of 179 degrees from UnitID [BL]
 
& inform
 
 >> Help: Inform (Informational Commands)
 -----------------------------------------------------------------------------
 Factions		Time			Uptime
 Stats			Ranklist		Staff
 Finger			Weather			Weaplist		
 Weapstats
 -----------------------------------------------------------------------------
 To view specifics about each command, use 'help <topic>' without the <>'s.
 
 
& INHERIT
 
  Flag: INHERIT (I)
 
  Previously, Wizard-owned objects had wizard powers.  This was
  a problem in many cases, so that behavior has changed.  Now, only
  Wizard objects or Wizard-owned Inherit-set objects have wizard 
  powers.
 
  Only players can set the Inherit flag, and the Inherit flag is 
  reset during @chown.  If a player is set Inherit, all his stuff is 
  assumed to be inherit, so his objects can control him.  If a 
  player is NOT Inherit, his stuff does NOT control him.  (i.e. 
  cannot @force him.)  This flag is not especially useful for non-
  wizards.
  
& insert()
 
  Syntax: insert(<list>, <pos>, <word>[, <sep>])
 
  This function inserts a word into <list> so that the word becomes
  the <pos>'th element of the list, and all subsequent list elements
  are moved down. This means that it appears between the <pos-1>'th
  and <pos>'th elements of the original list. This function may also
  be used to append a word to a list.
 
  <delim> may be used to specify a delimiter other than a space.
 
  Example:
 
  > say insert(This is a test, 4, new)
  You say "This is a new test"
  > say insert(Yet@Another@List, 3, Funky, @)
  You say "Yet@Another@Funky@List"
 
  See Also: extract(), ldelete(), replace()
  
& inventory
 
  Syntax: inventory
 
  Lists what you are carrying and how much money you have.
  
& inzone()
 
  Syntax: inzone(<object>)
 
  Returns a list of rooms in the zone defined by <object>. Currently a
  WIZARD/ ROYALTY only function.
 
  See Also: zone(), zplayers(), zwho(), zfun()
  
& isdbref()
 
  Syntax: isdbref(<string>)
 
  This function will return 1 if the string passed to it is a valid
  dbref. To be a valid dbref the string must begin with '#' and be
  followed by an integer. Also, the dbref must exist in the current
  database as a valid object. If the object fails either of these
  criteria, then a 0 is returned.
 
  Example:
 
  > say isdbref(#-1)
  You say "0"
  > say isdbref(#1)
  You say "1"
  > say isdbref(This is not a dbref)
  You say "0"
 
  See Also: isnum(), isword()
  
& isnum()
 
  Syntax: isnum(<string>)
 
  This function will return return 1 if the argument is a valid number
  and 0 if it is not.
 
  Example:
 
  > say isnum(22223.0000)
  You say "1"
  > say isnum(77)
  You say "1"
  > say isnum(22 L)
  You say "0"
  >say isnum(Bad Numbers!)
  You say "0"
 
  See Also: isdbref(), isword
  
& isword()
 
  Syntax: isword(<Text>)
 
  Returns 1 if the provided text is a word (comprised of one or more
  alphabetic characters ranging from A-Z).
 
  See Also: isnum(), isdbref()
  
& items()
 
  Syntax: items([<object>])
 
  This function returns the number of items that the stack of the
  calling object contains. If <object> is specified and you control
  it, then it returns the number of items in the stack of that
  object.
 
  See Also: lstack(), empty(), peek(), pop(), push(), OBJECT STACK
  
& iter()
 
  Syntax: iter(<list>, <eval>[, <delim>])
 
  <list> is a <delimter>-separated list of strings, which can be
  object numbers, attributes, or arbitrary words. <eval> is a string
  that is to be evaluated once for each item in <list>, replacing the
  special symbol ## with the corresponding item from <list>, and the
  symbol #@ with the position within the list being iterated. A space
  separated list of the results of these evaluations is returned to
  the caller.
 
  The effect is very similar to @dolist, except that the results are
  made into a list and returned, not executed.
 
  Example:
 
  > say iter(This is a test,strlen(##))
  You say "4 2 1 4"
  > say iter(This is a test,{strlen(##)})
  You say "4 2 1 4"
  > say iter(lnum(10),mul(mul(##,##),10))
  You say "0 10 40 90 160 250 360 490 640 810"
  > say iter(lcon(me),[name(##)]..[money(##)])
  You say "test..1 t1..1 radio..1 The Wizard's Pointy Hat..1"
  > say iter(Was it a cat I saw,[words(##)] #@,s)
  You say "1 1 4 2 1 3"
 
  See Also: @dolist, list(), parse()
  
& jettison
 
  RS Command: jettison
  
  This command causes a Battlesuit squad to jettison their backpacks.
  
& jump
 
  RS Command: jump [<TARGET-ID> | <bearing> <range>]
  
  This command activates the jumpjets of an RS Unit (if there are 
  any).
  
  Arguments:
  * <Target-ID> - Carry out a Death From Above attack on the target.
  * <bearing> <range> - Jump <range> hexes in the direction of 
                        <bearing>
  
& JUMP_OK
 
  Flag: JUMP_OK(J)
 
  When a room or thing is set JUMP_OK, that location can be teleported
  into by anyone.
 
  See also: @teleport
  
& KEY
 
  Flag: KEY (K)
 
  When set on an object prevents puppets from picking it up.
 
  See also: puppets
  
& kick
 
  RS Command: kick [R|L} [ID]
  
  This command causes your 'Mech to kick another RS Unit.
  
  As with all physical attacks you must be within the same hex as the 
  unit you are attacking.
  
  Arguments:
  none - if a target is locked, attempt to kick that target
  * R - attempt to kick with the Right leg
  * L - attempt to kick with the Left leg
  * ID - specify a unit to kick
  
  See Also: axe, charge, chop, club, grabclub, mace, punch, saw, trip
  
& kill
 
  Syntax: kill <player> [=<cost>]
 
  Attempts to kill the specified player. Killing costs <cost> coins,
  which gives you a <cost>% chance of killing the player. Thus,
  spending 100 coins always works (except against wizards and
  immortals, who can never be killed). Players cannot be killed in
  rooms which have been set HAVEN or which they control.  If you
  don't specify a cost, the default is 10 (for a 10% chance of
  success).  The player, if killed, receives <cost>/2 coins in
  insurance.
 
  See also: @akill, @kill, @okill, BEING KILLED, IMMORTAL, WIZARD
  
& land
 
  RS Command: land
  
  This command will cause your VTOL, Aero or dropship to land, if it 
  meets the required conditions (eg height, speed, etc).
  
  See Also: takeoff, vertical
  
& last()
 
  Syntax: last(<string>[, <delim>])
 
  Returns the last word of a string, that is, everything to the right
  of the last space in the string, or the entire string if there are
  no spaces in the string.
 
  The <delim> argument may be used to specify a delimiter other than
 'space'.
 
  Example:
 
  > say last(This is a test)
  You say "test"
  > say last(Happy-Fun-Test-Thing,-)
  You say "Thing"
 
  See Also: first(), rest(), extract()
  
& lastsite
 
  Attribute: lastsite

  Contains the name of the site from which the player last
  connected.
 
  See Also: last
  
& lateral
 
  RS Command: lateral [fl|fr|rl|rr|-]
  
  This command changes the movement of a quad to a direction 
  lateral to the heading of the mech.
  
  Arguments:
  fl - front left
  fr - front right
  rl - rear left
  rr - rear right
  - - disable lateral movement
  
& lateral2
 
  '''Effective Headings:'''<br>
  Given that the mech is represented by the * and has a heading of 0
  * A represents the actual direction of movement resulting from 
    'lateral fl'
  * B represents the actual direction of movement resulting from 
    'lateral fr'
  * C represents the actual direction of movement resulting from 
    'lateral rl'
  * D represents the actual direction of movement resulting from 
    'lateral rr'
 
 
     A     0     B
       300 ^  60  
         \ | /   
          \|/    
  270 <----*----> 90
          /|\   
         / | \  
       240 v 120
      C   180   D
  
& lattr()
 
  Syntax: lattr(<object>[/<wild-pattern>])
 
  Returns a list of the attributes set on <object>. If <wild-pattern>
  is given, only attributes matching it are returned.
 
  Example:
 
  > ex me
  Mortal(#226Pc)
  ....
  VC:Mon Sep  9 12:09:01 1991
  VE:baz
  Last:Thu Dec 19 08:57:21 1991
  VV(#2+):Foof!
  Domain:Abusees
  ....
  > say lattr(me)
  You say "Desc VC VE Last VV Domain"
  > say lattr(me/v*)
  You say "VC VE VV"
 
  See Also: hasattr(), get(), u()
  
& lbx
 
  RS Command: lbx <weapnum>
  
  This command toggles the state of <weapnum>, causing it to fire 
  LBX ammunition or normal ammuntion.
  
  LBX ammo is available for LBX-AutoCannons only.
  
& lcon()
 
  Syntax: lcon(<object>)
 
  Returns a space-separated list of the contents of <object>.
 
  Example:
 
  > i
  t1(#366)
  radio(#223)
  The Wizard's Pointy Hat(#188SO)
  You have 42463 clams.
  > say lcon(me)
  You say "#366 #223 #188"
 
  See Also: lexits(), lplayers(), lvplayers(), @dolist
  
& lcstr()
 
  Syntax: lcstr(<string>)
 
  Returns <string> with all letters converted to lowercase.
 
  Example:
 
  > say lcstr(This is something I want to TEST)                                     
  You say "this is something i want to test"
 
  See Also: capstr(), ucstr()
  
& ldelete()
 
  Syntax: ldelete(<list>, <pos>[, <sep>])
 
  This function removes a word from <list> by position. <delim> may be
  used to specify a delimiter other than a space.
 
  Example:
 
  > say ldelete(This is not a test, 3)
  You say "This is a test"
  > say ldelete(Yet@Another@Mundane@List, 3, @)
  You say "Yet@Another@List"
 
  See Also: remove(), delete(), extract(), insert(), replace()
  
& leave
 
  Syntax: leave[/<switch>]
 
  This command leave allows you to exit an object you have entered,
  arriving in the same location as the object. You may not leave an
  object if you fail that object's LeaveLock (but you may still
  @teleport out, use an exit inside the object, or go home).
 
  The following switch is recognized:
     /quiet   - Don't perform the @oleave/@aleave or @olfail/@alfail
                attributes on the entered object, and don't perform
                the @oxenter attribute on your new location.  This
                switch only works if you control your
                current location.
 
  See also: enter, @lock, ENTER_OK, @aleave, @alfail, @leave, @lfail,
  @oleave, @olfail, @oxenter
  
& lexits()
 
  Syntax: lexits(<loc>)
 
  Returns a space-separated list of the exits in <loc> and its
  parents.
 
  DARK exits are not returned unless you own the location.
 
  Example:
 
  > look here
  The Town Square
  You are in the town square.  All around you .....
  Obvious exits:
  foo  up  southeast  sw  north 
  > say lexits(here)
  You say "#302 #10 #9 #8 #6"
 
  See Also: lcon()
  
& link()
 
  Syntax: link(<Object>,<NewHome>)
 
  This function sets the target <Object>'s home to <NewHome>, which is
  the same as using @link.
 
  See Also: @link, home()
 & LINK_OK
 
  Flag: LINK_OK (L)
 
  If a room is LINK_OK, anyone can link exits TO it, though not FROM
  it.
  It has no meaning for people, things, or exits.
 
  See also: @link
  
& list()
 
  Syntax: list(<list>, <eval>[, <delim>])
 
  This function is exactly like iter() but serves a specialized
  purpose: MUX has a buffer limit, and for things like lists of
  players, iter() can quickly become inadequate, since the output is
  cut off before the listing is finished. The normal way to handle
  this is to use a @dolist/@pemit combination, but that takes many
  queue cycles. list() takes <list>, <eval>, and an optional
  delimiter, and evaluates them exactly like iter(). The difference
  is the output: iter() produces a space seperated list, while list()
  outputs each  list item on a new row of the screen.
 
  Note: This is a side effect function. It does not return anything,
  instead, it prints its output directly to the screen of the player
  causing the function to be evaluated. Since it does this, it is not
  hampered by the buffer limit.
 
  See Also: iter(), @dolist, parse()
  
& listchannels
 
  RS Command: listchannels
 
  This command displays the frequencies, channel mode, and comtitles
  set on an RS Unit.
 
  See Also: setchannelfreq, setchanneltitle, setchannelmode, 
            sendchannel
 
& listeras
 
 >> Help: Listeras (Template Command)
 -----------------------------------------------------------------------------
 Syntax: Listeras
 
 The 'Listeras' command will show all of our currently templated eras. These
 are in the format of a year number most of the time for the sake of
 familiarity.
 
 You can then use an era name with the 'Listrefs' command to view all refs in
 a particular era.
 
 See also: listrefs, viewref
 

& listrefs
 
 >> Help: Listrefs (Template Command)
 -----------------------------------------------------------------------------
 Syntax: Listrefs
 Syntax: Listrefs <era>
 
 The 'Listrefs' command displays a list of references requested by passing
 arguments to the command.
 
 - The first syntax listed will show the 'listrefs' help display.
 - The second syntax will list all refs in a particular era (2750, 3025, etc.) 
 
 See also: listeras, viewref
 
 
& listtic
 
  RS Command: listtic <num>
  
  This command lists the weapons in the specified TIC.
 
    See Also: addtic, cleartic, deltic
  
& lit()
 
  Syntax: lit(<string>)
 
  This function returns the string literally - without even squishing
  spaces, and without evaluating *anything*. This can be useful for
  writing ASCII maps with spaces or whatever. It can be a bit tricky
  to get a literal string with spaces into an attrib, however, since
  spaces are usually squished in setting an attribute.
 
  Example:
 
  > @va me=$test: think {[lit(near       far)]}
  Set.
  > ex me/va
  VA [#1]: $test: think {[lit(near       far)]}
  > test
  near       far
 
  Note: Leaving out the {}'s will not work in the above.
  
& ljust()
 
  Syntax: ljust(<string>, <length>[, <fill>])
 
  This function pads a string with trailing <fill> characters, or with
  spaces if no fill character is given) ("left-justifies") so it is
  <length> long. If <string> is longer than <length>, the <string> is
  returned; it is not truncated.
 
  Example:
 
  > say -[ljust(foo,6)]-
  You say "-foo   -"
  > say %r0[ljust(foo,6)]7%r01234567
  You say "
  0foo   7
  01234567"
  > say =[ljust(bar,5,.)]=
  You say "=bar..="
 
  See Also: rjust(), strlen()
  
& ln()
 
  Syntax: ln(<number>)
 
  Returns the result of taking the natural logarithm (base e) of
  <number>. <number> may be a floating point number, and a floating
  point result is returned.
 
  Example:
 
  > say ln(0)
  You say "#-1 LN OF NEGATIVE OR ZERO"
  > say ln(1)
  You say "0"
  > say ln(e())
  You say "1"
  > say ln(10)
  You say "2.302585"
 
  See Also: e(), exp(), log(), power()
  
& lnum()
 
  Syntax: lnum(<number>)
 
  Returns a list of numbers from 0 to <number>-1.
 
  Example:
 
  > say lnum(5)
 You say "0 1 2 3 4"
 
& loadcargo
 
  RS Command: loadcargo <name> <amount>
  
  This command loads <amount> of <name> into the RS Unit.
  
  See Also: unloadcargo, manifest, stores
  
& loc()
 
  Syntax: loc(<object>)
 
  Returns the number of the location where <object> is. You must
  either control the object or be nearby for it to work. When used on
  an exit it returns the destination of the exit. You can also use
  loc() to find the location of players that are not set UNFINDABLE.
 
  Example:
 
  > look
  Mortal's Room(#367R)
  A bare room with nothing in it but a bed and a chair.
  Contents:
  hat(#368)
  > say loc(me)
  You say "#367"
  > enter hat
  hat(#368)
  Contents:
  cat(#325)
  > say loc(me)
  You say "#368"
  > say loc(here)
  You say "#367"
 
  See Also: rloc(), room(), where()
  
& locate()

  Syntax: locate(<looker>,<string>,<where>)

  The locate function is used to look for an object from the
  perspective of <looker> (You must own <looker>). The database
  number of the item that is found is returned. The <where> parameter
  specifies a list of places to look, from this list:

    * a - Look for absolute references (#<number>)
    * c - Look for exits carried by <looker> (and by <looker>'s
parents).
    * e - Look for exits in <looker>'s location (and the location's
parents).
    * h - Look for 'here', which matches <looker>'s location.
    * i - Look in <looker>'s inventory.
    * m - Look for 'me', which matches <looker>.
    * n - Look for <looker>'s neighbors (other objects in the same
location).
    * p - Look for player names prefixed by a '*'
    * * - Look for everything in the above list.

  You may also specify qualifiers in <where> to help resolve possible
  ambiguities:

    * E - Prefer exits over other types.
    * L - Prefer unlocked exits over locked exits.
    * P - Prefer players over other types.
    * R - Prefer rooms over other types.
    * T - Prefer things over other types.
    * V - Report "Can't find..." and "Which one..." errors to
<looker>.
    * X - Select randomly if search finds multiple matches.

Continued in locate()2
 
& locate()2
 
  If nothing matches, the value #-1 is returned. If more than one
  thing of the preferred type matches, but nothing matches exactly,
  the value #-2 is returned, except if the X qualifier was specified
  in which case one is chosen at random. If more than one thing
  exactly matches, one is chosen at random. If you specify more than
  one type preference (E, P, R, or T), then the last one entered is
  the one that is obeyed. The default is for no type to be preferred.
 
  Example:
 
  > i
  test1(#378)
  test(#376)
  You have 42463 clams.
  > look
  Nullspace(#250R)
  test1(#382)
  > say locate(me,test,i)                > say locate(me,tes,in)
  You say "#376"                         You say "#-2"
  > say locate(me,test,n)                > say locate(here,tes,*)
  You say "#382"                         You say "#382"
  > say locate(me,test1,in)              > say locate(me,out,e)
  You say "#378"                         You say "#252"
  > say locate(me,test1,in)              > say locate(me,here,*)
  You say "#382"                         You say "#250"
 
  See Also: num(), PARENT OBJECTS
  
& lock
 
  RS Command: lock [<ID> | <x> <y> [<b|h|i|c>] | -]
  
  This command sets the targetting system of your RS Unit to the 
  specified target. Targets can be another RS Unit, a hex, or an 
  object within a hex.
  
  Arguments:
  * - - clears the current lock
  * ID - sets <ID> as the target. ID must be in line of sight. If ID 
         leaves line of sight the target lock will be lost.
  * x y - targets any units in the the hex designated by x y. Objects 
          in a hex can be specified using the following flags:
    * b - locks the building in the specified hex
    * h - locks the hex rather than any units in it
    * i - locks the hex for the purposes of setting it on fire
    * c - locks the hex for the purposes of clearing it
  
  Continued in lock2
  
& lock()
 
  Syntax: lock(<object>[/<whichlock>])
 
  Returns the named lock on <object>. If you don't specify the lock to
  get, the default lock is returned. You must control <object>.
 
  See Also: eloc()
  
& lock2
 
  Example:
  To lock UnitID zz:
  > lock zz
  Target set to T1 Zorya [zz].
  The sensors acquire a stable lock on T1 Zorya [om].
  
  To lock a hex for igniting:
  >lock 10 15 i
  Target coordinates set to igniting hex at (X,Y) 10, 15
  
  To lock a building within a hex:
  >lock 15 9 b
  Target coordinates set to building at (X,Y) 15, 9
  
  To lock a hex (and therefore any units within that hex)
  >lock 0 0
  The sensors acquire a stable lock on (0,0).
  
& log()
 
  Syntax: log(<number>)
 
  Returns the result of taking the common logarithm (base 10) of
  <number>. <number> may be a floating point number, and a floating
  point result is returned.
 
  Example:
 
  > say log(0)
  You say "#-1 LOG OF NEGATIVE OR ZERO"
  > say log(1)
  You say "0"
  > say log(10)
  You say "1"
  > say log(e())
  You say "0.434294"
 
  See Also: e(), exp(), ln(), power()
  
& logf()
 
  Syntax: logf(<logfile>,<text>)
 
  Logs specified text to the specified log file. This only works if
  the log file already exists in /game/logs. All text passed through
  logf() is evaluated but all formatting is stripped.
 
  See Also: @log
  
& LOGOUT
 
  Syntax: LOGOUT
 
  Disconnects you from your character without breaking the network
  connection to the game.  You may then log in to another character.
  The LOGOUT command must be entered in all capitals.
 
  See also: QUIT
  
& look
 
  Syntax: look[/<switches>] [<object>]
 
  Displays the description of <object>, or the room you're in if you
  don't specify an object.  Specifying object as <name> or #<dbref>
  or 'me' or 'here' is legal.  You can also use look to look at
  objects held by other people, just use 'look <person>'s <object>'.
 
  You may use the /outside switch to look at the location of your
  current location (useful if you are inside a vehicle or other
  object).  You may also look at other objects in the 'outer'
  location, but you may not use the possessive form with the
  /outside switch (ie: "look/outside <person>'s <object>" won't
  work).
 
  'read' is the same as 'look'.
 
  See also: @adesc, @describe, @odesc
  
& lparent()
 
  Syntax: lparent(<object>)
 
  This function returns a list consisting of the object's db# (as per
  the num() function), the db# of its parent, grandparent,
  greatgrandparent, etc. The list will not, however, show parents of
  objects which the player is not privileged to examine.
 
  See Also: parent(), children(), num()
  
& lplayers()

  FUNCTION: lplayers(<object>)

  Returns a space-separated list of the players inside <object>, connected
  or not.

  See Also: lcon(), lvplayers()
& lrs

  RS Command: LRS <M|T|E|L|S|H|C> [<BEARING> <RANGE> | <TARGET-ID>]

  Displays a long range map.

  Arguments:

  * M - MECH - displays RS units
  * T - TERRAIN - displays terrain features (buildings, trees, water,
        etc)
  * E - ELEVATION - displays the z value for hexes with a z <> 0
  * L - LOS - displays the line of site from your location. A ? is
        shown for hexes which are not in LOS
  * H - HEIGHT -
  * C - COMBINED - displays a the elevation of a hex (including 0) and
        colors the value depending on the terrain type (light green
        for light forrest, dark green for heavy forrest, etc)
 
   Continued in lrs2   
 
& lrs2

   By default the LRS map is centered on your current location. Using
   the <bearing> and <range> permits you to view the map offset from
   your current location by <range> hexes in the direction of
   <bearing>
  
   Example:
   Given that you are located at 100 100
  
   >lrs t
  
   Will display an LRS map of the terrain centered on 100 100
  
   >lrs t 90 20
  
   Will display an LRS map of the terrain centered on 120 100
    
& lrsheight
 
  Attribute: lrsheight <num>

  This attribute controls the number of hexes (vertically) displayed
  when using the 'lrs' command when in an RS unit.

  If the attribute is not set the command defaults to 11 hexes.
 
  See Also: lrs 
& lstack()
 
  Syntax: lstack([<object>])
 
  This function returns the contents of an object's stack as a list.
  If <object> is not specified, then it returns the stack of the
  executing object.
 
  See Also: push(), pop(), peek(), empty(), items(), OBJECT STACK
  
& lt()
 
  Syntax: lt(<integer1>,<integer2>)
 
  Takes two integers, and returns 1 if and only if <integer1> is less
  than <integer2>, and 0 otherwise.
 
  Warning: Passing anything but integers will produce unexpected
  results, as non-numeric strings are usually treated as numeric 0.
 
  Example:
 
  > say lt(4,5)
  You say "1"
  > say lt(5,5)
  You say "0"
  > say lt(6,5)
  You say "0"
  > say lt(foo, bar)
  You say "0"
 
  See Also: lte(), gte(), gt(), eq(), neq()
  
& lte()
 
  Syntax: lte(<integer1>,<integer2>)
 
  Takes two integers, and returns 1 if and only if <integer1> is less
  than or equal to <integer2>, and 0 otherwise.
 
  Warning: Passing anything but integers will produce unexpected
  results, as non-numeric strings are usuallly treated as numeric 0.
 
  Example:
 
  > say lte(4,5)
  You say "1"
  > say lte(5,5)
  You say "1"
  > say lte(6,5)
  You say "0"
  > say lte(foo, bar)
  You say "1"
 
  See Also: lt(), gte(), gt(), eq(), neq()
  
& lvplayers()

  FUNCTION: lvplayers(<object>)

  Returns a space-separated list of connected players inside <object>.

  See Also: lcon(), lplayers() 
& lwho()
 
  Syntax: lwho()
 
  Returns a list of the db numbers of connected players.
 
  Example:
 
  > WHO
  Player Name          On For Idle  Doing
  Mortal                00:11   0s 
  Evinar                00:12   6m 
  Wizard                00:32   6s 
  3 Players logged in.
  > say lwho()
  You say "#226 #271 #1"
 
  See Also: WHO, conn(), idle()
  
& mace
 
  RS Command: mace [ID]
  
  This command causes your 'Mech to attack another RS Unit with a 
  mace. Naturally, this requires that your unit be equipped with an 
  mace.
  
  As with all physical attacks you must be within the same hex as the 
  unit you are attacking.
  
  Arguments:
  none - if a target is locked, attempt to attack that target
  * ID - specify a unit to attack
  
  See Also: axe, charge, chop, club, grabclub, kick, punch, saw, trip
  
& mail()
 
  Syntax: mail(<mail message #>)
  Syntax: mail(<player name>)
  Syntax: mail(<player>, <mail message #>)
  Syntax: mail()
 
  The first form returns a message corresponding to that mail message
  number in your MUX mailbox. This function can be used to forward
  mail, or as a way to simply transfer mail messages to attributes on
  an object.
 
  The second form returns three numbers, corresponding to the number
  of read, unread, and cleared messages <player> has. The third form
  returns <player>'s <mail message #>. It works like the first form
  except it applies to another player. The last form returns the
  number of messages the evaluating player has. Only wizards can use
  the second and third forms of the function on other players.
 
  See Also: mailfrom(), @mail
  
& mail-admin
 
  The @mail command can also take the following switches:
 
    @mail/stats [<player>]    --  Basic mail statistics.
    @mail/dstats [<player>]   --  Also provides read/unread count.
    @mail/fstats [<player>]   --  Does all that, plus gives space
                                  usage.
 
    @mail/debug <action>[=<player>]
    @mail/nuke
 
  Only wizards may stats players other than themselves. The mail
  statistics  commands are computationally expensive, and thus are
  subject to "daytime"  restrictions. They also cost the same as a
  @find (100 credits).
 
  The /debug switch does sanity checking on the mail database, and may
  only be used by a wizard. "@mail/debug sanity" just does the
  check; the command "@mail/debug clear=<player name or dbref
  number>" wipes mail for an object.
  "@mail/debug fix" attempts to repair problems noted in the sanity
  check.
 
  The /nuke switch destroys the post office, erasing all @mail
  everywhere. It may only be used by a wizard.
 
  Also, admin may set the @amail attrib on their char.  When somebody
  sends you mail, it will trigger that attrib if it exists.
  
& mail-examples
 
  Here is an example of mailing a player, where is the player will be
  "bob", and sending the mail.
 
  > @mail bob = The MUX              - This is the Subject line.
 
  Sending mail to player 'Bob'
  > -Hi bob.                         - This is where you will enter
                                       the body of the message.
  Text Added.
  > @send                            - Basically, sends the @mail.
 
  MAIL: You sent your message to 'Bob'.
  
& mail-folders
 
  The MUX mail system allows each player 16 folders, numbered from
  0 to 15. Mail can only be in 1 folder at a time. Folder 0 is
  the "inbox" where new mail is received. Most @mail commands
  operate on only the current folder.
 
  @mail/folder
        This commands lists all folders which contain mail, telling
        how many messages are in each, and what the current folder is.
 
  @mail/folder <folder#|foldername>
        This command sets your current folder to <folder#>.
 
  @mail/folder <folder#> = <foldername>
        This command gives <folder#> a name.
 
  @mail/file <msg-list>=<folder#>
        This command moves all messages in msg-list from the current
        folder to a new folder, <folder#>.
  
& mail-other
 
  @mail/clear [<msg-list | all>]
  @mail/unclear [<msg-list> | all>]
        These commands mark mail in the current folder as cleared or
        uncleared.
        Mail marked for clearing is deleted when you disconnect, or
        if you use @mail/purge. If no msg-list is specified, all
        mail in your current folder is cleared. If "all" is given
        instead of a msg-list, all mail in *all* folders is
        cleared/uncleared.
 
  @mail/purge
        Actually deletes all messages marked for clearing with
  @mail/clear.
        This is done automatically when you log out.
 
  @mail/tag [<msg-list | all>]
  @mail/untag [<msg-list> | all>]
        These commands tag or untag mail in the current folder.
        Tagged mail can be later acted on en masse by using "tagged"
        as the msg-list for other commands (which does *not*
        untag them afterward). If no msg-list is specified,
        all messages in the current folder are tagged/untagged. If
        "all" is given as the msg-list, all mail in *all*
        folders is tagged/untagged.
   
  Example:
  To clear all mail from Lauren and Crusade:
  @mail/tag *lauren,
  @mail/tag *crusade
  @mail/clear tagged
  @mail/untag all
 
{ 'help mail-other2' for more }
  
& mail-other2
 
  @mail/safe [<msg-list> | all>]
        This command marks a message as being safe from mail
        expiration. It should be used sparingly and only for
        very imporatant messages.
  
& mail-reading
 
  @mail <msg #>
  @mail/read <msg-list>
        This displays messages which match the msg# or msg-list from
        your current folder.
 
  @mail
  @mail <msg-list, but not a single msg #>
        This gives a brief list of all mail in the current folder,
        with sender name, a list of receiving players, subject, and
        message status.
  @mail/list [<msg-list>]
        This gives the same list, but with time sent instead of
        subject.
        The status field is a set of characters (ex: NC-UF+) which
        mean:
                N = New (unread) message
                C = Cleared message
                U = Urgent message
                F = Forwarded message
                + = Tagged message
        The opposites of these (read messages, etc.) are indicated
        with a '-' in the status field in that position.
  
& mail-reviewing
 
  @mail/review <player>
  Reviews the messages you have sent to <player>.
 
  @mail/review <player>=<msglist>
  Reads the messages you have sent to <player>.
 
  @mail/retract <player>=<msglist>
  Retracts (deletes) unread messages you have sent to <player>.
  
& mail-sending
 
  @mail[/switch] <player-list> = <subject>
  This begins a message to all players in <player-list>.
  -<text> adds text to the message in progress, for example
  -This is a test
  would add the text 'This is a test' to the end of your @mail
  message, likewise, ~<text> prepends the text.

  @mail/send
  This sends the message that is currently in progress.
  -- is the equivalent of @mail/send. @mail/urgent sends
  the message as urgent, and should not be used often.
 
  @mail/cc <player-list>
        This replaces the currect player list with a new one for
        carbon copying. It does _not_ add onto the existing
        list.
 
  { 'help mail-sending2' for more }
  
& mail-sending2
 
  @mail/proof
	This shows you the message that is currently in progress, as
	it would be read by whomever received it.
 
  @mail/edit <old text> = <new text>
  Like @edit, but edits the message in process.
 
  @mail/abort
  This aborts the message currently in progress, allowing you
  to start a new one.
 
  @mail/fwd <msg> = <player-list>
        This sends a copy of <msg> to all the players in
        <player-list>.
        The copy will appear to have been sent by you (not the
        original sender), and its status will be "Forwarded".
        Note that this places the message to be forwarded into
        your mail buffer, where you can edit it with @mail/edit, add
        text with '-', or prepend text with '~'. You have to
        use '--' or @mail/send to send the message.
 
  @mail/quick <player-list>/<subject> = <message>
  Sends <message> to the list of players.
  
& mailfrom()
 
  Syntax: mailfrom(<msg #>)
 
  Returns the dbref # of the player who sent you <msg #>. Wizards may
  specify mailfrom(<player>,<msg #>).
 
  See Also: mail(), @mail
  
& maneuvering_ace
 
 >> Help: Maneuvering Ace (Advantages)
 -----------------------------------------------------------------------------
 Syntax: turnmode <tight/normal>
 
 Better BTH on lateral movements in non-VTOL units
 
 Result: You can move easier laterally in non-VTOL units, and you can change
 your turning style to make sharper turns - at the cost of losing more speed
 whilst doing so.
 
 
& manifest
 
  RS Command: manifest
  
  This command lists the parts and commodities and their amounts in 
  the RS Unit.
  
  See Also: stores, loadcargo, unloadcargo
  
& map()
 
  Syntax: map([<obj>/]<attr>, <list>[, <delim>])
 
  This function is nearly identical to an iter() operating on u()
  function. Each member of <list> is passed to the result of fetching
  <attr> as %0, and the results are used to form a new list, separated
  by the delimiter character.
 
  <delimiter> may be used to specify a delimiter other than space.
 
  Example:
 
  > &ADD_ONE object=add(%0,1)
  > say map(object/add_one,1 2 3 4 5)
  You say "2 3 4 5 6"
 
  See Also: filter(), fold(), iter(), parse(), u()
  
& masc
 
  RS Command: masc
  
  This command toggles the state of your Mechs MASC system.
  
& match()
 
  Syntax: match(<string>, <pattern>[, <delim>])
 
  This function matches <pattern> against each word of <string>,
  returning the number of the first word that matches. If no words
  match then 0 is returned. The case of the characters being matched
  is not significant.
 
  The pattern may contain the wildcards '*' and '?'. '?' matches any
  one character, while '*' matches any number of characters, including
  none. So 's?x' would match 'sex' or 'six', but not to 'socx', but
  's*x' would match any of them. <delim> may be used specified to
  specify a delimiter other than a space.
 
  Example:
 
  > say match(This is a test, test)
  You say "4"
  > say match(This is a test, is)
  You say "2"
  > say match(This is a test, *is*)
  You say "1"
  > say match(This is a test, *not*)
  You say "0"
  > say match(This is a test, is a)
  You say "0"
 
  See Also: LISTS, member(), strmatch()
  
& matchall()
 
  Syntax: matchall(<string>,<pattern>[,<delim>])
 
  This function works identically to the match() function, save that
  it returns all matches, not just the first: It returns the index
  numbers of all words in the list <string> which match <pattern>.
 
  Example:
 
  > say matchall(This is a test of a test,test)
  You say "4 7"
  > say matchall(This is testing a test,tes*)
  You say "3 5"
 
  See Also: LISTS, match(), strmatch()
  
& max()
 
  Syntax: max(<number1>,<number2>[,<numberN]...)
 
  Returns the largest integer from among its arguments. Up to 30
  arguments may be specified. <numberN> may be a floating point
  number, and a floating point result is returned.
 
  Example:
 
  > say max(2,4)
  You say "4"
  > say max(-100,50,0,25)
  You say "50"
 
  See Also: min()
  
& mechdesc
 
  Attribute: mechdesc <description>

  This attribute allows the addition of markings on an RS unit, which
  can be seen using the 'view' command from another RS unit.

  Example
  Given that bz is the unitID of an RS unit with 'mechdesc:A nasty
  looking monster of a mech' and bk is the unitID of an RS unit with
  no mechdesc attribute

  >view bz
  A nasty looking monster of a mech
  >view bk
  That target has no markings.

  See also: view
  
& mechprefs
 
  RS Command mechprefs [<setting>] [<on|off>]
  
  This command controls and displays the mechprefs for the RS Unit.
  
  If no argument is specified the command show the state of all 
  mechprefs.
  
  Arguments:
  * setting - if you specify a setting the command will toggle 
              the state of that setting.
  * on - turns the setting on
  * off - turns the setting off
  
  Continued in mechprefs2
  
& mechprefs2
 
  Settings:
  
  * MWSafety - determines if the unit will fire on a Mechwarrior on 
               the map. When set ON the unit will NOT fire on a 
               mechwarrior.
  
  * SLWarn - determine if the unit will warn you when it is lit by a 
             spotlight. When set ON the unit will warn when lit.
  
  * AutoFall - determines if the unit will attempt to avoid running 
               off  cliffs. When set ON the unit will NOT attempt to 
               avoid cliffing. 
  
  * ArmorWarn - determines if the unit will warn when a section has 
                low armor. When set ON the unit will report low armor.
  
  * AmmoWarn - determines if the unit will warn when running low on 
               ammunition. When set ON the unit will warn of low ammo.
  
  * AutoconShutdown - determines if the unit will report contacts on 
                      units which are shutdown. When set ON the unit 
                      will report on contacts which are shutdown.
  
  * FFSafety - determines if the unit will fire on friendly units. 
               When set ON the unit will NOT fire on friendly units.
  
& melee_specialist
 
 >> Help: Melee Specialist (Advantages)
 -----------------------------------------------------------------------------
 When performing physical attacks, you receive a -1 on attacker's movement
 mods (lowest 0)
 Increase physical damage by +1
 
 Result: You are better at performing physical attacks since this advantage
 lessens/negates your enemy's movement mods. When you hit with your physical
 attack, you hit harder.
 
 
& member()
 
  Syntax: member(<list>, <word>[, <delim>])
 
  This function takes a list and a word, and returns the position of
  that word within the list. If the word does not occur in the list,
  then 0 is returned. Unlike match(), member() does not check for
  wildcarding, and the cases of <list> and <word> are significant. A
  word is defined as a string which has no interior spaces. So 'hello'
  would be one word, while 'hello there' would be two. <delim> may be
  used to specify a delimiter other than a space.
 
  Example:
 
  > say member(This is a member test, member)
  You say "4"
  > say member(This is a member test, Member)
  You say "0"
  > say member(This is a member test, *e*)  
  You say "0"
  > say member(This is a member test, is a)
  You say "#-1 CAN ONLY TEST ONE ELEMENT"
 
  See Also: LISTS, match(), strmatch()
  
& merge()
 
  Syntax: merge(<string1>,<string2>,<character>)
 
  This function merges <string1> and <string2>, depending on
  <character>. If a character in <string1> is the same as <character>,
  it is replaced by the character in the corresponding position in
  <string2>. The two strings must be of the same length.
 
  Spaces need to be treated specially. A null character is considered
  to equal a space, for <character>.
 
  Example:
 
  > say merge(AB--EF,abcdef,-)
  You say, "ABcdEF"
  > say merge(AB[space(2)]EF,abcdef,)
  You say, "ABcdEF"
 
  See Also: splice()
  
& mid()
 
  Syntax: mid(<string>, <first>, <length>)
 
  This function returns a segment of <string>, the <length> characters
  to the right of the <first> character.
 
  Note: The first character in a string is numbered zero, and not one.
 
  Example:
 
  > say mid(12345678,0,3)
  123
  
& min()
 
  Syntax: min(<number1>,<number2>[,<numberN]...)
 
  Returns the smallest integer from among its arguments. Up to 30
  arguments may be specified. <numberN> may be a floating point
  number, and a floating point result is returned.
 
  Example:
 
  > say min(2,4)
  You say "2"
  > say min(-100,50,0,25)
  You say "-10"
 
  See Also: max()
 
& misc 
 
 >> Help: Misc (Misc Commands)
 -----------------------------------------------------------------------------
 Selfboot	Available
 -----------------------------------------------------------------------------
 To view specifics about each command, use 'help <topic>' without the <>'s.
 
 
& mix()
 
  Syntax: mix([<object>/]<attribute>,<list 1>,<list 2>[,<delim>])
 
  This function is similar to map(), except that it takes the elements
  of both lists, one by one, and passes them to the user-defined
  function as %0 and %1, respectively, for elements of <list 1> and
  <list 2>. <delim> is used to separate elements; if it is not
  specified, it defaults to a space. The lists must have the same
  number of elements.
 
  Example:
 
  > &add_nums me=[add(%0,%1)]
  > say [mix(add_nums,1 2 3 4 5,2 4 6 8 10)]
  You say, "3 6 9 12 15"
  > say [mix(add_nums,1:3:5:7,0:2:4:6,:)]
  You say, "1:5:9:13"
 
  See Also: map()
  
& mod()
 
  Syntax: mod(<integer1>,<integer2>)
 
  Returns the integer remainder from dividing <integer1> by
  <integer2>.
 
  Example:
 
  > say mod(15,3)
  You say "0"
  > say mod(16,3)
  You say "1"
  > say mod(17,3)
  You say "2"
  > say mod(18,3)
  You say "0"
 
  See Also: add(), fdiv(), div(), mul(), round(), sub(), trunc()
  
& money()
 
  Syntax: money(<object>)
 
  Returns an integer equal to the amount of money <object> has (if it
  is a player). If the specified object isn't a player, the value of
  the target is returned.
 
  Example:
 
  > score
  You have 1052 clams.
  > say money(me)
  You say "1052"
  > exam sac test
  Sac Test(#287V)
  Type: THING Flags: VISUAL
  Owner: Beaker  Key: *UNLOCKED* Clams: 20
  Home: Limbo(#0RLDAJ)
  Location: The Town Square
  > say money(sac test)
  You say "20"
  
& MONITOR
 
  Flag: MONITOR(M)
 
  When set on an object, anytime the object hears something from
  someone who passes the object's use lock, the object's attributes 
  are scanned for attributes of the form '^<pattern>:<commandlist>'.  
  If the message matches the wildcarded <pattern>, then 
  <commandlist> is executed, substituting %0 for the text that 
  matched the first wildcard, %1 for the second, and so on.
  
  All matching attributes are executed, not just the first.
  Parents of MONITOR objects are never checked for ^-patterns.
 
  When set on a player, this flag notifies that player whenever
  someone connects or disconnects from the MUX. It is valid only for 
  players, and must be set by a wizard.
 
  See also: LISTENING
  
& move
 
  Syntax: move[/<switch>] <direction>
           move[/<switch>] home
           <direction>
           home
 
  Moves you in the specified direction, assuming that the direction is
  not locked against you.  'move home' is a special command that
  returns you to your home. The word 'move' may be omitted.
 
  The following switch is recognized:
     /quiet   - Don't perform the @osucc/@asucc/@odrop/@adrop or
                @ofail/@afail attributes on the exit being used.  This
                switch only works if you control the exit.
 
  NOTE: 'goto' is the same as 'move'.
 
  See also: enter, home, leave.
  
& mudname()
 
  Syntax: mudname()
 
  Returns the name of the MUX. This is usually (but not necessarily)
  the name that appears in the various mud lists. This can be set via
  the mud_name config directive.
 
  Example:
 
  > say mudname()
  You say "Battletech: Random Mux"
  
& mul()
 
   Syntax: mul(<number1>,<number2>[,<numberN>]...)
 
  Returns the result of multiplying its arguments together. <numberN>
  may be a floating point number, and a floating point result is
  returned.
 
  Example:
 
  > say mul(3,5)
  You say "15"
  > say mul(3,5,-2)
  You say "-30"
 
  See Also: add(), div(), fdiv(), mod(), round(), sub(), trunc()
  
& MULTIOK
 
  Flag: MULTIOK (y)
 
  This flag is merely used as a marker for any softcoded multi
  checking code you may have. It serves absolutely no purpose under 
  the MUX itself.
  
& munge()
 
  Syntax: munge([<object>/]<attribute>,<list 1>,<list
2>[,<delimiter>])
 
  This function takes two lists of equal length. It passes the
  entirety of <list 1> to the user-defined function as %0. Then, this
  resulting list is matched with elements in <list 2>, and the
  rearranged <list 2> is returned. This is useful for doing things
  like sorting a list, and then returning the correspoding elements
  in the other list. If a resulting element from the user-defined
  function doesn't match an element in the original <list 1>, a
  corresponding element from <list 2> does not appear in the final
  result.
 
  For example: Consider attribute PLACES, which contains "Fort Benden
  Ista", and another attribute DBREFS contains the dbrefs of the main
  JUMP_OK location of these areas, "#20 #9000 #5000". We want to
  return a list of dbrefs, corresponding to the names of the places
  sorted alphabetically. The places sorted this way would be "Benden
  Fort Ista", so we want the final list to be "#9000 #20 #5000". The
  functions, using munge(), are simple:
 
  > &sort_alpha me=[sort(%0)]
  > say [munge(sort_alpha,v(places),v(dbrefs))]
  You say, "#9000 #20 #5000"
  
& mute mode
 
  setchannelmode:   Mute mode:
  Flag: U or u
  
  This mode silences a channel. This is useful if you are relaying 
  messages which you do not wish to listen to.
 
& mux
 
  This is the MUX online help facility.
 
     Notes on help descriptions: 
        [text] - Text enclosed in []'s is optional.  The []'s are never typed
                 in as part of the command.
        <parameter> - Information parameter for a command.  The <>'s are
                      never typed in as part of the command.
 
  -  Syntax of help command:
       help [<command>]
 
  -  To get a list of MUX topics:
       help topics 
 
  -  To get a list of Comsystem commands:
       help comsys
  
  -  To get a list of MUX Commands:
       help commands      (or @list commands)
  
  Some of the configuration shown in the help.txt might not be the same as
  the configuration of this MUX. If you notice any errors, contact an Admin.

 
& MYOPIC
 
  Flag: MYOPIC (m)
 
  If you are set MYOPIC, then you are treated as if you did not own
  anything when you use the 'look' command or when you automatically 
  look at a location upon entering it.  Other commands (such as 
  'examine') are not affected.
  
& name()
 
  Syntax: name(<dbref>)
 
  This function returns the name of the indicated object. When called
  with an exit it returns the only the first alias.
 
  See Also: fullname()
  
& narc
 
  RS Command: narc <weapnum>
  
  This command toggles the state of <weapnum>, causing it to fire NARC 
  compatible ammunition or normal ammunition.
  
  NARC applies only to missile type ammuntion.
  
& navigate
 
  RS Command: navigate
 
  This command returns a graphical representation of the hex your unit
  is located in, and the surrounding hexes.
  
& nearby()
 
  Syntax: nearby(<obj1>,<obj2>)
 
  Tests if <obj1> is near <obj2> (if it is in the same location, in
  <obj2>'s inventory, or is <obj2>'s location). You must control
  either <obj1> or <obj2>, or be near either one of them, if both of
  these tests fail then 0 is returned. This function returns 1 if the
  two objects are nearby and 0 if not.
 
  See Also: loc()
  
& neq()
 
  Syntax: neq(<integer1>,<integer2>)
 
  Takes two integers, and returns 1 if they are not equal and 0 if
  they are equal.
 
  Warning: Passing anything but integers will produce unexpected
  results, as non-numeric strings usually are treated as numeric 0.
 
  Example:
 
  > say neq(1,-1)
  You say "1"
  > say neq(5,5)
  You say "0"
  > say neq(foo, bar)
  You say "0"
 
  See Also: lt(), lte(), gte(), gt(), eq(), not()
  
& news
 
  Syntax: news [<topic>]
 
  Shows you the current news for the MUX. It is highly recommended
  that you check the news daily for new information.  Otherwise, the
  wizards will have no pity on you for messing up with the new
  commands.
  
& next()
 
  Syntax: next(<thing>)
 
  If thing is an exit in a room, then next will return the next
  nondark exit in the list of exits for that room. If thing is an
  object, then next will return the next object in the inventory list
  that the object is in. Otherwise, it returns a '#-1' string.
 
  See Also: lexits(), lcon()
  
& no_command
 
  Flag: NO_COMMAND (n)
 
  The NO_COMMAND flag disables the checking of $-commands on an
  object.
 
  Most MUXes will be configured to automatically set this flag on
  rooms and players. The server runs faster when fewer objects are 
  checked for $-commands; thus, any object which does not have $-
  commands on it should be set NO_COMMAND.
  
& NOBLEED
 
  Flag: NOBLEED (-)
 
  When set on a player, it will append an ANSI white character to
  the normal ANSI 'normal' character, so it will fix ANSI color
  'bleed' on most terminals. (Bleed occurs when a color extends into 
  text it was not meant to.) Do not set this flag unless you have 
  to, it tends to slow down the text display for the MUX.
 
  See also: ANSI
  
& NOSPOOF
 
  Flag: NOSPOOF(N)
 
  This flag will prepend information about the origin of @emits before
  each one.  It can get spammy, but it prevents people from spoofing 
  you.
 
  See also: @emit, @femit, @oemit, @pemit
  
& not()
 
  Syntax: not(<boolean>)
 
  Takes a boolean value, and returns its inverse. So, if the input is
  equivalent to true(1) it returns a 0, and if the input is equivalent
  to false(0), it returns a 1.
 
  See Also: BOOLEAN VALUES, and(), or(), xor()
  
& nss
 
  RS Command: nss
  
  This command toggles the status of the Null Signature System for 
  those units so equipped.
  
& num()
 
  Syntax: num(<object>)
 
  Returns the dbref number of <object>.
 
  See Also: locate()
  
& obj()
 
  Syntax: objmem(<object>)
 
  Returns the size in bytes of <object>. Note that this is the
  complete struct size of the object, and not just the attribute
  values.
 
  See Also: playmem()
  
& objeval()
 
  Syntax: objmem(<object>)
 
  Returns the size in bytes of <object>. Note that this is the
  complete struct size of the object, and not just the attribute
  values.
 
  See Also: playmem()
  
& objmem()
 
  Syntax: objmem(<object>)
 
  Returns the size in bytes of <object>. Note that this is the
  complete struct size of the object, and not just the attribute
  values.
 
  See Also: playmem()
  
& ogfail
 
  Syntax: @ogfail <object> = <message>
  Attribute: Gfail
 
  Sets the message (prefixed by the plaayer's name) that is shown to
  others in the same room when someone tries to give <object> but
  fails because he didn't pass the object's give lock.
 
  Function references and %-substitutions are allowed in give failure
  messages, and are evaluated when someone tries to give away the
  object.
 
  In function references, 'me' refers to the object being given away,
  while %-substitutions that refer to the enactor (such as %n, %#,
  %p, etc) refer o the (attempted) giver.
 
  This attribute is only meaningful for players and things, and will
  never be automatically triggered on other object types.
 
  Example:
  @ogfail sword =  can't give away a cursed sword!
 
  See also: give, @agfail, @ogfail, @lock
  
& @ogfail
 
  Syntax: @ogfail <object> = <message>
  Attribute: Ogfail
 
  Sets the message (prefixed by the player's name) that is shown to
  others in the same room when someone tries to give away <object>
  but fails because they didn't pass the object's give lock.
 
  Function references and %-substitutions are allowed in give failure
  messages, and are evaluated when someone tries to give away the
  object. In function references, 'me' refers to the object being
  given away, while %-substitutions that refer to the enactor (such
  as %n, %#, %p, etc) refer to the (attempted) giver.
 
  Example:
  @ogfail blob = tries to give away a sticky blob of goo.
 
  See also: give, @agfail, @gfail, @lock
  
& OPAQUE
 
  Flag: OPAQUE (O)
 
  When set on a player, it prevents other players from seeing what you
  are carrying in your inventory.  The only exception is when the
  object you are carrying belongs to the player looking at you.
  
& or()
 
  Syntax: or(<boolean1>,<boolean2>[,<booleanN>]...)
 
  Takes two or more booleans, and returns 1 if at least one is
  equivalent to true(1).
 
  See Also: BOOLEAN VALUES, and(), not(), xor()
  
& orflags()
 
  Syntax: orflags(<object>,<list of flags>)
 
  This function returns 1 if <object> has at least one of the flags in
  a specified list, and 0 if it does not. The list is specified with a
  single letter standing for each flag, like the output of the
  flags() function. A '!' preceding a flag letter means "not flag".
 
  Thus, orflags(me,Wr) would return 1 if I am set WIZARD or ROYALTY.
  orflags(me,D!c) would return 1 if I am DARK or not CONNECTED.
 
  If a letter does not correspond to any flag, <object> doesn't have
  it, so it is simply ignored. There can be an arbitrary number of
  flags.
 
  Warning: Do not put spaces between flag letters.
 
  See Also: flags(), andflags(), hasflag()
  
& osuccess
 
  Syntax: @osuccess <object> = <message>]
  Attribute: Osucc
 
  Sets the message (prefixed by the player's name) that is shown to
  others in the room when someone picks up the named player or
  thing, goes through the named exit, or looks at the room and
  passes the room's lock.
 
  Setting Osuccess messages on all takeable objects and usable exits
  is considered good building practice.
 
  Examples:
  <object>
  @osucc vase = carefully picks up the vase.
 
  <exit>
  @osucc doorway = opens the door and leaves the room. The door closes
  behind %o with a click.
 
  See also: get, look, @asuccess, @success, SUCCESS
  
& OUTPUTPREFIX
 
  Syntax: OUTPUTPREFIX <string>
 
  Causes <string> to be output on a line by itself before printing the
  results of each command.  This command is intended for use by
  external robot programs, and may be restricted to players whose
  ROBOT flag is set.
 
  The OUTPUTPREFIX command must be entered in all capitals.
 
  See also: @robot, OUTPUTSUFFIX, ROBOT
  
& OUTPUTSUFFIX
 
  Syntax: OUTPUTSUFFIX <string>
 
  Causes <string> to be output on a line by itself after printing the
  results of each command.  This command is intended for use by
  external robot programs, and may be restricted to players whose
  ROBOT flag is set.
 
  The OUTPUTSUFFIX command must be entered in all capitals.
 
  See also: @robot, OUTPUTPREFIX, ROBOT
  
& owner()
 
  Syntax: owner(<object>)
  Syntax: owner(<object>/<attrib>)
 
  The first form of the Template:Function function returns the dbref
  of the owner of the object. The object must either be yours or
  nearby.
 
  The second form returns the owner of an attribute on the named
  object. You must own either the object or the attribute.
  
& page
 
  Syntax: page <player-list> [=[<control>]<message>]
 
  This command sends <message> to <player-list>.  If you do not
  specify a name, it defaults to the players you last paged.  You
  may use either the player's name or alias, a list of names and/or
  aliases, and you may also give a string that uniquely matches the
  start of a player's name on the WHO list.
 
  You can format the message one of several ways by specifying ':',
  ';', or '"' as the first character of the message.  ':' and ';'
  format the message as 'From afar, <player> <message>', with ';'
  omitting the space between <player> and <message>.  '"' formats
  the message in normal page format (this is the default).
 
  If your Idle attribute is set to something, then it is sent to
  anyone who successfully pages you.  This is useful for when you
  are away from your terminal for a short while.
 
  { 'help page2' for more}
  
& page2
 
  You can selectively disable pages from certain players with the
  '@lock/page' command (players must pass the lock in order to page
  you).  If someone cannot page you, they will be sent a message
  including of your Reject attribute if they try.  If someone pages
  you while you are not connected, they are sent a message including
  your Away attribute.
 
  You can also page many players at one time, where all the players
you page
  will see the message.
 
  Example:
  > p darkenelf lauren = Hi
  You paged (Darkenelf Lauren) with 'Hi'.
 
  To (Darkenelf Lauren), Dreamline pages: Hi
 
  You only need to type the player-list once, then the next time you
  page that player or set of players, you can abbreviate it with:
  "p :waves."  or, "p I'm back."
 
  This will work until you page another player or list of players.
 
  See also: pose, say, whisper, :, ;, ", @pemit, @away, @idle,
  @reject.
  
& pain_resistance
 
 >> Help: Pain Resistance (Advantages)
 -----------------------------------------------------------------------------
 +1 BTH to Conscious Roll
 Receive only 1 damage from ammo explosions
 
 Result: You take less damage from ammo explosions, but you are more likely to
 go unconscious.
 
& pairs()

  Syntax: pairs(obj/attr)

  This function returns a string which lists the number of 'brackets'
  in the specified attribute on the object.

  The string returned contains the number of { [ ( ) ] } in that
  order.

  Error Messages:
  * If the attribute does not exist on the object the function
  returns an empty string

  Example:
  Given that #1234 is an object with the attribute COMMA.F on it:
> ex #1234/COMMA.F
COMMA.F:
[ifelse(lt(strlen(round(%0,0)),4),round(%0,0),ifelse(lt(strlen(round(%
0,0)),7),
[strtrunc(round(%0,0),[sub(strlen(round(%0,0)),3)])]%,[reverse(strtrun
c(reverse(
round(%0,0)),3))],[strtrunc(round(%0,0),[sub(strlen(round(%0,0)),6)])]
%,[reverse
(mid(reverse(round(%0,0)),3,3))]%,[reverse(strtrunc(reverse(round(%0,0
)),3))]))]
> think pairs(#1234/comma.f)
0 8 31 31 8 0
 
& parent()
 
  Syntax: parent(<obj>)
 
  Returns the parent of <obj>. Returns #-1 if <obj> cannot be found or
  if you do not own <obj> and it is not set VISUAL.
 
  Example:
 
  > say parent(me)
  You say "#-1"
  > say My va is [v(va)].
  You say "My va is "
  > @parent me=test
  Parent set.
  > say parent(me)
  You say "#323"
  > say My va is [v(va)].
  You say "My va is Testing 123"
 
  See Also: children(), @parent, PARENT OBJECTS
  
& PARENT2
 
  Topic: PARENT OBJECTS (continued)
 
  A parent object may itself have a parent, up to a configurable limit
  (usually 10 levels).  The parent need not be the same type as its
  children, and flags and locks are not inherited from parent 
  objects.  You may not create parent loops.
 
  See also: @parent, parent()
  
& PARENT OBJECTS
 
  Topic: PARENT OBJECTS
 
  Parent objects provide a way for several objects to inherit common
  attributes, exits, and $-commands from a single object, so that
  changing the parent object affects all of its children.  When 
  searching for attributes or exits, first the object itself is 
  checked, then the parent is checked only if the object does not 
  have what was searched for.
 
  Any attribute the parent object has will be passed down to its
  children, if they don't already have one. For instance, if the 
  child object has no description, it will inherit the description 
  of its parent.
 
  Any exits the parent object has will show up in the exit list of the
  child, and may be used as normal exits.
 
  The parent is searched for $-commands as well as the child, and only
  attributes that are unique to the parent are checked, so that
  conflicting attribute names are skipped.  If both have an 
  attribute named "cmd1", only the child's "cmd1" attributes is 
  checked for a $-command.
 
{ 'help parent2' for more }
  
& PARENT_OK
 
  Flag: PARENT_OK (Y)
 
  If an object is set PARENT_OK, then any other object that passes the
  object's ParentLock may make this object a parent of any object that
  it controls. Caution: allowing others to use your objects as 
  parents lets them read the attributes on the object (as well as 
  any parents of the object).
 
  See also: @lock/parent
  
& parent rooms
 
  Parent rooms are a subset of zones. If a room is used as as zone
  object, it is a parent room (PR). PRs are like local "master" 
  rooms. Exits in the PR are global to that zone, and $commands on 
  objects in the PR are global to that zone. Parent rooms are only 
  defined if globals are used.
  
  Parent rooms should only be used for very large zones which have a
  lot of global exits. Otherwise, a ZMO thing should be used, 
  because command evaluation on a parent room is slower than command 
  evaluation on a ZMO.
  
  Large numbers of parent rooms may slow down the game significantly.
 
  See ZONE OBJECTS and COMMAND EVALUATION for more information.
  
& parse()
 
  Syntax: parse(<list>,<eval>[,<delimiter>])
 
  This function takes each element of <list>, evaluates <eval> after
  substituting it for ##, and constructs a space-separated list of the
  results.
 
  Example:
 
  > say parse(1 2 3 4 5,add(##,1))
  You say "2 3 4 5 6"
  > say parse(This|is|a|string|length|test,strlen(##),|)
  You say "4 2 1 6 6 4"
 
  See Also: @dolist, iter(), map()
  
& peek()
 
  Syntax: peek([<object>], [<position>])
 
  This function returns an item from the caller's stack without
  removing it from the stack. If <position> is specified, it returns
  the item from that position in the stack (items in the stack are
  numbered with 0 being the most recently push()ed item), otherwise,
  it returns position 0.
 
  If <object> is specified and you control it, then it returns an item
  from <object>'s stack.
 
  See Also: lstack(), empty(), items(), pop(), push(), OBJECT STACK
  
& @pemit
 
  Syntax: @pemit[/switches] <what>=<message>
 
  Emits <message> only to <what>, or to <what>'s contents of the
  /contents switch is given.  <what> must be either in the same
  location as you or be something you own.  You can also @pemit to
  distant players if pagelocks allow you to page them, and this
  costs as much as a page <This feature is not present in all
  MUXes>.  You cannot @pemit to the contents of something you don't
  own.
 
  The following switches are available:
    /contents - Send the message to the contents of the named object.
    /object   - Send the message to the named object.
    /list     - Send the message to a list of objects.
 
  You may specify any combination of these switches.
 
  See also: page, @remit, @emit, @oemit, SPOOFING
  
& pemit()
 
  Syntax: pemit(<list of objects>, <message>)
 
  A side effect function, with the same effect as @pemit/list <list of
  objects> = <message>.
 
  See Also: @pemit
  
& perception
 
 >> Help: Perception (Skills-Combat, Misc.)
 -----------------------------------------------------------------------------
 Used for noticing units that appear within your line of sight (LOS)
 
 
& pereccm
 
  RS Command: pereccm
  
  The command puts your personal ECM suite into ECCM mode, which 
  enables it to counteract enemy ECM.
  
  This command is only available to units equipped with 
  InfiltatrorII_Stealth_Tech
  
& perecm

  RS Command:
  
  This command puts your personal ECM suite into ECM mode

  ECM interferes with the communications and certain sensors of enemy 
  units within ranage of your 'ECM Umbrella'.

  This command is only available to units equipped with 
  InfiltatrorII_Stealth_Tech
  
& pi()
 
  Syntax: pi()
 
  Returns the value of the trigonometric constant pi to nine decimal
  places.
 
  Example:
 
  > say pi()
  You say "3.141562654"
 
  See Also: acos(), asin(), atan(), cos(), sin(), tan()
  
& pickup
 
  RS Command: pickup <UnitID>
  
  This command permits a mech with hands to start towing the specified 
  unit.
  
  See Also: dropoff, attachcables, detachcables
  
& piloting-aerospace
 
 >> Help: Piloting-Aerospace (Skills-Combat, Piloting)
 -----------------------------------------------------------------------------
 Used for piloting rolls while in a VTOL
 
 
& piloting-biped
 
 >> Help: Piloting-Biped (Skills-Combat, Piloting)
 -----------------------------------------------------------------------------
 Used for piloting rolls while in a biped mech
 
 
& piloting-quad
 
 >> Help: Piloting-Quad (Skills-Combat, Piloting)
 -----------------------------------------------------------------------------
 Used for piloting rolls while in a quad mech
 
 
& piloting-spacecraft
 
 >> Help: Piloting-Spacecraft (Skills-Combat, Piloting)
 -----------------------------------------------------------------------------
 Used for piloting rolls while in a spacecraft
 
 
& piloting-tracked
 
 >> Help: Piloting-Tracked (Skills-Combat, Piloting)
 -----------------------------------------------------------------------------
 Used for piloting rolls while in tracked units (example: tanks)
 
 
& piloting-wheeled
 
 >> Help: Piloting-Wheeled (Skills-Combat, Piloting)
 -----------------------------------------------------------------------------
 Used for piloting rolls while in wheeled units (example: fuel trucks)
 
& PIPING
  
  Command piping in MUX is similar to piping in a UNIX shell. You string two
  or more commands together using the ;| symbol, much as you would using a
  semicolon. The output from the previous command in a pipe is accessable
  using the %| substitution. This output contains the raw ASCII codes that
  would normally be directly output to your terminal. You may use the
  translate() function to either convert the raw characters in the output to
  MUX substitutions, or strip them out altogether. Like the semicolon, the ;|
  symbol in MUX is taken literally if you type it on the terminal. Currently
  you may only pipe 20 commands in a row.
 
  Examples:
  > &MAILDESC me=$+maildesc *=*:look %0 ;| @mail/quick
                  %1/Description=[translate(%|,1)]

  > &SAYDESC me=$+saydesc *:look %0 ;| say %r%|
  > +saydesc me
  You say "
  Lauren(#5PXMWc)
  You see nothing special.
  "
 
  See also: translate() 
& playmem()
 
  Syntax: playmem(<player>)
 
  Returns the size in bytes of <player>. Note that this is the total
  number of bytes that player uses, including all objects that they
  own.
 
  You must be a WIZARD, or have the search power to use this function
  on another player.
  
& pmatch()
 
  Syntax: pmatch(<string>)
 
  Given the partial name of a player, it returns that player's dbref
  number. This partial name completion works identically to the
  partial name completion of the page command - i.e. it first
  attempts to match the normal names of all players (connected or
  not), and if that fails, it tries to match the partial names of
  connected players. If no player is matched, it returns "#-1". If
  more than one match is possible for a partial name, it returns "#-
  2".
 
  The function will also accept *<player> or #<db#>. If given a non-
  player dbref #, pmatch() will return #-1.
 
  See Also: num(), locate()
  
& pods
 
  RS Command: pods
  
  This command lists the location and type of NARC and iNARC pods 
  attached to your RS Unit.
  
  Example:
=========================Attached NARC and iNARC Pods========================
-- Location ---||- NARC -||- iHoming -||- iHaywire -||- iECM -||- iNemesis --
 Left Arm      ||........||...........||............||........||.............
 Right Arm     ||........||...........||............||........||.............
 Left Torso    ||........||...........||............||........||.............
 Right Torso   ||........||...........||............||........||.............
 Center Torso  ||........||...........||............||........||.............
 Left Leg      ||........||.....X.....||............||........||.............
 Right Leg     ||........||...........||............||........||.............
 Head          ||........||...........||............||........||.............
  
& poll()
 
  Syntax: poll()
 
  This function returns the string which is set as the @doing header.
 
  Example:
  >WHO
  Player Name        On For Idle  Under Construction
  Fred             1d 22:55   0s  Stuff
  Nurks            1d 23:44   0s  Other Stuff
  2 Players logged in, 85 record, no maximum.
  >say poll()
  You say "Under Construction"
  
& pop()
 
  Syntax: pop([<object>], [<position>])
 
  This function returns an item from the caller's stack and removes it
  from the stack. If <position> is specified, it returns the item from
  that position in the stack (items in the stack are numbered with 0
  being the most recently push()ed item) and removes it, otherwise, it
  returns position 0. If <object> is specified and you control it,
  then it returns an item from <object>'s stack.
 
  See Also: lstack(), empty(), items(), peek(), push(), OBJECT STACK
  
& ports()
 
  Syntax: ports(<player name>)
 
  This function returns the list of descriptors ("ports") that a
  player, specified by full player name, or by dbref, is connected to.
  Only Wizards may use this function; if a user lacks the privileges,
  or the player is not connected, an empty list is returned.
  Otherwise, a list of ports is returned in order of most recent
  connection to least recent connection. These ports correspond to
  those given by the session command.
  
& pos()
 
  Syntax: pos(<string1>,<string2>)
 
  This function returns the position that <string1> begins in
  <string2>, with the first position being 1. If <string1> is not in
  <string2>, then it returns -1.
 
  Example:
 
  > say pos(man,superman)
  You say "6"
 
  See Also: match(), member()
  
& pose
 
  Syntax: pose[/<switches>] <message>
 
  Displays <message> to everyone in your current room, preceded by
  your name and optionally a space.  Example: the command 'pose
  jumps for joy' produces '<yourname> jumps for joy'.
 
  The following switches are available:
     /default - (default) Put a space between your name and the
                message (ie, display '<name> <message>').
     /nospace - Don't put a space between your name and the message
                (ie, display '<name><message>').
 
  See also: page, say, whisper, :, ;,"
  
& poss()
 
  Syntax: poss(<object>)
 
  Returns the proper possessive pronoun (his, her, its, their) for
  referring to <object>, based on the object's Sex attribute. You must
  either control or be near <object>.
 
  See Also: obj()
  
& #
 
  Syntax: #<number> <command>
 
  Forces the object whose database number is <number> to perform
  <command>.
 
  Example:
  #1033 move north
 
  forces object #1033 to go north (assuming that you control it).
  The same restrictions that apply to @force also apply to this
  command.
 
  See also: @force
  
& power()
 
  Syntax: power(<number>, <power>)
 
  Returns the result of raising <number> to the <power>th power.
<number> may
  not be negative. <number> and <power> may be floating point numbers,
and a
  floating point result is returned.
 
  Example:
 
  > say power(2,3)
  You say "8"
  > say power(9, 0.5)
  You say "3"
  > say power(100,pi())
  You say "1919487.587204"
  > say power(5, 0)
  You say "1"
  > say power(0, 0)
  You say "1"
  > say power(2,-3)
  You say "0.125"
  > say power(-2,3)
  You say "#-1 POWER OF NEGATIVE"
 
  See Also: exp(), ln(), log(), sqrt()
  
& powers list
 
  TOPIC: Powers List
 
  announce		Can use the @wall command.
  boot			Can use the @boot command.
  builder		Can build, if the builder power is enabled.
  chown_anything	Can @chown anything to anyone.
  comm_all		Like a wizard with respect to channels.
  control_all		Can modify any object in the database.
  expanded_who		Sees the wizard WHO, and SESSION commands.
  find_unfindable	Can locate unfindable people.
  free_money		Unlimited money.
  free_quota		Unlimited quota.
  guest			Is this a guest character?
  halt			Can @halt anything, and @halt/all.
  hide			Can set themselves DARK.
  idle			No idle timeout.
  long_fingers		Can get, look, whisper, etc from a distance.
 
{ 'help powers list2' for more }
 

& powers list2
 
  monitor		Can set or reset monitor flag.
  poll			Can set the @poll.
  prog			Can use @program on players other than themself.
  search		Can @search anyone.
  see_all		Can examine and see attributes like a wizard.
  see_queue		Can @ps/all or @ps any player.
  stat_any		Can @stat any player.
  steal_money		Can give negative money.
  tel_anywhere		Can teleport anywhere.
  tel_anything		Can teleport anything (includes tel_anywhere)
  unkillable		Cannot be killed with the 'kill' command.
 
  See also: @power
  
& precision
 
  RS Command: precision <weapnum>
  
  This command toggles the state of <weapnum>, causing it to fire 
  Precision ammunition or normal ammunition.
  
  Precision ammo is available for AutoCannons only.
  
& prone
 
  RS Command: prone
  
  This command causes your mech to drop to the ground.
  
  Note - if the unit is moving there is a risk of damage to the Mech.
  
& PUEBLO
 
  Details on Pueblo support in TinyMUX:
 
  @VRML_URL is the URL of a VRML scene for a particular room.
  @HTDesc is an alternate description for players who are logged in
  using Pueblo.
  @pemit/html and @emit/html allow outputting unescaped HTML strings.
  Please see http://www.chaco.com/pueblo/doc/enhancing.html for more
  details.
  
& punch
 
  RS Command: punch [R|L} [ID]
  
  This command causes your 'Mech to punch another RS Unit.
  
  As with all physical attacks you must be within the same hex as the 
  unit you are attacking.
  
  Arguments:
  none - if a target is locked, attempt to punch that target
  * R - attempt to punch with the Right leg
  * L - attempt to punch with the Left leg
  * ID - specify a unit to punch
  
  See Also: axe, charge, chop, club, grabclub, kick, mace, saw, trip
  
& PUPPET
 
  Flag: PUPPET (p)
 
  Causes an object to grow eyes and ears, and relay
  all it sees and hears to its owner.
 
  See also: @force, PUPPETS
  
& push()
 
  Syntax: push(<data>)
  Syntax: push(<object>, <data>)
 
  This function places <data> onto the calling object's stack. If the
second
  form is used, it places data onto <object>'s stack.
 
  See Also: lstack(), empty(), items(), peek(), pop(), OBJECT STACK
  
& QUIET
 
  Flag: QUIET (Q)
 
  This flag, when set on yourself, prevents you from hearing
  the 'set' or 'triggered' messages from any objects you own.  When
  set on an object, only that object will not relay its messages.
 
  See also: @set, @trigger
  
& QUIT
 
  Syntax: QUIT
 
  Logs you out and disconnects you from the game. Must be in all
  capitals.
 
  See also: LOGOUT
  
& "
 
  Syntax: "<message>
 
  Says <message> out loud to everyone in your current room.  Example:
  the command '"Where is the movie theater?' produces
  '<yourname> says "Where is the movie theater>"'.  Note that the
  closing double quote is automatically added.
 
  See also: page, pose, say, :,"
  
& r()
 
  Syntax: r(<number>)
 
  This function is used to access "local registers", and returns the
  contents of the specified register. There are ten such registers,
  numbered 0 through 9.
 
  The local registers are normally cleared at the start of each
  command, but are preserved across the commands that compose an
  actionlist, as well as commands that directly trigger actionlists,
  such as @switch, @trigger, and @dolist.
 
  See Also: setq(), setr()
  
& rac
 
  RS Command: rac <weapnum> <-/2/4/6>
  
  This command sets the specified Rotary AutoCannon to fire the 
  specified number of shots each time it fires.
  
  Example:
  
  >rac 0 6
  Weapon 0 set to fire six shots at a time.
  
  >rac 0 -
  Weapon 0 set to fire one shot at a time.
  
& radio
 
  RS Command: radio <id>=<message>
 
  This command sends <message> to <id>.
 
  Note - <id> must be within Line Of Sight of your unit.
 
& radio colors

  setchannelmode <channel>=<modes><color code>

  You can set the color of transmissions for a channel by using one of
  the following arguments:
  
  b - blue              B - bright blue
  c - cyan              C - bright cyan
  g - green             G - bright green
  m - magenta           M - bright magenta
  r - red               R - bright red
  w - white             W - bright white
  x - black             X - bright black
  y - yellow            Y - bright yellow
  
& rand()
 
  Syntax: rand(<num>)
 
  Rand returns an integer between 0 and num-1.
 
  Example:
 
  > say rand(10)
  You say "6"
  > say rand(10)
  You say "1"
  > say rand(10)
  You say "4"
  > say rand(10)
  You say "9"
  > say rand(10)
  You say "1"
  
 & range
 
  RS Command: range [x y] [x y]

  This command returns the range to the hex specified.

  If only one hex is specified the range returned is from your
  current location.

  If two hexes are specified the command returns the range from the
  first hex to the second hex.
 
& ranklist
  
 >> Help: Ranklist (Factional Command)
 -----------------------------------------------------------------------------
 Syntax: Ranklist
 
 The 'Ranklist' command displays all of your faction's ranks and their
 names, along with how much XP is needed to reach each of these ranks.
 
 
& ranklist
 
 >> Help: Ranklist (Informational Command)
 -----------------------------------------------------------------------------
 Syntax: Ranklist
 
 The 'Ranklist' command simply displays a list of the various ranks your
 character can achieve. It also shows how much experience is needed to reach
 each rank level, in addition to how much you need for the next rank.
 
 
& rapidfire
 
  RS Command: rapidfire <weapnum>
  
  This command toggles the specified weapon between rapidfire mode 
  and normal mode.
  
  Only Standard and Light Autocannons can use rapidfire mode. 
  
& read
 
  Syntax: read [<object>]
 
  Displays the description of <object>, or the room you're in if you
  don't specify an object.  Specifying object as <name> or #<dbref>
  or 'me' or 'here' is legal.  You can also use look to look at
  objects held by other people, just use 'read <person>'s <object>'.
 
  You may use the /outside switch to look at the location of your
  current location (useful if you are inside a vehicle or other
  object).  You may also look at other objects in the 'outer'
  location, but you may not use the possessive form with the
  /outside switch (ie: "read/outside <person>'s <object>" won't
  work).
 
  NOTE: 'look' is the same as 'read'.
  
& reattach
 
  RS Command: reattach <loc>
  
  This command attaches a new limb to replace a head, leg or arm which 
  has  been destroyed. 
  
  A reattachment replaces the limb but does not install components, 
  weapons or armor on the limb. These repairs must be carried out once 
  the limb reattachment is complete.
  
& regmatch()
 
  Syntax: regmatch(<string>,<regexp>[,<register list>])
 
  This function matches the regular expression <regexp> against the
  entirety of <string>, returning 1 if it matches and 0 if it does
  not.
 
  If <register list> is specified, there is a side-effect: any
  parenthesized substrings within the regular expression will be set
  into the specified local registers, in the order they were specified
  in the list. <register list> can be a list of one through nine
  numbers. If the specified register is -1, the substring is not
  copied into a register.
 
  For example:
  if <string> is 'cookies=30', and <regexp> is '(.+)=([0-9]*)'
  (parsed; note that escaping may be necessary), then the 0th
  substring matched is 'cookies=30', the 1st substring is 'cookies',
  and the 2nd substring is '30'. If <register list> is '0 3 5', then
  %q0 will become "cookies=30", %q3 will become "cookies", and %q5
  will become "30". If <register list> was '0 -1 5', then the
  "cookies" substring would simply be discarded.
 
  See Also: REGEXPS 
  
& relay mode
 
  setchannelmode: Relay mode
  Flag: E, or e
  
  This mode causes your radio to retransmit messages from units 
  which are out of range of other units. Relay mode can only operate 
  in Digital mode.
  
  You will see nothing to indicate if you are relaying or not.
  
& reload
 
  RS Command: reload <loc> <pos>[<type>]
  
  This command loads ammunition into the specified ammo bin.
  
  The ammo <type> can be specified also, if a non-standard type is 
  required.
  
  Continued in reload2
  
  See Also: unload, ammo types 
& reload2
 
  Example:
  Given a Pinto VTOL with no LRM ammo left
  
  >critstatus fs 
  
  
  --------------------------------------------------------------------
                     Front Side Criticals                             
  --------------------------------------------------------------------
  1 MediumLaser                          7 BeagleProbe                
  2 MediumLaser                          8 Empty                      
  3 MediumLaser                          9 Empty                      
  4 LRM-5                               10 Empty                      
  5 ArtemisIV                           11 Empty                      
  6 LRM-5 Artemis IV Ammo (0)           12 Empty                      
-  -------------------------------------------------------------------
  
  >reload fs 6
  
  You start reloading the ammo compartment..
  BTH: 5 Roll: 3
  You fumble around, wasting the ammo in the progress.
  You have 15 minutes of repairs pending and you're ready to do at 
  least 585 more minutes of work.
  
& remove()
 
  Syntax: remove(<list>, <word>[, <delim>])
 
  Remove takes a list and a word, and returns the list, with the word
  deleted from it. <delim> may be used to specify a delimiter other
  than a space.
 
  Example:
 
  > say remove(this is a test, is)
  You say "this a test"
  > say remove(You can't remove, this)
  You say "You can't remove"
  > say remove(You can't remove multiple words, You can't)
  You say "#-1 CAN ONLY DELETE ONE ELEMENT"
  > say remove(How about an o-separated list, w ab, o)
  You say "Hout an o-separated list"
 
  See Also: delete(), ldelete()
  
& removegun
 
  RS Command: removegun <num>
  
  This command removes a weapon from an RS Unit.
  
  The <num> specified refers to the number of the weapon in the status 
  command.
  
  Continued in removegun2
  
removegun2
 
  Example:
  
  >status w
  Vehicle Name:                  ID:[FV]   Vehicle Reference: Pinto
  Tonnage:    30      FlankSpeed: 161       Movement Type: VTOL
  Pilot: NONE
  SHUTDOWN
  AdvSensors: BeagleProbe
  
==================WEAPON SYSTEMS===========================AMMUNITION========
------ Weapon --------- [##] Location ---- Status ||--- Ammo Type ---- Rounds
 MediumLaser            [ 0] Front Side    Ready  || LRM-5            A   24
 MediumLaser            [ 1] Front Side    Ready  ||    
 MediumLaser            [ 2] Front Side    Ready  ||    
 LRM-5                  [ 3] Front Side    Ready  ||    
  
  >removegun 0
  BTH: 5 Roll: 7
  You start removing the gun..
  You have 40 minutes of repairs pending and you're ready to do at 
  least 560 more minutes of work.
   
& removepart
 
  RS Command: removepart <loc> <pos>
  
  This command removes the component which is at <loc> <pos>
  
  The critstatus command is use to identify <loc> and <Pos>
  
  Continued in removepart2
  
& removepart2
 
  Example:
  Given an EXT-4D in for scrapping
  
  >critstatus lt
  -------------------------------------------------------------------
                          Left Torso Criticals                       
  -------------------------------------------------------------------
   1 Engine                               7 LRM-10                   
   2 Engine                               8 LRM-10                   
   3 Engine                               9 Empty                    
   4 JumpJet (Destroyed)                 10 Empty                    
   5 JumpJet                             11 Empty                    
   6 JumpJet                             12 Empty                    
  -------------------------------------------------------------------
  
  >removepart lt 5
  You start removing the part..
  Tech - BTH: 4(Base:4, Mod:0) Roll: 9
  You have 40 minutes of repairs pending and you're ready to do at 
  least 560 more minutes of work.
  
& removepod
 
  RS Command: removepod <loc> <type>
  
  This command attempts to removes am iNARC pod from an RS 
  Unit.
  
  Arguments:
  * <loc> - specifies the location of the pod to attempt to remove.
  * <type> - specifies the type of the pod. 
  
    Pod Types:
    * E - ECM pod
    * H - Homing pod
    * Y - Haywire pod
  
  Example:
  Given a homing pod attached to your left leg:
  
  >removepod ll h
  You try to swat at the iNarc pods attached to your Left Leg with 
  your Left Arm.  
  BTH:  8,      Roll:  8
  You knock a Homing pod off your Left Leg!
  
& removesection
 
  RS Command: removesection <loc>
  
  This command removes a section (eg LT, RL) from an RS Unit which is 
  being scrapped.
  
  NOTE - this command will remove a section even if there are parts 
  still on it which can be salvaged. In that case, those parts will be 
  lost.
  
& repairgun
 
  RS Command: repairgun [<num> | <loc> <pos>}]
  
  This command a repairs damaged weapon in <loc> <pos> or displayed as 
  <num> in the damages command.
  
  Use critstatus to determine the <pos> for the weapon.
  
  Example:
  Given a Pinto which has a damaged medium laser
      You can use either:
      repairgun 0
      OR
      repairgun fs 1
  
& repairpart
 
  RS Command: repairpart <loc> <pos>
  
  This command a repairs damaged part in <loc> <pos>.
  
  Use critstatus to determine the <pos> for the part.
  
& repairs
 
  RS Command: repairs
  
  This command displays the repairs which are currently being 
  carried out on an RS Unit.
  
  
& repeat()
 
  Syntax: repeat(<string>,<number>)
 
  This function simply repeats <string>, <number> times. No spaces are
  inserted between each repetition.
 
  Example:
 
  > say repeat(Test, 5)
  You say, "TestTestTestTestTest"
  
& replace()
 
  Syntax: replace(<list>, <pos>, <word>[, <sep>])
 
  This function inserts a word into <list> so that the word becomes
  the <pos>'th element of the list, and the word previously in that
  position is removed. This means that it appears between the
  <pos-1>'th and <pos+1>'th elements of the original list, replacing
  the word at that position. This function may not be used to append
  a word to a list.
 
  <delim> may be used to specify a delimiter other than a space.
 
  Example:
 
  > say replace(This is a test, 4, quiz)
  You say "This is a quiz"
  > say replace(Yet@Another@Mundane@List, 3, Funky, @)
  You say "Yet@Another@Funky@List"
 
  See Also: extract(), insert(), ldelete()
  
& replacegun
 
  RS Command: replacegun [<num> | <loc> <pos>}] [<name>]
  
  This command installs a new weapon in <loc> <pos> or displayed 
  as <num> in the damages command.
  
  THe agument allows you to install a specific brand of that weapon, 
  if brands are enabled on the MUX.
  
  Use critstatus to determine the <pos> for the weapon.
  
  Continued in replacegun2 
& replacegun2
 
  Example:
  Given a Pinto which has a destroyed medium laser
  
  status w
Vehicle Name:                  ID:[FV]   Vehicle Reference: Pinto
Tonnage:    30      FlankSpeed: 161       Movement Type: VTOL
Pilot: NONE
SHUTDOWN
AdvSensors: BeagleProbe
==================WEAPON SYSTEMS===========================AMMUNITION========
------ Weapon --------- [##] Location ---- Status ||--- Ammo Type ---- Rounds
 MediumLaser            [ 0] Front Side    *****  || LRM-5            A   24
 MediumLaser            [ 1] Front Side    Ready  ||    
 MediumLaser            [ 2] Front Side    Ready  ||    
 LRM-5                  [ 3] Front Side    Ready  ||    
 
      You can use either:
      replacegun 0
      OR
      replacegun fs 1
      to install the new weapon.
  
& replacepart
 
  RS Command: replacepart <loc> <pos>
  
  This command installs a new part in <loc> <pos> 
  
  Use critstatus to determine the <pos> for the part.
  
& replacesuit
 
  RS Command: replacesuit <suitnum>
  
  This command replaces a destroyed battlesuit.
  
  Arguments:
  * suitnum - this uses the same argument as critstatus does for 
              battlesuits:  eg S1, S2, etc
  
& report
 
  RS Command: report [<UnitID>|<x> <y>]
  
  This command provides the same information provided by the 
  'scan <object> i' command.
  
  The report command can operate over greater distances than the scan 
  command, however there is a corresponding decrease in accuracy of 
  the information provided for objects which are more distant.
  
  See Also: scan
  
& reseal
 
  RS Command: reseal <loc>
  
  This command repairs flooded sections of an RS Unit.
  
  Note - the command does not repair other damage in the section, only 
  the flooding itself.
  
& rest()
 
  Syntax: rest(<string>[, <delim>])
 
  This function takes a string, returns all the string except the
  first word, that is, everything to the right of the first space, or
  an empty string, or the empty string if there are no spaces in the
  string. <delim> may be used to specify a word delimiter other than a
  space.
 
  Example:
 
  > say rest(This is a test)
  You say "is a test"
  > say rest(Would you like coffee, or perhaps tea)
  You say "you like coffee, or perhaps tea"
  > say rest(List!with!different!delimiters,!)
  You say "with!different!delimiters"
 
  See Also: first(), last()
  
& reverse()
 
  Syntax: reverse(<string>)
 
  Reverses the order of the characters of <string>.
 
  Example:
 
  > say reverse(This is a test)
  You say "tset a si sihT"
  > say reverse(This is a test, Really...)
  You say "...yllaeR ,tset a si sihT"
  > say reverse(A man, a plan, a canal -- Panama!)
  You say "!amanaP -- lanac a ,nalp a ,nam A"
 
  See Also: revwords()
  
& revwords()
 
  Syntax: revwords(<string>[, <delim>])
 
  Reverses the order of the words of <string>. A word is considered to
  be any sequence of nonblank characters, separated by blanks, so
  punctuation characters that follow a word are considered part of
  the word. <delim> may be used to specify a delimiter other than a
  space.
 
  Example:
 
  > say revwords(This is a test, Really...)
  You say "Really... test, a is This"
  > say revwords(Was it a cat I saw?)
  You say "saw? I cat a it Was"
 
  See Also: reverse()
  
& rjust()
 
  Syntax: rjust(<string>, <length>[, <fill>])
 
  This function pads a string with leading <fill> characters, or with
  spaces if no fill character is given) ("right-justifies") so it is
  <length> long. If <string> is longer than <length>, the <string> is
  returned; it is not truncated.
 
  Example:
 
  > say -[rjust(foo,6)]-
  You say "-   foo-"
  > say %r0[rjust(foo,6)]7%r01234567
  You say "
  0   foo7
  01234567"
  > say =[rjust(bar,5,.)]=
  You say "=..bar="
 
  See Also: ljust()
  
& rloc()
 
  Syntax: rloc(<object>,<levels>)
 
  This function may be used to get the location of an object's
  location (for which you would previously use 'loc(loc(<object>))',
  which fails if you don't control <object>'s location).
 
  <levels> indicates the number of nested 'loc' calls to make, so
  'loc(loc(<object>))' could be replaced with 'rloc(<object>,2)'. If
  rloc() encounters a room, the dbref of the room is returned.
 
  You must either control the object or be nearby for it to work. When
  used on an exit it returns the destination of the exit. You can also
  use rloc() to find the location of players that are not set
  UNFINDABLE.
 
  rloc(<object>,0) is the same as num(<object>), and rloc(<object>,1)
  is the same as loc(<object>).
 
  See Also: loc(), where()
  
& ROBOT
 
  Flag: ROBOT (r)
 
  If set on a player, indicates that the player is a robot and is
  allowed to use the OUTPUTPREFIX and OUTPUTSUFFIX commands that 
  many publicly available robot programs require.  Some MUXes do not 
  restrict access to the OUTPUTPREFIX and OUTPUTSUFFIX commands.
 
  If set on an exit or a thing, indicates that robot players may not
  use the exit or pick up the thing, the player is treated as having 
  failed the lock.
 
  See also: OUTPUTPREFIX, OUTPUTSUFFIX, @robot.
  
& room()
 
  Syntax: room(obj)
 
  Returns the number of the room that <obj> is in, or would be in if
  it executed leave commands until it got to a room. You can find out
  the containing room of objects you own, nearby objects, and
  findable players.
 
  Example:
 
  > i
  You are carrying:
  hat(#368)
  cat(#325)
  > look
  Mortal's Room(#367R)
  A bare room with nothing in it but a bed and a chair.
  > say I am in [room(me)], the cat is in room [room(cat)].
  You say "I am in #367, the cat is in room #367."
  > @fo hat=get cat
  cat has left.
  > say The cat is in [loc(#325)] within room [room(#325)].
  You say "The cat is in #368 within room #367."
 
  See Also: loc(), UNFINDABLE
  
& rottorso
 
  RS Commmand: <l|c|r>
  
  This command rotates the torso on a bidped mech in the direction 
  specified.
  
  Arguments:
  l - rotate the torso left
  c - center the torso
  r - rotate the torso right
  
& round()
 
  Syntax: round(<number>,<places>)
 
  Rounds <number> to <places> decimal places. <number> may be a
  floating point number, and an integer result is returned.
 
  Example:
 
  > say round(5,0)
  You say "5"
  > say round(5.123,1)
  You say "5.1"
  > say round(9.8765,3)
  You say "9.877"
  > say round(5.5,0)
  You say "6"
  > say round(-5.5,0)
  You say "-6"
 
  See Also: div(), floor(), mod(), trunc()
  
& ROYALTY
 
  Flag: ROYALTY
 
  If a person is ROYALTY, they can see and examine things, and
  teleport anywhere or anything, like a wizard can. They cannot modify
  objects or players they do not control, and cannot use wizard
  commands.
 
  This flag may only be set by a wizard.
 
  See also: WIZARD, STAFF, HEAD
  
& running
 
 >> Help: Running (Skills-Combat, Misc.)
 -----------------------------------------------------------------------------
 
 
 
& s()
 
  Syntax: s(string)
 
  This function performs pronoun substitution in a string, and then
  returns that string. As usually, %n is the name, %s the subjective
  pronoun, %o the objective, %p the possessive, and %a the absolute
  possessive. It is important to note that the pronoun is that of the
  triggering object.
 
  So, if the attribute ve of an object were: s(This is %n), and I were
  to type @trigger <object>/ve, it would return "This is <myname>",
  but if attribute vf were @trigger me/ve, then triggering the
  attribute vf makes the Attribute ve return "This is <object>".
 
  See Also: subj(), obj()
  
& SAFE
 
  Flag: SAFE (s)
 
  When set, requires the use of the /override switch to @destroy in
  order to destroy the object.  It does not prevent the destruction 
  of the object, but merely requires some additional effort.  If a 
  thing is set DESTROY_OK, its SAFE flag is ignored and it may be 
  destroyed without using the /override switch.
 
  See also: @destroy, DESTROY_OK
  
& safety
 
  RS Command: saftey <on|off>
  
  This command controls the ability of your unit to fire on 
  Mechwarriors on the map.
  
  Arguments:
  * on - enables firing on Mechwarriors
  * off - disable firing on Mechwarriors
  
  See Also: mechprefs 
& saw
 
  RS Command: saw [ID]
  
  This command causes your 'Mech to attack another RS Unit with a 
  saw. Naturally, this requires that your unit be equipped with a 
  saw.
  
  As with all physical attacks you must be within the same hex as the 
  unit you are attacking.
  
  Arguments:
  none - if a target is locked, attempt to attack that target
  * ID - specify a unit to attack
  
  See Also: axe, charge, chop, club, grabclub, kick, mace, punch, trip
  
& say
 
  Syntax: say <message>
 
  Says <message> out loud to everyone in your current room. You can
  also use '"<message>'.
 
  See also: page, pose, whisper, :, ;,"
  
& scan
 
  RS Command: scan [<UnitID> [a|i|w]|<x> <y>| <x> <y> <b|h>]
  
  This command scans the specified object displaying various 
  information about it.
  
  Arguments:
  none - scans the locked target
  * UnitID - scans the specified unit
   *UnitID arguments:
    none - displays the full detail for the specified unit
    * a - displays the armor for the specified unit
    * i - displays the info for the specified unit
    * w - displays the weapons for the specified unit
  * x y - scans the specified hex
   * x y arguments:
    none - scans the hex for units
    * b - scans the building in the specified hex
    * h - scans the specified hex for mines
  
& scan mode
 
  setchannelmode: Scan mode:
  Flag: S or s
  
  This mode will listen for any analog signals and attempt to 
  determine  the frequency which those transmissiosn are using. 
  Depending on a number of factors your scanner will determine the 
  frequency either 'somewhat', 'fairly well', 'precisely' or 
  'exactly'.
  
  Example:
  Given that a unit is transmitting in analog mode within radio range 
  and that you have a channel set to scan mode.
  
  You notice a unknown transmission your scanner ....
  Your systems manage to zero on it exactly on channel A.
   
& scharge
 
  RS Command:
  
  This command toggles the status (ie on or off) of your units 
  supercharger, if it is so equipped.
  
& score
 
  Syntax: score
 
  Displays how much money you have.  Helpful to see if any machines
  are looping.
 
  See also: @ps, LOOPING
  
& scramble()
 
  Syntax: scramble(<string>)
 
  This function scrambles a string, returning a random permutation of
  its characters. Note that this function does not pay any attention
  to spaces or other special characters; it will scramble these
  characters just like normal characters.
 
  Example:
  > say scramble(abcdef)
  You say "cfaedb"
 
  See Also: shuffle()
  
& search()
 
  Syntax: search([<player>] [<class>=<restriction>[,<low>[,<high>]]])
 
  This function returns a list of objects that match the search
  criteria, which are the same as with the @search command. This
  function costs as much as the @search command, so repeated use is
  expensive.
 
  Warning: if you use the [ and ] characters in an Eval selection you
  will need to escape them.
 
  Example:
  > say search()
  You say "#226 #289 #325 #364 #368 #369"
  > @stats me
  6 objects = 0 rooms, 0 exits, 5 things, 1 players. (0 garbage)
  > say search(eval=\[eq(money(##),1)\])
  You say "#289 #325 #364 #368 #369"
  > say search(player=wizard)
  You say "#1"
 
  See Also: @search, SEARCH CLASSES
  
& secs()
 
  Syntax: secs()
 
  Returns the number of elapsed seconds since midnight, January 1,
  1970. This is an easy way to time things.
 
  Example:
  > say secs()
  You say "692636020"
  ... wait a bit ...
  > say secs()
  You say "692636043"
 
  See Also: convsecs(), convtime(), time()
  
& secure()
 
  Syntax: secure(<string>)
 
  Returns <string> after replacing the characters [](){};%\$ with
  spaces. This prevents strings entered by players from causing
  undesired side effects when used, such as making your object
  perform unintended commands or give out information to which you
  have access.
 
  Note: This function is only needed when the resulting string is to
  be passed through the @force command or be used as an attribute for
  an object (like the success message for a mail message object).
 
  Example:
  > @va me=Sneak a peek at Wiz's desc... [get(#1/desc)]
  > say secure(%va)
  You say "Sneak a peek at Wiz's desc...  get #1/desc  "
  > say secure($foobar:this {is} a really, tough ; test.)
  You say " foobar:this is a really tough   test."
 
  Note: 'say secure(Sneak a peek at Wiz's desc... [get(#1/desc)])'   
  does not produce the expected result because the argument is   
  evaluated before being processed by secure(), therefore the get()  
  call has already been performed.
 
  See Also: ansisecure(), escape()
 
& selfboot
 
 >> Help: Selfboot (Misc Command)
 -----------------------------------------------------------------------------
 Syntax: Selfboot
 
 The 'Selfboot' command removes any of your multiple connections that may be
 leftover from being disconnected or having more than one window open. You
 have multiple connections open if your name appears more than once on the
 WHO list.
 
 
& ;
 
  Syntax: ;<message>
 
  This command is much like the ':' command, except that no space is
  inserted between your name and the action.
 
  Example:
  ;'s watch beeps.
 
  produces '<yourname>'s watch beeps.'.
 
  Warning: This command does not work in command lists run from an
  attribute because the ';' is treated as the command separator.
  Use pose/nospace  instead.
 
  See also: page, pose, say, whisper, :,"
  
& sendchannel
 
  RS Command: sendchannel <channel>=<message>
 
  Transmits <message> over <channel>
  
  See Also: setchannelmode, setchannelfreq, setchanneltitle 
            listchannels 
& sensor
 
  RS Command: sensor [<pri> <sec>]
  
  This command displays the currently selected sensors or sets sensors 
  to those specified.
  
  Arguments:
   none - displays the current sensors
   one argument - displays a detailed report on the current sensors
   two arguments - set your primaary and secondary sensors
    * b - beagle active probe
    * e - electromagnetic
    * h - bloodhound active probe
    * i - infrared
    * l - light amplification
    * r - radar
    * s - seismic
    * v - visual 
 
  Continued in sensor2
  
& sensor2
 
  Example:
  
  To display the brief report showing your current sensors:
  >sensor
  Sensors
  -------
  Primary:   Electromagnetic (R:16-24)
  Secondary: Infrared (R:15)
  
  To display the details report showing your current sensors:
  >sensor long
  Sensors
  -------
  Primary:   Electromagnetic 
          Range:      16-24
          Blocked by: Mountains/Obstacles, 8 pt woods
          Notes:      Easy to hit heavies, good in forests (BTH), 
          overall unreliable (chances of detection/BTH)
  Secondary: Infrared 
          Range:      15
          Blocked by: Fire/Obstacles, 6 pt woods
          Notes:      Easy to hit 'hot' targets, not very efficient in 
          forests (BTH)
  
  Continued in sensor3
  
& sensor3
 
  Example:
  To set the sensors to Primary:Electro Magnetic and Secondary: 
  Infrared:
  
  >sensor e i
  Sensors
  -------
  Primary:   Electromagnetic (R:16-24)
  Secondary: Infrared (R:15)
  
& SESSION
 
  Syntax: SESSION
 
  Displays information on how many characters you have sent and
  received during this session, and which (Internal) port you are
  connected to on the MUX.  It must be typed in all uppercase.
 
  Example:
    > SESSION
                           Characters Input----  Characters Output---
  Player Name   On For Idle Port Pend  Lost   Total  Pend  Lost Total
  Mortal        00:06   0s   16    0     0       44   156     0 2679
  2 Players logged in.
 
  Pending characters are those waiting to be acted on as commands (for
  input) or waiting to be sent out over the network (output).  Lost
  characters are due to overflowing either the MUX's input or output
  buffers, either as the  result of running a single command that
  produces too much output (such as @find and @search commands that
  match a large number of objects), or from typing too much on one
  line.
 
  Note: your Pending count for output will always be nonzero, as the
  output of the SESSION command hasn't been sent out over the
  network yet.
 
  See also: who, DOING
  
& set()
 
  Syntax: set(<object>, <string>)
 
  Works the same as @set, <object> and <string> are equivalent to what comes
  before and after the '=' sign.  Returns nothing.

  The following demonstrate how to use set() for setting or clearing a flag,
  attribute flag, or attribute on an object. As with @set, flags are cleared
  by using an exclamation mark(!) preceding the flag name for both general and
  attribute flags.  For attributes, an empty value after the colon (:) will
  clear the attribute value from the <object>.

    set(<object>, <flag>)
    set(<object>/<attribute>, <attribute flag>)
    set(<object>, <attribute>:<value>)

  Examples:

  > think [set(me,foo:Twenty Pink Pigs)]
  < think [set(me,foo:)]
  > think [set(me,VERBOSE)]
  > think [set(me/foo,!VISUAL)]
  
  See Also: @set
  
& setchannelfreq
 
  RS Command: setchannelfreq <channel>=<frequency>
 
  This command sets the frequency assigned to <channel>
 
  Example:
  >setchannelfreq a=9343
 
  See Also: sendchannel, setchannelmode, setchanneltitle,  
            listchannels 
& setchannelmode
 
  RS Command: setchannelmode <channel>=<mode>
 
  This command sets the characteristics of your use of <channel>.
 
  Mode Arguments:
  A - Analog
  D - Digital
  E - Relay
  I - Info
  S - Scan
  U - Mute
 
  Additionally you can supply color codes.
 
  See also: sendchannel, setchanneltitle, setchannelfreq, analog mode, 
            digital mode, relay mode, info mode, scan mode, mute mode, 
            radio colors 
& setchanneltitle
 
  RS Command: setchanneltitle <channel>=<title>
  
  This command sets the string which is prefixed to your transmissions 
  on <channel>
  
  Example
  
  setchanneltitle a=Mechjock
  
  senchannel a=Can anyone hear me?
  [A:180] <Mechjock> Can anyone hear me?
 
  See Also: sendchannel, setchannelmode, setchannelfreq, listchannels
  
& setdiff()
 
  Syntax: setdiff(<list1>, <list2>[, <delim>])
 
  This function returns the difference of two sets -- i.e., the
  elements in <list1> that aren't in <list2>. The list that is
  returned is sorted. If <delim> is specified, it (rather than a
  space) is used to separate items in the list.
 
  Example:
  > say setdiff(foo baz gleep bar, bar moof gleep)
  You say, "baz foo"
 
  See Also: setinter(), setunion(), sort()
  
& setinter()
 
  Syntax: setinter(<list1>, <list2>[, <delim>])
 
  This function returns the intersection of two sets -- i.e., the
  elements that are in both <list1> and <list2>. The list that is
  returned is sorted. If <delim> is specified, it (rather than a
  space) is used to separate items in the list.
 
  Example:
  > say setinter(foo baz gleep bar, bar moof gleep)
  You say, "bar gleep"
 
  See Also: setdiff(), setunion(), sort()
  
& setlock()
 
  Syntax: setlock(<locktype>,<object>,<key>)
 
  This function carries out the same action as the @lock command.
 
  Example:
  >say setlock(default,testobject,me)
  You say "1"
 
  This is the equivalent of @lock testobject=me
 
  See also: lock(), @chown, @unlock, @lock locks, @lock keys,
  @lock attribute, @lock evaluation, @lock indirect, @lock normal,
  @lock is, @lock carry, @lock ownership, @lock compound
  
& setq()
 
  Syntax: setq(<number>,<string>)
 
  This function is used to copy strings into local registers. It
  returns a null string; it is a purely "side effect" function. There
  are ten local registers, numbered 0 through 9. They are cleared at
  the start of each interactive command, but are preserved across the
  command queue. They are most useful for storing complex function
  evaluations which are used repeatedly within a single command. The
  local registers may be read via the r() function, and a common use
  of setq()/r() is to temporarily store the result of a complex
  evaluation whose result is needed more than once.
 
  setq() can be used to improve the readability of MUX code, as well
  as to cut down the amount of time needed to do complex evaluations.
 
  Example:
  >&TEST me=Test on [mudname()] at [time()].
  > say [setq(0,u(TEST))]'[r(0)]' has length [strlen(r(0))].
  You say "'Test on TestMUX at Tue Feb 23 17:00:51 1993.' has length
  45."
 
  See Also: r(), setr()
  
& setr()
 
  Syntax: setr(<number>,<string>)
 
  This function is identical to setq(), but returns <string>.
 
  See Also: setq(), r()
  
& setunion()
 
  Syntax: setunion(<list1>, <list2>[, <delim>])
 
  This function returns the union of two sets -- i.e., all the
  elements of both <list1> and <list2>, minus any duplicate elements.
  Think of it as cat() without duplicated words. The list returned is
  sorted. If <delim> is specified, it (rather than a space) is used
  to separate item in the list.
 
  Example:
  > say setunion(foo baz gleep bar, bar moof gleep)
  You say, "bar baz foo gleep moof"
 
  See Also: setdiff(), setinter(), sort()
  
& shl()
 
  Syntax: shl(<number>,<count>)
 
  Performs a leftwards bit-shift on <number>, shifting it <count>
  times. This is equivalent to mul(<number>,pow(2,<count>), but much
  faster.
 
  See Also: mul()
  
& shr()
 
  Syntax: shr(<number>,<count>)
 
  Performs a rightwards bit-shift on <number>, shifting it <count>
  times. This is equivalent to div(<number>,pow(2,<count>), but much
  faster.
 
  See Also: div()
  
& shuffle()
 
  Syntax: shuffle(<word1> <word2> <...<wordN>[,<delimiter>])
 
  This function shuffles the order of words in a list, returning a
  random permutation of its elements.
 
  Example:
  > say shuffle(foo bar baz gleep)
  You say "baz foo gleep bar"
 
  See Also: scramble()
  
& shutdown
 
  RS Command: shutdown
  
  This command causes the RS Unit to shutdown.
  
& sight
 
  RS Command: sight <weapnum> [<target-id> | <x> <y>]
  
  This command displays the base-to-hit for the specified weapon 
  against the specified target.
  
  Arguments:
  none - if no argument is given the command calculates the BTH for 
         the locked target, if any.
  * ID -  calculates the BTH for the specified RS Object.
  * x y - calculates the BTH for the specified hex.
  
  NOTE - the BTH returned by the sight command applies ONLY to the 
  weapon specified and at the time of the calculation. The BTH may 
  well be different by the time you fire the weapon.
 
  See Also: lock
  
& sign()
 
  Syntax: sign(<number>)
 
  Returns -1, 0, or 1 depending on whether its argument is negative,
  zero, or positive (respectively).
 
  Example:
  > say sign(-4)                                                                    
  You say "-1"
  > say sign(4)
  You say "1"
  > say sign(0)
  You say "0"
  > say sign(-1)
  You say "-1"
  
& sin()
 
  Syntax: sin(<number>)
 
  Returns the sine of <number>, expressed in radians.
 
  Examples:
  > say sin(0)
  You say "0"
  > say sin(fdiv(pi(),2))
  You say "1"
  > say sin(fdiv(pi(),4))
  You say "0.707107"
  > say sin(fdiv(pi(),6))
  You say "0.5"
 
  See Also: acos(), asin(), atan(), cos(), pi(), tan()
  
& sixth_sense
 
 >> Help: Sixth Sense (Advantages)
 -----------------------------------------------------------------------------
 Notifies you of all locks
 
 Result: You see an emit (message) when someone (or something) locks you. The
 message varies based on the enemy's tonnage.
 
 
& skills
 
 >> Help: Skills
 -----------------------------------------------------------------------------
  Skills are what determine how good your character is at doing certain
  things, on and off the battlefield. You may see your list of skills by
  typing 'skills', the lower the + number is, the better you are at that
  particular skill. For example, 3+ is better than 4+. You may see what
  each of your skills does by reading on.  Keep in mind that not all skills
  are always used.
 
  For the sake of organization, we will break the skill listing up into
  different categories for easier browsing. Please choose one of the
  topics listed below to view the associated skills.
 
  Skill Categories
  ================
   * Skills-Combat
   * Skills-Econ
   * Skills-Technician
   * Skills-Misc
 -----------------------------------------------------------------------------
 To view a skill category, use 'help <category>' without the <>'s.
 
 
& skills-combat
 
 >> Help: Skills-Combat
 -----------------------------------------------------------------------------
 [_Misc Combat Skills_]
 Computer		Perception		Running
 Swimming

 [_Communication Skills_]
 Comm-Conventional	Comm-Hyperpulse
 
 [_Gunnery Skills_]
 Gunnery-Artillery	Gunnery-Ballistic	Gunnery-Flamer
 Gunnery-Laser		Gunnery-Missile		Gunnery-Spotting
 
 [_Piloting Skills_]
 Piloting-Aerospace	Piloting-Biped		Piloting-Quad
 Piloting-Spacecraft	Piloting-Tracked	Piloting-Wheeled
 -----------------------------------------------------------------------------
 To view info on a skill, use 'help <skillname>' without the <>'s.
 
 
& skills-econ
 
 >> Help: Skills-Econ
 -----------------------------------------------------------------------------
 Administration		Appraisal		Bureaucracy
 Engineering		Gambling		Leadership
 Negotiation		Protocol		Research
 Strategy		Tinker			Training
 -----------------------------------------------------------------------------
 To view info on a skill, use 'help <skillname>' without the <>'s.
 

& skills-misc
 
 >> Help: Skills-Misc
 -----------------------------------------------------------------------------
 Acrobatics		Alternate_Identity		Archery
 Blade			Climbing			Cryptography
 Demolitions		Disguise			Escape_Artist
 Forgery		Gambling			Impersonation
 Interrogation		Jump_Pack			Leadership
 Medtech		Navigation			Quickdraw
 Riding			Security_Systems		Seduction
 Small_Arms		Stealth				Strategy
 Streetwise		Support_Weapons			Survival
 Tactics		Throwing_Weapons		Tracking
 Training		Unarmed_Combat			Zero-G_Operations
 -----------------------------------------------------------------------------
 To view info on a skill, use 'help <skillname>' without the <>'s.
 

& skills-technician
 
 >> Help: Skills-Technician
 -----------------------------------------------------------------------------
 [_General Unit Class Skills_]
 Technician-Aerospace	Technician-Battlemech	Technician-Battlesuit
 Technician-Mechanic	Technician-Spacecraft

 [_Specialty Skills_]
 Technician-Electronics	Technician-Weapons
 
 [_Related Skills_]
 Tinker
 -----------------------------------------------------------------------------
 To view info on a skill, use 'help <skillname>' without the <>'s.
 
 
& \\
 
  Syntax: \\<message>
 
  Outputs <message> to everyone in your current room without
  embellishment.
 
  Example:
  >\\A chill falls over the room.
  A chill falls over the room.'
 
  See also: @emit, @oemit, NOSPOOF
  
& SLAVE
 
  Flag: SLAVE (x)
 
  If set on a player, neither the player nor any of his objects may
  perform any commands that change the database.  Some sites may 
  restrict additional commands.  This flag may only be set or 
  cleared by wizards.
  
& slite
 
  RS Command: slite
  
  This command toggles the status (ie on or off) of your searchlight 
  if your unit is so equipped.
  
& sort()
 
  Syntax: sort(<list>[, <sort type>[, <delim>]])
 
  Takes a list of words, numbers, or dbref, and sorts them into
  ascending order. Lexicographic order is used for words, and numeric
  order is used for numbers and dbrefs.
 
  <sort type> may be used to specify the type of sort to perform (use
  d for dbref, n for integer numeric, f for floating numeric, and a
  for alphanumeric). If omitted or left blank, the function will
  automatically determine the type of sort to perform.
 
  If <delim> is specified, it (rather than a space) is used to
  separate items in the list. You may specify an alternate delimiter
  without specifying a sort type by passing a null <sort type>
  parameter.
 
  Example:
  > say sort(This is a test)
  You say "This a is test"
  > say sort(98 99 100 101)
  You say "98 99 100 102"
  > say sort(foo-bar-bletch,,-)
  You say "bar-bletch-foo"
 
  See Also: sortby()
  
& sortby()
 
  Syntax: sortby([<obj>/]<attrib>,<list>[,<delimiter>])
 
  This function sorts an arbitrary list according to the u-function
  <obj>/<attrib>.
 
  The u-function should compare two arbitrary elements, %0 and %1, and
  return:
 
    * zero - if the elements are equal
    * a negative integer - if element 1 is less than element 2
    * a positive integer - if element 1 is greater than element 2.
 
  A simple example, which imitates a normal alphabetic sort:
 
  > &ALPHASORT test=[comp(%0,%1)]
  > say [sortby(test/ALPHASORT,foo bar baz)]
  You say "bar baz foo"
 
  A slightly more complicated sort. #1 is "God", #2 is "Amby", "#3" is
  "Bob":
 
  > &NAMESORT me=[comp(name(%0),name(%1))]
  > say [sortby(NAMESORT,#1 #2 #3)]
  You say "#2 #3 #1"
 
  Warning: The function invocation limit applies to this function.     
  If this limit is exceeded, the function will fail _silently_. List     
  and function sizes should be kept reasonable.
 
  See Also: sort()
  
& space()
 
  Syntax: space(<count>)
 
  Returns the number of indicated spaces. If <count> is missing,
  negative, or cannot be converted to a number, one space is returned.
  This function is useful when you want to pass a single space (or
  more than one) as a function to an argument, because normally
  leading and trailing spaces are stripped from function arguments.
 
  Example:
  > say space(4)
  You say "    "
  > say edit(Foo bar bletch, space(), X)
  You say "FooXbarXbletch"
 
  Note: Don't use space() when an ljust(), rjust() or center() can
  do the job better. It's ideal to lay things out so if you ever have
  to go in and change wording, you won't have to adjust your space
  functions.
 
  See Also: ljust(), rjust(), center()
 
& speed

  RS Command: speed [num | walk | run | stop | back | flank | cruise] 
  
  With an argument this command sets the speed for the RS Unit.
  WIthout an argument it returns the speed that the unit is currently
  doing.
 
  Arguments
  * walk - sets the unit to it's walking/cruising speed
  * run - sets the unit to it's run/flank speed (~walk speed * 1.5)
  * stop - sets the unit to speed 0
  * back - sets the unit to it's max backwards speed (the same as it's 
           walk speed)
  * flank - see run
  * cruise - see walk
 
  Note - An RS Unit takes time to accelerate or decelerate to the
  speed set by the command.
 
  Example:
  Given that you are in an RS unit at speed 0
 
  >speed 60
  Desired speed changed to 60 KPH
  >speed
  Your current speed is 29.68.
  >speed
  Your current speed is 60.00.
  
& speed_demon
 
 >> Help: Speed Demon (Advantages)
 -----------------------------------------------------------------------------
 While sprinting, +1 movement to your walk/run speed (3/5 unit --> 4/6)
 Negates slower turn-rates that normally apply to sprinting
 
 Result: You go faster while sprinting than those without this advantage, and
 you turn at normal rates, instead of the slower sprinting rate
 
 
& splice()
 
  Syntax: splice(<list1>, <list2>, <word>[, <delim>])
 
  This function splices <list1> and <list2> together. <list1> and
  <list2> are space-separated lists of words
 
  If a word in <list1> is the same as <word>, it is replaced by the
  word in the corresponding position in <list2>. Both lists must have
  the same number of words. <delim> may be used to specify a delimiter
  other than a space.
 
  Example:
  > say splice(foo bar baz,eek moof gleep,bar)
  You say, "foo moof baz"
 
  See Also: merge()
  
& spot
 
  RS Command: spot <UnitID|OwnID|->
  
  This command controls the assignment of a spotter unit.
  
  Arguments:
  * UnitID - Causes your unit to use <UnitID> as a spotter
  * OwnID - Causes your unit to be available as a spotter
  * '-' - Causes your unit to cease acting as a spotter
  
& sqrt()
 
  Syntax: sqrt(<number>)
 
  Returns the square root of <number>. <number> may be a floating
  point number, and a floating point result is returned. <number> may
  not be negative.
 
  Example:
  > say sqrt(2)
  You say "1.414214"
  > say sqrt(100)
  You say "10"
  > say sqrt(0)
  You say "0"
  > say sqrt(-1)
  You say "#-1 SQUARE ROOT OF NEGATIVE"
 
  See Also: power()
  
& squish()
 
  Syntax: squish(<text>)
 
  This function literally 'squishes' the given text, reducing multiple
  instances of spaces to a single space, after evaluating everything
  normally.
 
  See Also: trim()
 
& staff
 
 >> Help: Staff (Informational Command)
 -----------------------------------------------------------------------------
 Syntax: Staff
 
 The 'Staff' command displays a listing of the current staff presiding over
 the game along with basic information about each staff member. Their job
 within the staff along with when they were last connected (or connected now)
 are also shown.
 
 
& STAFF
 
  Flag: STAFF
 
  This flag can be used to mark players who serve as staff on the MUX.
  It is wizard-settable only.
 
  See also: WIZARD, ROYALTY, HEAD
  
& stand
 
  RS Command: stand
  
  This command causes a Mech which is prone (laying on the ground) to 
  attempt to stand up.
  
  See Also: prone 
& startsecs()
 
  Syntax: startsecs()
 
  Returns a string which is the time the MUX last rebooted, expressed
  in seconds.
 
  Example:
  > say startsecs()
  You say "1144296532"
 
  See Also: starttime()
  
& starttime()
 
  Syntax: starttime()
 
  Returns a string which is the time the MUX last rebooted. The time
  is in the same format as the time() function returns.
 
  Example:
  > say starttime()
  You say "Sat Dec  7 00:09:13 1991
 
  See Also: convtime(), time()
  
& startup
 
  RS Command: startup [override]
  
  This command commences the startup cycle for an RS Unit.
 
& stats
 
 >> Help: Stats (Informational Command)
 -----------------------------------------------------------------------------
 Syntax: Stats
 
 The 'Stats' command shows basic information about your character. Things such
 as your personal injury level and your mech listing are on here, along with
 your various skills and XP gained in each.
 
 
& stats()
 
  Syntax: stats([<player>])
 
  This function returns information about the number of objects on the
  MUX, much like the @stats command. If the argument is omitted or is
  'all', then the stats for the entire MUX are returned, otherwise the
  stats for the named player are returned. You can only get stats for
  yourself unless you are a WIZARD.
 
  The stats are returned as a set of 6 numbers, in the same order as
  reported by the @stats command: total objects, rooms, exits, things,
  players, and garbage. This command costs as much as the equivalent
  @stats command (ie: '@stats/all' or '@stats <player>', not the free
  '@stats').
 
  Example:
  > @stats me
  6 objects = 0 rooms, 0 exits, 5 things, 1 players. (0 garbage)
  > say stats(me)
  You say "6 0 0 5 1 0"
  > say stats()
  You say "377 51 165 134 20 7"
  > @stats/all
  377 objects = 51 rooms, 165 exits, 134 things, 20 players. (7
  garbage)
 
  See Also: @stats
  
& status
 
  RS Command: status [a|i|w]
  
  This command displays the status of the RS Unit.
  
  Arguments:
  No argument returns the full status report
  * a - displays the armor status only
  * i - displays info such as navigation status, heat status, etc.
  * w - displays the weapon status only
  
& stealth
 
  RS Command: stealth
  
  This command toggles the status of Stealth Armor for those units 
  which are so equipped.
  
& STICKY
 
  Flag: STICKY (S)
 
  If a thing is STICKY, it goes home when dropped.  If a room is
  STICKY, its drop-to is delayed until the last person leaves. This 
  flag is only meaningful for things and rooms.
 
  See also: HOMES, DROP-TOS
  
& stinger
 
  RS Command: stinger <weaponum
  
  This command toggles the state of <weapnum>, causing it to fire 
  Stinger ammunition or normal ammunition.
  
  Stinger ammo is only used for missile launchers.
 
& stores

  RS Command: stores
  
  This command lists the parts and commodities and their amounts in 
  the factory/tower/bay/etc.
  
  See Also: loadcargo, unloadcargo, manifest
  
& strcat()
 
  Syntax: strcat(<string1>, <stringN>, ...)
 
  This function concatanates two or more strings, with no
  space between them.
   
  Example:
  Say strcat(foo,bar,baz,blech)
  You say "foobarbazblech".
  
& stripansi()
 
  Syntax: stripansi(<string>)
 
  Strips the ansi codes from <string>.
 
  See Also: ANSI, ansi(), ansisecure()
  
& strlen()
 
  Syntax: strlen(<string>)
 
  This function returns the number of characters in <string>.
 
  Example:
    > say strlen(This is a test)
    You say "14"
    > say strlen(Would you like coffee, or perhaps tea)
    You say "37"
    
& strmatch()
 
  Syntax: strmatch(<string>,<pattern>)
 
  This function matches <pattern> against the entire <string>,
  returning 1 if it matches and 0 if it does not.  The case of the 
  characters being matched is not significant.
 
  The pattern may contain the wildcards '*' and '?'.  '?' matches any
  one character, while '*' matches any number of characters, 
  including none. So 's?x' would match 'sex' or 'six', but not to 
  'socx', but 's*x' would match any of them.
 
  Examples:
    > say strmatch(This is a test,*Test)
    You say "1"
    > say strmatch(This is a test,*This)
    You say "0"
    > say strmatch(This is a test,*is*is*)
    You say "1"
 
  See also: match(), member(), regmatch().
  
& strtrunc()
 
  Syntax: strtrunc(<string>,<number>)
 
  This function returns <string> truncated if it is longer than
<number>. If
  <number> is greater than the length of <string>, it just returns
<string>.
  Much more efficient than the equivalent mid().
 
  See also: mid(), ljust().
  
& sub()
 
  Syntax: sub(<number1>,<number2>)
 
  Returns the result of subtracting <number2> from <number1>. The
  numbers may be floating point numbers, and a floating point result
  is returned.
 
  Example:
  > say sub(5,2)
  You say "3"
 
  See Also: inc(), dec(), add(), div(), mod(), mul()
  
& subeval()
 
  Syntax: subeval(<string>)
 
  This function's usefulness is primarily useful in conjunction with
  v() as a way to control when evaluation occurs. Escapes are
  evaluated, but {} and functions are not. The location escape is also
  not evaluated.
 
  When used from the command line, it's use is limited to nil because
  evaluation of subeval's parameters occurs before the subeval()
  function is called.
  
& subj()
 
  Syntax: subj(<object>)
 
  Returns the proper subjective pronoun (he, she, it, they) for
  referring to <object>, based on the object's Sex attribute. You
  must either control or be near <object>.
 
  See Also: obj(), s(), @sex
  
& success
 
  Syntax: @success <object> = <message>
  Attribute: Succ
 
  Sets the message that is shown to the player who successfully picks
  up the named player or thing, goes through the named exit, or
  looks at the room and passes the room's lock.
 
  Example:
  <object>
  @succ vase = You carefully pick up the delicate vase.
 
  <exit>
  @succ doorway = You open the door and walk through the
  doorway.
 
  See also: get, look, @asuccess, @osuccess, SUCCESS
  
& sum()
 
  Syntax: sum(<list>[, <delim>])
 
  Returns the sum of a list of numbers, optionally separated by <delim>.
 
  Example:
  > say sum(2 3 4)
  You say "9"
  > say sum(34|47|78,|)
  You say "159"
   
& SUSPECT
 
  Flag: SUSPECT (u)
 
  The SUSPECT flag is a marker used to denote players that are to be
  watched. Any player with this flag set will have every command 
  they type sent to the SuspectsLog channel for monitoring. Players 
  can't see the flag set on themselves and don't know they are 
  suspected.
 
 
& swarm
 
  RS Command: swarm [ID | -]
  
  This command causes your Battlesuit squad to attempt to mount an 
  enemy unit. This reduces your BTH for weapon attacks, and the 
  swarmed unit cannot use it's weapons on you.
  
  As with all physical attacks you must be within the same hex as the 
  unit you are attacking.
  
  Arguments:
  none - attack the locked unit
  * ID - attack the specified unit
  
  See Also: attackleg
  
& swimming
 
 >> Help: Swimming (Skills-Combat, Misc.)
 -----------------------------------------------------------------------------
 
 
 
& switch()
 
  Syntax: switch(<str>[,<pat1>,<res1>]...[,<dflt>])
 
  The switch function compares <str> against <pat1>, <pat2>, etc
  (allowing * to match any number of characters and ? to match any 1
  character), and returns the corresponding <resN> parameter for the
  first <patN> pattern that matches. If none match, then the default
  result <dflt> is returned.
 
  Example:
  > say switch(c,*a*,A,*b*,B,*c*,C,*d*,D,E)
  You say "C"
  > say switch(f,*a*,A,*b*,B,*c*,C,*d*,D,E)
  You say "E"
  > say switch(cab,*a*,A,*b*,B,*c*,C,*d*,D,E)
  You say "A"
  > say switch(f,*a*,A,*b*,B,*c*,C,*d*,D) 
  You say ""
 
  See Also: @switch, match(), ifelse(), case()
 
& t()
& true()

  FUNCTION: t(<boolean>) OR true(<boolean>)

  Takes a boolean value, and returns 1 if it's true, and 0 if it's false.

  Related Topics: BOOLEAN VALUES, and(), not(), or(), xor(). 
& tacsize
 
  Attribute: tacsize <height> <width>

  This attribute determines the height and width of the map displayed
  in response to the 'tactical' command.

  See Also: tactical
  
 & tactical
 
  RS Command: tactical [C | T | L] [<BEARING> <RANGE> | <TARGET-ID>]
 
  Displays the tactical map
  
  Arguments
  * c - highlights clifs which a mech cannot traverse
  * t - highlights cliffs which a vehicle cannot travers
  * l - displays the line of sight
  
  By default the map is centered on your current location. Using
  the <bearing> and <range> permits you to view the map offset from
  your current location by <range> hexes in the direction of
  <bearing>.
  
  Alternatively by specifying the <ID> of another RS unit 
  you can view the tactical map centered on that unit.
  
   
& tag
 
  RS Command: tag [id|-]
  
  This command enables and disables the targetting of an enemy RS Unit 
  with the Target Acquisition Gear. 
  
  Arguments:
  * ID - The ID of the RS Unit you wish to light up with the TAG.
  * - - Disables TAG
  
  Example:
  
  >tag IY
  You light up T2 Exterminator [IY] with your TAG.
  ...
  Your TAG system has achieved a stable lock.
  
  >tag - 
  Your TAG connection has been broken.
  
& take
 
  Syntax: take[/<switch>] <object>
           take[/<switch>] <exit>
           take[/<switch>] <object>'s <sub-object>
 
  The first form picks up <object> from your location and adds it to
  your inventory.  It will fail if the object is locked against you,
  or if you are inside a player or object that you don't control and
  which isn't set ENTER_OK.
 
  The second form takes an exit from your location and adds it to you.
  Anyone inside you may then use the exit to travel to the exit's
  destination.
 
  You may take exits that you own, and exits owned by others in
  locations that you own.
 
  The third form takes <sub-object> from <object> and adds it to your
  inventory.  <object> must be ENTER_OK and <sub-object> must not be
  locked against you for this to work.  The lock on <object> is not
  checked.
 
  { 'help take2' for more}
  
& take2
 
 The following switch is recognized:
     /quiet   - Don't perform the @osucc/@asucc or @ofail/@afail
                attributes on the target object.  This switch only
                works if you control the object.
 
  <object> and <sub-object> may be either players or things.
  'get' is the same as 'take'.
 
  See also: drop, @afail, @asucc, @fail, @ofail, @osucc, @succ,
  ENTER_OK, FAILURE, SUCCESS.
  
& takeoff
 
  RS Command: takeoff
  
  This command is used in a VTOL or Aero unit to get the unit into 
  the air.
  
  See Also: land, vetical,
  
& tan()
 
  Syntax: tan(<number>)
 
  This function returns the tangent of <number>, expressed in radians.
 
  Examples:
    > say tan(0)
    You say "0"
    > say tan(1)
    You say "1.557408"
    > say tan(fdiv(pi(),4))
    You say "1"
  
  See also: acos(), asin(), atan(), cos(), pi(), sin().
  
& target
 
  RS Command: target <section | ->
  
  This command permits you to target a specific part of the unit you 
  you have locked.
  
  Arguments:
  * - disable targetting
  * section - sets the section of the RS Unit to aim at.
  
  Example:
  >lock ia
  Target set to T1 Mercury [ia].
  The sensors acquire a stable lock on T1 Mercury [ia].
  
  >target h
  Head targetted.
  >target ct
  Center Torso targetted.
  
  >target -
  Targetting disabled.
  
  See Also: lock
  
& tel()
 
  Syntax: tel(<victim>,<targetloc>)
 
  Teleports the specified thing or player (or exit?) to the target
  location.
 
  Example:
  > think tel(me,#0)
  Limbo(#0:R)
  Welcome to Limbo
 
  The above is the equivalent of @teleport me=#0
 
  See Also: @teleport
 
& templates
 
 >> Help: Templates (Template Commands)
 -----------------------------------------------------------------------------
 Listrefs		Listeras		Viewref
 -----------------------------------------------------------------------------
 To view specifics about each command, use 'help <topic>' without the <>'s.
 
 
& think
 
  Syntax: think <message>
 
  You can use this command to send a private message to yourself.
  Pronoun substitution is performed. This is essentially equivalent
  to "@pemit me=<message>", but with "think", there is no prepended
  text.
 
  One possible use: "@adesc me=think --> %n(%#[flags(%#)])
  just looked at you."
  
& thrash
 
  RS Command: thrash
  
  This command is used by a Mech to attempt to dislodge any elementals 
  or battlesuits which are swarming it.
  
  A Mech must be prone before it can thrash.
 
  See Also: prone, swarm
  
& throw
 
  Syntax: throw[/<switch>] <object>
           throw[/<switch>] <exit>
 
  The first form removes <object> from your inventory and puts it in
  your location, except for the following special cases: Dropping a
  STICKY thing sends it home, and dropping a thing in a room with a
  drop-to sends the thing to the drop-to location.
 
  The second form removes <exit> from your list of exits and adds it
  to the list of exits for the current location.  Anyone in the same
  location as you may then use the exit to travel to the exit's
  destination.  You can only drop exits when you own the location
  where you are dropping them.
 
  The following switch is recognized:
     /quiet   - Don't perform the @odrop/@adrop attributes on the
                dropped object.  This switch only works if you control
                the object.
 
  NOTE: 'drop' is the same as 'throw'.
 
  See also: get, @adrop, @drop, @odrop, DROP-TO, STICKY.
  
& thrust
 
  RS Command: thrust [num]
  
  This command controls the thrust for Aero type RS Units.
  
  Arguments:
  none - displays the current thrust
  num - sets the thrust
  
  NOTE - Aero units are currently non-functional within the codebase.
  
  See Also: dive, climb
 
& time
 
 >> Help: Time (Informational Command)
 ------------------------------------------------------------------------------
 Syntax: Time
 
 The 'Time' command shows the current MUX time, along with a progress bar that
 shows how far in to the game day you are. This resets at 00:00:00 MUX time.
 
 
& time()
 
  Syntax: time()
 
  Gives you the current machine time for the box where the game is
  running.
 
  Note: The returned time may need adjustment for time zones.
 
  Example:
  > say time()
  You say "Thu Dec 19 09:48:06 1991"
 
  See Also: convsecs(), convtime(), secs()
  
& toggletype
 
  RS Command: toggletype <loc> <pos> <type>
  
  This command sets the ammunition for ammobin in <loc> <pos> to 
  <type>.
  
  To set the ammobin to use the 'normal' ammunition use '-' as the 
  argument.
 & topics
 
  Help available on the following Topics:
 
  ARBITRARY COMMANDS  ATTRIBUTE OWNERSHIP BEING KILLED        BOGUS COMMANDS
  BOOLEAN VALUES      COMMAND EVALUATION  COMSYS              CONTROL 
  COSTS               CREDITS             DROP-TO             ENACTOR
  EXITS               FAILURE             FLAG LIST           FLAGS 
  FUNCTION LIST       FUNCTIONS           GENDER              GOALS 
  HERE                HOMES               LINKING             LISTENING
  LISTS               LOOPING             ME                  MONEY
  MOVING              OBJECT STACK        OBJECT TYPES        PARENT OBJECTS
  PARENT ROOMS        PIPING		  POWERS LIST         PUEBLO
  PUPPETS             REGEXPS             ROBBERY             SEARCH CLASSES
  SEMAPHORES          SPOOFING            STACK               SUBSTITUTIONS
  SUCCESS             SWITCHES            VERBS               WIZARDS
  ZONE OBJECTS 
& toughness
 
 >> Help: Toughness (Advantages)
 -----------------------------------------------------------------------------
 3 dice are rolled, and the best 2 are calculated towards your Conscious Roll
 check
 
 Result: You are less likely to be knocked unconscious in combat.
 
 
& TRACE
 
  Flag: TRACE(T)
 
  When a thing is set TRACE, it will report to its owner the result of
  all substitutions that it performs that change the original 
  string.  The order for displaying nested evaluations (such as when 
  evaluating the arguments to a function) is a site-selected 
  configuration parameter.
 
  When trace output is displayed in top-down order (final evaluation
  first, followed by the 'smaller' evaluations needed to perform 
  it), then the total  number of trace ouput lines that may be 
  produced by an evaluation is limited to 200.  Bottom-up trace 
  output is not limited.
  
& translate()
 
  Syntax: translate(<string>, <type>)
 
  This function takes <string>, and converts all raw ANSI color codes
  and carriage returns to either MUX substitutions, or to spaces. If
  <type> is 0 or 's', the raw codes are converted to spaces, if it is
  1 or 'p', the codes are converted to MUX %c and %r substitutions.
 
  See Also: stripansi(), secure()
  
& TRANSPARENT
 
  Flag: TRANSPARENT (t)
 
  If an exit is TRANSPARENT, then when you look at it you see the description
  of the room on the other side of the exit in addition to the description
  of the exit.  When a room is TRANSPARENT, you see a long listing of
  exits, including their destinations.
 
 
& trim()
 
  Syntax: trim(<string> [,<trim style> [,<trim character>]])
 
  This function will trim trailing and/or lead characters on the
  string that you specify.  <trim character> specifies the character 
  to trim (default is space), and <trim style> tells the kind of 
  trimming to perform (default is trim both sides of the string).
 
  The following values for <trim style> are recognized:
      'b' :   Trim both ends of the string (default)
      'l' :   Trim the left end of the string.
      'r' :   Trim the right end of the string.
  Note: anything else specified for <trim style> will trim both sides.
 
  Example:
    > say trim(;;;Wacka;;;,;)
    You say "Wacka"
    > say trim(%b%b%b Polly Parrot %b%b%b%b,,r)
    You say "    Polly Parrot"
    > say trim(---Trim Rules!---,-,l)
    You say "Trim Rules!---"
 
  See also: center(), ljust(), rjust().
  
& trip
 
  RS Command: trip [R|L} [ID]
  
  This command causes your 'Mech to trip another RS Unit.
  
  As with all physical attacks you must be within the same hex as the 
  unit you are attacking.
  
  Arguments:
  none - if a target is locked, attempt to trip that target
  * R - attempt to trip with the Right leg
  * L - attempt to trip with the Left leg
  * ID - specify a unit to trip
  
  See Also: charge, chop, club, grabclub, kick, mace, punch, saw
  
& trunc()
 
  Syntax: trunc(<number>)
 
  Returns the value of <number> after truncating any fractional value.
  <number> may be a floating point number, and an integer result is
  returned.
 
  Example:
 
  > say trunc(5)
  You say "5"
  > say trunc(5.2)
  You say "5"
  > say trunc(5.8)
  You say "5"
  > say trunc(-5)
  You say "-5"
  > say trunc(-5.2)
  You say "-5"
 
  See Also: div(), floor(), mod(), round()
  
& turnmode
 
  RS Command: turnmode <tight|normal>
  
  This command permits selection of the desired turning rate.
  
  NOTE - This command is available to characters with the Maneuvering 
  Ace advantage only.
  
  Arguments:
  * normal - as per normal
  * tight - enables sharper turns, however there is a greater cost in 
            speed lost to achieve the turn.
  
& turret
 
  RS Command: turret <degrees>
  
  This command sets the direction in which the turret on a vehcile
  faces.
  
  Note - The turret is not locked in that direction. Changing the 
  heading of the unit will rotate the entire unit, including the 
  turret which consequently will change the direction the turret is 
  facing.
  
  See Also: autoturret
  
& type()
 
  Syntax: type(<object>)
 
  Returns a string indicating the object type of <object>, either
  EXIT, PLAYER, ROOM, or THING.
 
  Example:
 
  > say type(me)
  You say "PLAYER"
  > say type(here)
  You say "ROOM"
 
  See Also: hastype()
  
& u()
 
  Syntax: u([<obj>/]<attr>[,<arg>]...)
 
  The u function evaluates an attribute, either from the object
  performing the function or from another object you own, passing in
  arguments and returning the result.
 
  When evaluating the fetched attribute, %# refers to the original
  enactor and not the 'calling' object, and 'me' refers to the object
  that supplied the attribute.
 
  Example:
 
  > @va me=Word is [extract(v(vb),add(%0,1),1)], arg2 is %1.
  > @vb me=This is a test of the u function.
  > say u(va,4,Testing 123)
  You say "Word is of, arg2 is Testing 123."
  > say u(va,7)
  You say "Word is function., arg2 is ."
  > say u(me/va,6,Foobar)
  You say "Word is u, arg2 is Foobar."
 
  See Also: s(), v(), get(), get_eval(), map()
  
& ucstr()
 
  Syntax: ucstr(<string>)
 
  This function returns <string> with all letters converted to
  uppercase.
 
  Example:
    > say ucstr(This is a test, really!)
    You say "THIS IS A TEST, REALLY!"
 
  See also: capstr(), lcstr().
  
& udefault()
 
  Syntax: udefault([<obj>/]<attr>,<default case>[,<arg>]...)
 
  This function returns the value of the user-defined function as
  defined by <attr> (or <obj>/<attr>), as if retrieved via the u()
  function, with <args>, if the attribute exists and is readable by
  you.
 
  Otherwise, it evaluates the default case, and returns that. The
  default case is only evaluated if the attribute does not exist or
  cannot be read.
 
  Example:
 
  > &TEST me=[center(%0,5,*)]
  > say udefault(Test,-- BOOM --,ACK)
  You say "*ACK*"
  > &TEST me
  > say udefault(me/Test,-- BOOM --,ACK)
  You say "-- BOOM --"
 
  See Also: get(), get_eval(), u(), default(), edefault()
  
& udisembark
 
  RS Command: udisembark
  
  This command causes your RS Unit to exit the carrier in which is it 
  being transported.
  
  Upon exit your RS Unit will be immediately started up and you will 
  be able to move, however no weapons will be available until the unit 
  is fully reset.
  
  Example:
  
  >udisembark
  You emerge from the unit loading ramp.
  
  Your Left Arm has finished its previous action.
  Your Right Arm has finished its previous action.
  Your Left Torso has finished its previous action.
  Your Right Torso has finished its previous action.
  Your Center Torso has finished its previous action.
  Your Left Leg has finished its previous action.
  Your Right Leg has finished its previous action.
  Your Head has finished its previous action.
 
  See Also: embark 
& ulocal()
 
  Syntax: ulocal([<obj>/]<attr>[,<arg>]...)
 
  The ulocal() function is almost identical to u() in Syntax: it
  evaluates an attribute, either from the object performing the
  function, or another object that you control or has the same owner
  as you, passing in arguments and returning the result. When
  evaluating the fetched attribute, %# refers to the original enactor
  and not the 'calling' object; 'me' refers to the object that
  supplied the attribute.
 
  However, unlike the u() function, the global registers r(0) through
  r(9) (%q0 - %q9) are preserved in their initial state. This means
  that functions "below" the level of the u() can reset global
  registers for temporary calculations, without needing to worry about
  "clobbering" the original values.
 
  This makes ulocal() particularly useful for global or shared code
  which calls arbitrary u() functions, where global register values
  need to be preserved from accidental user clobbering.
 
  (help ulocal()2 for more)
. 
& ulocal()2 
  Example:
 
&FRUIT me=apples bananas oranges pears
&SUB-FUNCTION me=[setq(0,v(FRUIT))][extract(%q0,match(%q0,%0),1)]
&TOP-FUNCTION me=[setq(0,are delicious!)][ulocal(SUB-FUNCTION,%0)]%q0
say u(TOP-FUNCTION,b*)
You say "bananas are delicious!"
 
If SUB-FUNCTION had been called with u() instead of ulocal():
 
&TOP-FUNCTION me=[setq(0,are delicious!)][u(SUB-FUNCTION,%0)] %q0
say u(TOP-FUNCTION,b*)
You say "bananas apples bananas oranges pears"
 
In this second example, in SUB-FUNCTION, %q0 was set to "apples
bananas oranges pears", so that when the u() "returned" and TOP-
FUNCTION evaluated %q0, this is what was printed. In the first
example, ulocal() reset the value of %q0 to its original "are
delicious!"
 
  See Also: u(), setq(), r()
  
& ultra
 
  RS Command: ultra <weapnum>
  
  This command toggles the state of <weapnum> causing it to cycle 
  between Ultra mode and normal mode. In Ultra mode 2 shots are fired 
  instead of 1. 
  
  Only the Ultra AutoCannon can use Ultra mode.
  
& UNFINDABLE
 
  Flags: UNFINDABLE (U)
 
  If a player is set UNFINDABLE, he cannot be found by the loc() or
room()
  functions.  If a room is set UNFINDABLE, players in that room (or
inside
  objects in the room) cannot be found by loc()/room().
 
  See also: loc(), room()
  
& UNINSPECTED
 
  Flag: UNINSPECTED (g)
 
  This flag is typically set on rooms that need to be
  inspected for good building practices. This flag may only be set by
  wizards and royalty.
  
& unjam
 
  RS Command: unjam <weapnum>
 
  This command permits the pilot to fix fixes ammo loader jams.
  
  Example:
  
  The ammo loader mechanism jams on your RotaryAC/2!
  
  >status w
=========================WEAPON SYSTEMS STATUS=========================
[##] -------- Weapon Name -------- || Location -------- || Status -----
[ 0] RotaryAC/2                    || Right Arm         || AMMOJAM
[ 1] StreakSRM-6                   || Left Torso        || OPERATIONAL
[ 2] ERMediumLaser                 || Head              || OPERATIONAL
  
  >unjam 0
  You begin to shake the jammed ammo loose on weapon #0
  You make a roll to unjam the weapon!
  Modified Gunnery Skill: BTH 5   Roll: 9
  You manage to clear the jam on your RotaryAC/2!
  
& unload
 
  RS Command: unload <loc> <pos>
  
  This command unloads the ammunition stored in the ammobin at 
  <loc> <pos>.
  
  Use the critstatus command to identify the <pos>
 
& unloadcargo

  RS Command: unloadcargo <name> <amount>
 
  This command unloads <amount> of <name> from the RS Unit.
  
  See Also: loadcargo, stores, manifest
 
& uptime
 
 >> Help: Uptime (Informational command)
 -----------------------------------------------------------------------------
 Syntax: Uptime
 
 The 'Uptime' command shows not only the amount of time the MUX has been up
 since the last restart, it also shows some other interesting statistics such
 as the lifetime of the game, the current version number, and the time since
 the last restart.
 
 
& use
 
  Syntax: use <object>
 
  Uses <object>.  Some objects will do interesting, useful, or
  dangerous things when used, for instance, using a camera should
  result in a picture being taken.
 
  See also: @ause, @ouse, @use
  
& usebin
 
  RS Command: usebin <weapnum> <location>
  
  The command specifies the ammobin which <weapnum> will draw 
  ammunition from first.
  
  Example:
  Given that the unit is an AGS-2D
  
  >usebin 0 lt 7
  Prefered ammo source set to Left Torso for weapon #0
  
& v()
 
  Syntax: v(<string>)
 
  This function can be used as an alternative for percent (%)
  substitution and also as a replacement for get(me/<arg>). If the
  argument is two characters long or longer and starts with a letter,
  then the object performing the v() call (and its parent, if
  necessary) is searched for the named attribute, and its value is
  returned if possible. Otherwise, a percent substitution is performed
  on the argument (so that v(o) is equivalent to %o, for instance).
 
  The percent form (%o in the previous example) is preferred as it is
  faster.
  
  Note: Attributes with single-character names cannot be retrieved
  with v().
 
  See Also: GENDER, SUBSTITUTION, PARENT OBJECTS
  
& VACATION
 
  Flag: VACATION(|)
 
  This flag can only be set by wizards. It is usually used to
  mark players who will be inactive for a long period of time. It is
  automatically cleared when the character logs on.
  
& vadd()
 
  Syntax: vadd(<vector>,<vector>[,<delimiter>])
 
  Returns the sum of two vectors. A vector is a list of numbers
  separated by spaces or a delimiter, and may be up to 20-dimensional.
 
  Example:
 
  > think vadd(1 2 3,4 5 6)
  5 7 9
  > think vadd(0|0|0,1|2|3,|)
  1|2|3
 
  See Also: vmul(), vdim(), vsub(), vunit(), vmag()
  
& valid()
 
  Syntax:  valid(name,<Name>)
 
  Returns a 1 if the specified <Name> is a valid name for an object,
  room, exit, or player. 0 if not. Names are considered invalid if
  they begin with certain characters like '!'.
 
  Example:
 
  > think valid(name,somename)
  1
  > think valid(name,!test)
  0
 
  See Also: name(), @name
  
& vdim()
 
  Syntax: vdim(<vector>[,<delimiter>])
 
  Returns the dimensionality of a vector.
 
  Example:
  > think vdim(1 2 3 4)
  4
   
  See Also: vmul(), vadd(), vsub(), vunit(), vmag()
 
 & vector
 
  RS Command: vector [x y] [x y]
 
  This command returns the vector to the hex specified.
 
  If only one hex is specified the vector returned is from your
  current location.
 
  If two hexes are specified the command returns the vector from the
  first hex to the second hex.
 
  The hex argument may be omitted if the unit is locked to the target
  hex.
   
& VERBOSE
 
  Flag: VERBOSE (v)
 
  This flag causes all commands executed by the object having
  the flag to be echoed to the owner of the object.
 
  See also: TRACE
 
& version

  Syntax: version

  Displays the version of MUX that is running and the date it was last
  rebuilt.

  See also: version()
  
& version()
 
  Syntax: version()
 
  Returns a string which contains various version information for the
  MUX you're on.
 
  Example:
 
  > version
  You say "TinyMUX Beta 1.6+HUD+HAG+ALG #7 with BtOnline-BTechMux 0.5"
  
& vertical
 
  RS Command: vertical [num]
  
  This command controls the vertical speed of VTOL type RS Units.
  
  Arguments:
  none - displays the current vertical speed
  num - sets the vertical speed to num
  
  See Also: land, takeoff
  
& view

  RS Command: view <UnitID>
 
  This command shows the value of the mechdesc attribute on <UnitID>
 
  Example
  Given that bz is the unitID of an RS unit with 'mechdesc:A nasty
  looking monster of a mech' and bk is the unitID of an RS unit with
  no mechdesc attribute
 
  >view bz
  A nasty looking monster of a mech
  >view bk
  That target has no markings.

  See Also: mechdesc
 
& viewref
  
 >> Help: Viewref (Template Command)
 -----------------------------------------------------------------------------
 Syntax: Viewref <reference>
 Syntax: Viewref/specs <reference>
 Syntax: Viewref/weaponspecs <reference>
 Syntax: Viewref/critstatus <reference> <section>
 
 The first form of this command shows the unit's status display as if you were
 in a mech of the specified type and hit 'status'.
 
 The second form of the command shows pertinent information on the specified
 ref.
 
 The third form of this command shows the 'weaponspecs' display as if you were
 in a mech of the specified type and hit 'weaponspecs'.
 
 The fourth form of this command displays the 'critstatus' display for the
 specified reference. This is useful for checking weapon/ammo/crit locations
 in each section of a unit.
 
 See also: listrefs, listeras
 
 
& visible()
 
  Syntax: visible(<object>,<victim>[/<attr>])
 
  Returns 1 if <object> can examine <victim>, or 0 otherwise. If
  <object> or <victim> do not exist, 0 is returned.
 
  If an object-attribute pair is provided, 1 is returned if <object>
  can see <attr> on <victim>. If <attr> is not present on <victim>, 1
  is returned if <object> can examine <victim>.
 
  See Also: DARK, LIGHT
  
& VISUAL
 
  Flag: VISUAL (V)
 
  When set on your object, it allows other players to examine it and
  see all the object's attributes as if they owned the object. They
  cannot make any changes to the object.
  
& vmag()
 
  Syntax: vmag(<vector>[,<delimiter>]
 
  Returns the magnitude of a vector, using a euclidean distance
  metric. That is, for vector a b c d, returns sqrt(a^2+b^2+c^2+d^2).
 
  Example:
 
  >think vmag(3 4)
  5
   
  See Also: vmul(), vdim(), vadd(), vsub(), vunit()
  
& vmul()
 
  Syntax: vmul(<vector|number>,<vector|number>[,<delimiter>])
 
  Returns the result of either multiplying a vector by a number, or
  the "dot product" (elementwise product) of two vectors. The dot
  product of a b c by w x z is aw bx cz
 
  Example:
 
  > think vmul(1 2 3,2)
  2 4 6
  > think vmul(1 2 3,2 3 4)
  2 6 12
 
  See Also: vmag(), vdim(), vadd(), vsub(), vunit()
  
& vsub()
 
  Syntax: vsub(<vector>,<vector>[,<delimiter>])
 
  Returns the difference between two vectors.
 
  Example:
 
  > think vsub(3 4 5,3 2 1)
  0 2 4
 
  See Also: vmul(), vdim(), vadd(), vmag(), vunit()
  
& vunit()
 
  Syntax: vunit(<vector>[,<delimiter>]
 
  Returns the unit vector (a vector of magnitude 1), which points in
  the same direction as the given vector.
 
  Example:
 
  > think vunit(2 0 0)
  1 0 0
  > think vmul(vunit(5 6 7),vmag(5 6 7))
  5 6 7
 
  See Also: vmul(), vdim(), vadd(), vsub(), vmag()
 
& weaplist
 
 >> Help: Weaplist (Informational Command)
 ----------------------------------------------------------------------------
 Syntax: Weaplist
 
 Displays a complete listing of all of the weapons currently supported by our
 source. The entries are color coded based on type, the legend for the types
 is on the bottom of the display.
 
 
& weaponspecs
 
  RS Command: weaponspecs
  
  This command displays the specifications for the weapons in the RS 
  Unit.
  
  Example:
                  Weapons statistics for Exterminator: EXT-4D                 
Weapon Name             Heat  Damage  Range: Min  Short  Med  Long  VRT       
------------------------------------------------------------------------------
IS.MediumLaser            3      5            0     3      6    9   25        
IS.LRM-10                 4      1            6     7     14   21   15        
IS.Anti-MissileSystem     1      2            0     1      1    1   60        
IS.SmallLaser             1      3            0     1      2    3   15        
------------------------------------------------------------------------------
  
& weaponstatus
 
  RS Command: weaponstatus
  
  This command displays the status of all the weapons in the RS Unit, 
  indicating if each weapon is DESTROYED, DISABLED, JAMMED, SHORTED, 
  EMPTY, DUD, AMMOJAM, DAMAGED, or OPERATIONAL.
  
  Example:
=========================WEAPON SYSTEMS STATUS=========================
[##] -------- Weapon Name -------- || Location -------- || Status -----
[ 0] MediumLaser                   || Left Arm          || OPERATIONAL
[ 1] MediumLaser                   || Left Arm          || OPERATIONAL
[ 2] MediumLaser                   || Right Arm         || OPERATIONAL
[ 3] MediumLaser                   || Right Arm         || OPERATIONAL
[ 4] LRM-10                        || Left Torso        || OPERATIONAL
[ 5] Anti-MissileSystem            || Right Torso       || OPERATIONAL
[ 6] SmallLaser                    || Head              || OPERATIONAL

  See Also: status, weaponspecs
 
& weapstats
 
 >> help: Weapstats (Informational Command)
 ----------------------------------------------------------------------------
 Syntax: Weapstats <weapon>
 
 This command displays a bunch of various information about the specified
 weapon. To name a few:
 
 Recycle Time, Weapon Type, Heat, Damage, Minimum/Short/Medium/Long Ranges,
 Crits per weapon, Ammo per ton, Weight, and Battle Value. 
 

& weather
 
 >> Help: Weather (Informational Command)
 -----------------------------------------------------------------------------
 Syntax: Weather
 
 Shows the conditions out on the map. You can see this from anywhere in the
 game so your location is irrelevant.
 
 
& where()
 
  Syntax: where(<object>)
 
  This function returns the "true" location of an object. You must
  control the object or be near it in order for it to work. For
  players and things, the "true" location is the normal location of
  the object.
 
  For exits, the "true" location is the source room. For rooms, it is
  #-1.
 
  See Also: loc(), rloc()
 
& whisper

  Syntax: whisper <player>=<message>

  Whispers the message to the named person, if they are in the same
  room as you. No one else can see the message that you whisper.

  You can format the message one of several ways by specifying ':',
  ';', or '"' as the first character of the message.  ':' and ';'
  format the message as 'You sense <player> <message>', with ';'
  omitting the space between <player> and <message>.  '"' formats
  the message in normal whisper format (this is the default).

  See also: page, pose, say, :, ;,"
  
& WHO
 
  Syntax: WHO <prefix>
 
  Displays a list of players currently connected to the MUX.
  The WHO report tells you how long a player has been on, how long
  they have been inactive, and what they are doing (if they have
  used the @doing  command).  If <prefix> is specified, only players
  whose names start with  <prefix> are listed.  The WHO command must
  be entered in all capitals.
 
  See also: @doing, lwho()
  
& WIZARD

  Flag: WIZARD (W)

  If a person is WIZARD, they are a wizard, unkillable,
  subject to fewer restrictions, and able to use wizard commands.
  In general, WIZARDs can do anything using #<number> or *<player>.
  Only player #1 can set and unset the WIZARD flag of other players.

  No WIZARD can turn their own WIZARD flag off.  There is probably a
great
  metaphor for life in there somewhere.
  
& wordpos()
 
  Syntax: wordpos(<string>, <charpos>[, <delim>)
 
  Returns the number of the word within <string> where the character
  position <charpos> falls. Spaces between words are treated as
  belonging to the word that follows them. If <charpos> is not within
  the string, the value #-1 is returned. Both words and characters are
  numbered starting at 1.
 
  <delim> may be used to specify a delimiter other than a space.
 
  Example:
 
  > say wordpos(This is a test, 4)
  You say "1"
  > say wordpos(This is a test, 5)
  You say "2"
  > say wordpos(This is a test, 6)
  You say "2"
  > say wordpos(This is a test, 20)
  You say "#-1"
 
  See Also: extract()
  
& words()
 
  Syntax: words(<string>[, <delim>])
 
  Returns the number of words in <string>. <delim> may be used to
  specify a delimiter other than a space.
 
  Example:
 
  > say words(This is a test)
  You say "4"
  say words(Would you like coffee or perhaps tea?)
  > You say "7"
  say words(This:is:a:colon:separated:list,:)
  > You say "6"
  
& XCODE
 
  Flag: XCODE (X)
 
  The XCODE flag, in conjunction with @xtype, designates an XCODE
  object.
  
& xget()
 
  Syntax: xget(<object>,<attribute>)
 
  This function works exactly like get(), but uses the object and
  attribute separated into two arguments.
 
  See Also: get(), eval(), get_eval()
  
& xor()
 
  Syntax: xor(<boolean1>[,<booleanN>]...)
 
  Takes one or more BOOLEAN-Z arguments, and returns TRUE(1) if an odd
  number of them are equivalent to TRUE.
 
  See Also: BOOLEAN VALUES, and(), not(), or()
  
& zfun()
 
  Syntax: zfun(<attrib>, <arg0>[, <arg1>[, ...]])
 
  Evaluates <attrib> on the enactor's zone object with parameters.
 
  See Also: zone(), zplayers(), zwho()
  
& zone()
 
  Syntax: zone(<object>)
 
  Returns the object's 'zone'. This is the dbref of the master object
  which defines the zone.
 
  Example:
 
  think zone(#12)
  #8
 
  See Also: zfun(), zplayers(), zwho()
  
& ZONE OBJECTS
 
  ZONE OBJECTS
 
  Zones are areas of the MUX which may be controlled by many people.
  Essentially, they allow group ownership of objects.
 
  The default zone is NOTHING. Any building done by a player defaults
  to belonging to the same zone that the player belongs to.
  Every zone is defined by a Zone Master Object (ZMO). The ZMO is an
  ordinary MUX object owned by some player. A wizard may change the
  zone of an object or player to a ZMO.
 
  If the ZMO is a room, it is called a "Parent room." Most of the
  statements about ZMOs also apply to parent rooms; for details,
  see the help topic PARENT ROOMS.
 
  See also: ZONES2
  
& ZONES2
 
  Anyone who can pass the Enter lock of the ZMO has control over all
  objects in that zone. This, in essence, gives that player wizard
  powers within that zone. For this reason, one must be extremely
  careful with the enter locks of ZMOs!
 
  Also, $commands on a ZMO are treated as global within that zone.
  The game attempts to match $commands for the ZMO of the player's
  location, as well as $commands for the player's own zone.
  
  For some suggestions on how to use zones, see "help ZONES3".
  
& ZONES3
 
  Some suggested uses of zones:
  1. If you are working on a building project with several people, it 
  may be useful to create a zone object and @elock it to all of you, 
  and ask a  wizard to @chzone the players involved to the zone 
  object. That way, all of the  players working on the project will 
  be able to modify the building.

  2. On a similar thread, if several players are working on a project 
  involving only a few objects, it may be simpler to create a zone 
  object and @chzone those few objects to the ZMO instead of 
  resetting the zones of the players. Note that a player does not 
  have to belong to a zone in order to change objects in that zone; 
  all is merely required to pass the ZMO's enter lock.
 
  See also: ZONES4
   
& ZONES4
 
  More possible uses for zones:
 
  3. If local wizards are desired, a zone object may be created and
  enter locked to the local wizard. Players building within 
  that zone should  be @chzone'd to that ZMO. The local wizard 
  will then be able to control anything within that domain.
 
  4. If you want restricted global commands defined over only a
  small area, you can define that area to be part of a zone, 
  and place the desired $commands upon the ZMO.
  
& zplayers()
 
  Syntax: zplayers(<ZoneObject>)
 
  Returns a list of player dbrefs who are members of the specified
  zone.
 
  See Also: zone(), zfun(), zwho()
  
& zwho()
 
  Syntax: zwho(<object>)
 
  Returns a list of players who are in the zone defined by <object>.
  Currently a WIZARD/ROYALTY only function.
 
  Example:
 
  think zwho(#18)
  #20 #32 #18
 
  See Also: zone(), zfun(), zplayers()

