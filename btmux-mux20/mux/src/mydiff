diff /home/nick/sandbox/mux2.4.20/mux/src/.depend ./.depend
22c22
< local.o: local.cpp copyright.h autoconf.h config.h externs.h db.h attrcache.h flags.h timeutil.h match.h mudconf.h alloc.h htab.h svdhash.h stringutil.h svdrand.h
---
> local.o: local.cpp copyright.h autoconf.h config.h externs.h db.h attrcache.h flags.h timeutil.h match.h mudconf.h alloc.h htab.h svdhash.h stringutil.h svdrand.h functions.h command.h btech/mech.h config.h externs.h db.h attrs.h powers.h copyright.h btech/mech.stat.h btech/muxevent.h btech/p.event.h comsys.h btech/macros.h btech/floatsim.h btech/btconfig.h btech/mymath.h btech/maps.h btech/btmacros.h btech/mech.h btech/p.glue.hcode.h btech/map.coding.h btech/p.map.coding.h btech/glue.h mudconf.h command.h btech/glue_types.h btech/p.glue.h btech/mech.notify.h btech/p.mech.notify.h btech/glue.h btech/p.glue.h btech/p.glue.scode.h functions.h python.h 
42c42
< sqlshared.o: sqlshared.cpp autoconf.h copyright.h config.h sqlshared.h
---
> sqlshared.o: sqlshared.cpp autoconf.h copyright.h config.h
58c58
< sqlshared.o: sqlshared.cpp autoconf.h copyright.h config.h sqlshared.h
---
> sqlshared.o: sqlshared.cpp autoconf.h copyright.h config.h
Only in .: .game.cpp.swp
Common subdirectories: /home/nick/sandbox/mux2.4.20/mux/src/CVS and ./CVS
Only in .: Makefile
diff /home/nick/sandbox/mux2.4.20/mux/src/_build.h ./_build.h
3c3
< // $Id: _build.h,v 1.46 2005/10/12 05:39:11 sdennis Exp $
---
> // $Id: _build.h,v 1.48 2005/10/19 15:00:17 sdennis Exp $
20,21c20,21
< #define MUX_VERSION       "2.4.0.20"         // Version number
< #define MUX_RELEASE_DATE  "2005-AUG-06"      // Source release date
---
> #define MUX_VERSION       "2.4.0.22"         // Version number
> #define MUX_RELEASE_DATE  "2005-OCT-19"      // Source release date
Only in .: _build.o
Only in .: aero.bomb.o
Only in .: aero.move.o
Only in .: ai.o
diff /home/nick/sandbox/mux2.4.20/mux/src/alloc.h ./alloc.h
3c3
< // $Id: alloc.h,v 1.2 2003/01/23 08:07:13 sdennis Exp $
---
> // $Id: alloc.h,v 1.3 2005/10/24 15:48:36 sdennis Exp $
18c18,20
< 
---
> #ifdef FIRANMUX
> #define LBUF_SIZE   16000   // Large
> #else
19a22
> #endif
Only in .: alloc.o
Only in .: artillery.o
Only in .: attrcache.o
diff /home/nick/sandbox/mux2.4.20/mux/src/autoconf.h ./autoconf.h
0a1,3
> /* autoconf.h.  Generated by configure.  */
> /* autoconf.h.in -- System-dependent configuration information */
> 
6,14d8
< #define _WIN32_WINNT 0x0400
< #define FD_SETSIZE      512
< #define WIN32_LEAN_AND_MEAN
< #include <windows.h>
< #include <winsock2.h>
< 
< #include <malloc.h>
< #include <crtdbg.h>
< 
23c17
< #define STDC_HEADERS
---
> #define STDC_HEADERS 1
25c19
< #undef HAVE_UNISTD_H
---
> #define HAVE_UNISTD_H 1
27c21,23
< #undef NEED_MEMORY_H
---
> /* #undef NEED_MEMORY_H */
> /* Decl for pid_t */
> /* #undef pid_t */
31c27
< #undef TM_IN_SYS_TIME
---
> /* #undef TM_IN_SYS_TIME */
33c29
< #undef HAVE_TM_ZONE
---
> #define HAVE_TM_ZONE 1
35c31
< #undef HAVE_TZNAME
---
> /* #undef HAVE_TZNAME */
37c33
< #undef HAVE_SETRLIMIT
---
> #define HAVE_SETRLIMIT 1
39c35
< #undef HAVE_GETRUSAGE
---
> #define HAVE_GETRUSAGE 1
41c37
< #undef HAVE_GETDTABLESIZE
---
> #define HAVE_GETDTABLESIZE 1
43c39
< #undef HAVE_GETPAGESIZE
---
> #define HAVE_GETPAGESIZE 1
45c41
< #undef HAVE_GETTIMEOFDAY
---
> #define HAVE_GETTIMEOFDAY 1
47c43
< #undef HAVE_USLEEP
---
> #define HAVE_USLEEP 1
49c45
< #undef HAVE_NANOSLEEP
---
> #define HAVE_NANOSLEEP 1
51c47
< #undef HAVE_SETITIMER
---
> #define HAVE_SETITIMER 1
53c49
< #undef SYS_SIGLIST_DECLARED
---
> /* #undef SYS_SIGLIST_DECLARED */
55c51
< #undef HAVE_SYS_SIGNAME
---
> /* #undef HAVE_SYS_SIGNAME */
57c53
< #undef INDEX_IN_STRING_H
---
> /* #undef INDEX_IN_STRING_H */
59c55
< #define MALLOC_IN_STDLIB_H
---
> #define MALLOC_IN_STDLIB_H 1
61c57
< #undef SIGNAL_SIGCHLD_BRAINDAMAGE
---
> /* #undef SIGNAL_SIGCHLD_BRAINDAMAGE */
63c59,63
< #define HAVE_ERRNO_H
---
> #define HAVE_ERRNO_H 1
> /* Define if malloc.h exists */
> #define HAVE_MALLOC_H 1
> /* Define if sys/wait.h exists */
> #define HAVE_SYS_WAIT_H 1
65c65
< #undef HAVE_SYS_SELECT_H
---
> #define HAVE_SYS_SELECT_H 1
67c67
< #undef HAVE_SYS_RUSAGE_H
---
> /* #undef HAVE_SYS_RUSAGE_H */
69c69
< #undef WORDS_BIGENDIAN
---
> /* #undef WORDS_BIGENDIAN */
73c73
< #undef WORDS_UNKNOWN
---
> /* #undef WORDS_UNKNOWN */
75c75
< #undef const
---
> /* #undef const */
89c89
< #define CAN_UNALIGN_SHORT
---
> #define CAN_UNALIGN_SHORT 1
91c91
< #define CAN_UNALIGN_INT
---
> #define CAN_UNALIGN_INT 1
93c93
< #define CAN_UNALIGN_LONG
---
> #define CAN_UNALIGN_LONG 1
95c95
< #define CAN_UNALIGN_LONGLONG
---
> #define CAN_UNALIGN_LONGLONG 1
97c97
< #undef inline
---
> /* #undef inline */
99c99
< #undef NEED_INDEX_DCL
---
> /* #undef NEED_INDEX_DCL */
101c101
< #undef NEED_MALLOC_DCL
---
> /* #undef NEED_MALLOC_DCL */
103c103
< #undef NEED_VSPRINTF_DCL
---
> /* #undef NEED_VSPRINTF_DCL */
105c105
< #undef NEED_SYS_ERRLIST_DCL
---
> /* #undef NEED_SYS_ERRLIST_DCL */
107c107
< #undef NEED_SYS__ERRLIST_DCL
---
> /* #undef NEED_SYS__ERRLIST_DCL */
109c109
< #undef NEED_SPRINTF_DCL
---
> /* #undef NEED_SPRINTF_DCL */
111c111
< #undef NEED_GETRLIMIT_DCL
---
> /* #undef NEED_GETRLIMIT_DCL */
113c113
< #undef NEED_GETRUSAGE_DCL
---
> /* #undef NEED_GETRUSAGE_DCL */
115c115
< #define HAVE_LINGER
---
> #define HAVE_LINGER 1
117c117
< #undef HAVE_STRUCT_SIGCONTEXT
---
> #define HAVE_STRUCT_SIGCONTEXT 1
119c119
< #define EXTENDED_STDIO_DCLS
---
> #define EXTENDED_STDIO_DCLS 1
121c121
< #undef EXTENDED_SOCKET_DCLS
---
> #define EXTENDED_SOCKET_DCLS 1
123c123
< #undef SOCKLEN_T_DCL
---
> #define SOCKLEN_T_DCL 1
125c125
< #undef TIME_WITH_SYS_TIME
---
> #define TIME_WITH_SYS_TIME 1
127c127
< #undef HAVE_SYS_TIME_H
---
> #define HAVE_SYS_TIME_H 1
129c129
< #undef NEED_GETTIMEOFDAY_DCL
---
> /* #undef NEED_GETTIMEOFDAY_DCL */
131c131
< #undef NEED_GETPAGESIZE_DCL
---
> /* #undef NEED_GETPAGESIZE_DCL */
133c133
< #define HAVE_IEEE_FP_FORMAT 1
---
> /* #undef HAVE_IEEE_FP_FORMAT */
135c135
< #define HAVE_IEEE_FP_SNAN 1
---
> /* #undef HAVE_IEEE_FP_SNAN */
141c141
< #undef HAVE_DEV_URANDOM
---
> #define HAVE_DEV_URANDOM 1
143c143
< #undef HAVE_FPU_CONTROL_H
---
> #define HAVE_FPU_CONTROL_H 1
145c145
< #undef HAVE_IEEEFP_H
---
> /* #undef HAVE_IEEEFP_H */
147c147
< #undef IEEEFP_H_USEABLE
---
> /* #undef IEEEFP_H_USEABLE */
149c149
< #undef HAVE_FENV_H
---
> #define HAVE_FENV_H 1
151c151
< #undef HAVE_FEGETPREC
---
> /* #undef HAVE_FEGETPREC */
153c153
< #undef HAVE_FESETPREC
---
> /* #undef HAVE_FESETPREC */
155c155,157
< #undef HAVE_IN_ADDR_T
---
> #define HAVE_IN_ADDR_T 1
> /* Define if fcntl.h exists */
> #define HAVE_FCNTL_H 1
159a162,165
> /* Define if pread exists */
> #define HAVE_PREAD 1
> /* Define if pwrite exists */
> #define HAVE_PWRITE 1
171,172c177,184
< #include <io.h>
< #include <fcntl.h>
---
> #ifndef _GNU_SOURCE
> #define _GNU_SOURCE
> #endif
> 
> #ifdef HAVE_UNISTD_H
> #include <unistd.h>
> #endif // HAVE_UNISTD_H
> 
176c188,192
< #include <process.h>
---
> 
> #ifdef NEED_MEMORY_H
> #include <memory.h>
> #endif
> 
177a194,287
> 
> #ifdef NEED_INDEX_DCL
> #define index           strchr
> #define rindex          strrchr
> #define bcopy(s,d,n)    memmove(d,s,n)
> #endif
> 
> #ifdef TIME_WITH_SYS_TIME
> #include <sys/time.h>
> #include <time.h>
> #else
> #ifdef HAVE_SYS_TIME_H
> #include <sys/time.h>
> #else
> #include <time.h>
> #endif
> #endif
> 
> #if defined(HAVE_SETRLIMIT) || defined(HAVE_GETRUSAGE)
> #include <sys/resource.h>
> #ifdef NEED_GETRUSAGE_DCL
> extern int      getrusage(int, struct rusage *);
> #endif
> #ifdef NEED_GETRLIMIT_DCL
> extern int      getrlimit(int, struct rlimit *);
> extern int      setrlimit(int, struct rlimit *);
> #endif
> #endif
> 
> #ifdef HAVE_SYS_FILE_H
> #include <sys/file.h>
> #endif
> 
> #ifdef HAVE_SYS_STAT_H
> #include <sys/stat.h>
> #endif
> 
> #ifdef HAVE_GETTIMEOFDAY
> #ifdef NEED_GETTIMEOFDAY_DCL
> extern int gettimeofday(struct timeval *, struct timezone *);
> #endif
> #endif
> 
> #ifdef HAVE_GETDTABLESIZE
> extern int getdtablesize(void);
> #endif
> 
> #ifdef HAVE_FCNTL_H
> #include <fcntl.h>
> #endif
> 
> #ifdef HAVE_SYS_WAIT_H
> #include <sys/wait.h>
> #endif
> 
> #ifdef HAVE_GETPAGESIZE
> 
> #ifdef NEED_GETPAGESIZE_DECL
> extern int getpagesize(void);
> #endif // NEED_GETPAGESIZE_DECL
> 
> #else // HAVE_GETPAGESIZE
> 
> #ifdef _SC_PAGESIZE
> #define getpagesize() sysconf(_SC_PAGESIZE)
> #else // _SC_PAGESIZE
> 
> #include <sys/param.h>
> 
> #ifdef EXEC_PAGESIZE
> #define getpagesize() EXEC_PAGESIZE
> #else // EXEC_PAGESIZE
> #ifdef NBPG
> #ifndef CLSIZE
> #define CLSIZE 1
> #endif // CLSIZE
> #define getpagesize() NBPG * CLSIZE
> #else // NBPG
> #ifdef PAGESIZE
> #define getpagesize() PAGESIZE
> #else // PAGESIZE
> #ifdef NBPC
> #define getpagesize() NBPC
> #else // NBPC
> #define getpagesize() 0
> #endif // NBPC
> #endif // PAGESIZE
> #endif // NBPG
> #endif // EXEC_PAGESIZE
> 
> #endif // _SC_PAGESIZE
> #endif // HAVE_GETPAGESIZE
> 
> #ifdef HAVE_ERRNO_H
178a289,308
> #else
> extern int errno;
> #endif
> 
> // Assure that malloc, realloc, and free are defined.
> //
> #if !defined(MALLOC_IN_STDLIB_H)
> #if   defined(HAVE_MALLOC_H)
> #include <malloc.h>
> #elif defined(NEED_MALLOC_DCL)
> extern char *malloc(int);
> extern char *realloc(char *, int);
> extern int   free(char *);
> #endif
> #endif
> 
> #ifdef NEED_SYS_ERRLIST_DCL
> extern char *sys_errlist[];
> #endif
> 
181c311
< #include <fcntl.h>
---
> #include <sys/fcntl.h>
183,187c313,315
< typedef int     dbref;
< typedef int     FLAG;
< typedef int     POWER;
< typedef char    boolexp_type;
< typedef char    IBUF[16];
---
> #ifdef NEED_SPRINTF_DCL
> extern char *sprintf(char *, const char *, ...);
> #endif
189c317,358
< #endif /* AUTOCONF_H */
---
> #ifndef EXTENDED_STDIO_DCLS
> extern int    fprintf(FILE *, const char *, ...);
> extern int    printf(const char *, ...);
> extern int    sscanf(const char *, const char *, ...);
> extern int    close(int);
> extern int    fclose(FILE *);
> extern int    fflush(FILE *);
> extern int    fgetc(FILE *);
> extern int    fputc(int, FILE *);
> extern int    fputs(const char *, FILE *);
> extern int    fread(void *, size_t, size_t, FILE *);
> extern int    fseek(FILE *, long, int);
> extern int    fwrite(void *, size_t, size_t, FILE *);
> extern pid_t  getpid(void);
> extern int    pclose(FILE *);
> extern int    rename(char *, char *);
> extern time_t time(time_t *);
> extern int    ungetc(int, FILE *);
> extern int    unlink(const char *);
> #endif
> 
> #include <sys/socket.h>
> #ifndef EXTENDED_SOCKET_DCLS
> extern int    accept(int, struct sockaddr *, int *);
> extern int    bind(int, struct sockaddr *, int);
> extern int    listen(int, int);
> extern int    sendto(int, void *, int, unsigned int,
>                     struct sockaddr *, int);
> extern int    setsockopt(int, int, int, void *, int);
> extern int    shutdown(int, int);
> extern int    socket(int, int, int);
> extern int    select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
> #endif
> 
> typedef int   dbref;
> typedef int   FLAG;
> typedef int   POWER;
> #ifdef REALITY_LVLS
> typedef unsigned int RLEVEL;
> #endif /* REALITY_LVLS */
> typedef char  boolexp_type;
> typedef char  IBUF[16];
190a360
> #endif /* AUTOCONF_H */
Only in .: autogun.o
Only in .: autopilot.o
Only in .: autopilot_command.o
Only in .: autopilot_commands.o
Only in .: boolexp.o
diff /home/nick/sandbox/mux2.4.20/mux/src/bsd.cpp ./bsd.cpp
3c3
< // $Id: bsd.cpp,v 1.51 2005/10/15 06:24:25 sdennis Exp $
---
> // $Id: bsd.cpp,v 1.52 2005/10/21 03:36:01 sdennis Exp $
2844a2845,2846
> void pcache_sync(void);
> 
2921a2924
>                         local_dump_complete_signal();
2932a2936
>                         local_dump_complete_signal();
3023a3028,3033
> 
>         local_presync_database_sigsegv();
> #ifndef MEMORY_BASED
>         al_store();
> #endif
>         pcache_sync();
3024a3035
> 
Only in .: bsd.o
Only in .: bsuit.o
Only in .: btech
Only in .: btech.o
Only in .: btechstats.o
Only in .: btspath.o
Only in .: buildnum.data
diff /home/nick/sandbox/mux2.4.20/mux/src/command.cpp ./command.cpp
3c3
< // $Id: command.cpp,v 1.55 2005/10/12 05:36:21 sdennis Exp $
---
> // $Id: command.cpp,v 1.62 2005/10/25 05:46:30 sdennis Exp $
78c78
<     {"parent",          2,  CA_PUBLIC,  CLONE_PARENT|SW_MULTIPLE},
---
>     {"parent",          2,  CA_PUBLIC,  CLONE_FROM_PARENT|SW_MULTIPLE},
763c763,847
< void init_cmdtab(void)
---
> void commands_no_arg_add(CMDENT_NO_ARG cmdent[])
> {
>     CMDENT_NO_ARG *cp0a;
>     for (cp0a = cmdent; cp0a->cmdname; cp0a++)
>     {
>         if (!hashfindLEN(cp0a->cmdname, strlen(cp0a->cmdname),
>                          &mudstate.command_htab))
>         {
>             hashaddLEN(cp0a->cmdname, strlen(cp0a->cmdname), cp0a,
>                        &mudstate.command_htab);
>         }
>     }
> }
> 
> void commands_one_arg_add(CMDENT_ONE_ARG cmdent[])
> {
>     CMDENT_ONE_ARG *cp1a;
>     for (cp1a = cmdent; cp1a->cmdname; cp1a++)
>     {
>         if (!hashfindLEN(cp1a->cmdname, strlen(cp1a->cmdname),
>                         &mudstate.command_htab))
>         {
>             hashaddLEN(cp1a->cmdname, strlen(cp1a->cmdname), cp1a,
>                        &mudstate.command_htab);
>         }
>     }
> }
> 
> void commands_one_arg_cmdarg_add(CMDENT_ONE_ARG_CMDARG cmdent[])
> {
>     CMDENT_ONE_ARG_CMDARG *cp1ac;
>     for (cp1ac = cmdent; cp1ac->cmdname; cp1ac++)
>     {
>         if (!hashfindLEN(cp1ac->cmdname, strlen(cp1ac->cmdname),
>                          &mudstate.command_htab))
>         {
>             hashaddLEN(cp1ac->cmdname, strlen(cp1ac->cmdname), cp1ac,
>                        &mudstate.command_htab);
>         }
>     }
> }
> 
> void commands_two_arg_add(CMDENT_TWO_ARG cmdent[])
> {
>     CMDENT_TWO_ARG *cp2a;
>     for (cp2a = cmdent; cp2a->cmdname; cp2a++)
>     {
>         if (!hashfindLEN(cp2a->cmdname, strlen(cp2a->cmdname),
>                          &mudstate.command_htab))
>         {
>             hashaddLEN(cp2a->cmdname, strlen(cp2a->cmdname), cp2a,
>                        &mudstate.command_htab);
>         }
>     }
> }
> 
> void commands_two_arg_argv_add(CMDENT_TWO_ARG_ARGV cmdent[])
> {
>     CMDENT_TWO_ARG_ARGV *cp2aa;
>     for (cp2aa = cmdent; cp2aa->cmdname; cp2aa++)
>     {
>         if (!hashfindLEN(cp2aa->cmdname, strlen(cp2aa->cmdname),
>                          &mudstate.command_htab))
>         {
>             hashaddLEN(cp2aa->cmdname, strlen(cp2aa->cmdname), cp2aa,
>                        &mudstate.command_htab);
>         }
>     }
> }
> 
> void commands_two_arg_cmdarg_add(CMDENT_TWO_ARG_CMDARG cmdent[])
> {
>     CMDENT_TWO_ARG_CMDARG  *cp2ac;
>     for (cp2ac = cmdent; cp2ac->cmdname; cp2ac++)
>     {
>         if (!hashfindLEN(cp2ac->cmdname, strlen(cp2ac->cmdname),
>                          &mudstate.command_htab))
>         {
>             hashaddLEN(cp2ac->cmdname, strlen(cp2ac->cmdname), cp2ac,
>                        &mudstate.command_htab);
>         }
>     }
> }
> 
> void commands_two_arg_argv_cmdarg_add(CMDENT_TWO_ARG_ARGV_CMDARG cmdent[])
765,770d848
<     CMDENT_NO_ARG               *cp0a;
<     CMDENT_ONE_ARG              *cp1a;
<     CMDENT_ONE_ARG_CMDARG       *cp1ac;
<     CMDENT_TWO_ARG              *cp2a;
<     CMDENT_TWO_ARG_ARGV         *cp2aa;
<     CMDENT_TWO_ARG_CMDARG       *cp2ac;
771a850,859
>     for (cp2aac = cmdent; cp2aac->cmdname; cp2aac++)
>     {
>         if (!hashfindLEN(cp2aac->cmdname, strlen(cp2aac->cmdname),
>                          &mudstate.command_htab))
>         {
>             hashaddLEN(cp2aac->cmdname, strlen(cp2aac->cmdname), cp2aac,
>                        &mudstate.command_htab);
>         }
>     }
> }
772a861,862
> void init_cmdtab(void)
> {
791a882
>         CMDENT_TWO_ARG *cp2a;
810,829c901,907
<     for (cp0a = command_table_no_arg; cp0a->cmdname; cp0a++)
<         hashaddLEN(cp0a->cmdname, strlen(cp0a->cmdname), cp0a, &mudstate.command_htab);
< 
<     for (cp1a = command_table_one_arg; cp1a->cmdname; cp1a++)
<         hashaddLEN(cp1a->cmdname, strlen(cp1a->cmdname), cp1a, &mudstate.command_htab);
< 
<     for (cp1ac = command_table_one_arg_cmdarg; cp1ac->cmdname; cp1ac++)
<         hashaddLEN(cp1ac->cmdname, strlen(cp1ac->cmdname), cp1ac, &mudstate.command_htab);
< 
<     for (cp2a = command_table_two_arg; cp2a->cmdname; cp2a++)
<         hashaddLEN(cp2a->cmdname, strlen(cp2a->cmdname), cp2a, &mudstate.command_htab);
< 
<     for (cp2aa = command_table_two_arg_argv; cp2aa->cmdname; cp2aa++)
<         hashaddLEN(cp2aa->cmdname, strlen(cp2aa->cmdname), cp2aa, &mudstate.command_htab);
< 
<     for (cp2ac = command_table_two_arg_cmdarg; cp2ac->cmdname; cp2ac++)
<         hashaddLEN(cp2ac->cmdname, strlen(cp2ac->cmdname), cp2ac, &mudstate.command_htab);
< 
<     for (cp2aac = command_table_two_arg_argv_cmdarg; cp2aac->cmdname; cp2aac++)
<         hashaddLEN(cp2aac->cmdname, strlen(cp2aac->cmdname), cp2aac, &mudstate.command_htab);
---
>     commands_no_arg_add(command_table_no_arg);
>     commands_one_arg_add(command_table_one_arg);
>     commands_one_arg_cmdarg_add(command_table_one_arg_cmdarg);
>     commands_two_arg_add(command_table_two_arg);
>     commands_two_arg_argv_add(command_table_two_arg_argv);
>     commands_two_arg_cmdarg_add(command_table_two_arg_cmdarg);
>     commands_two_arg_argv_cmdarg_add(command_table_two_arg_argv_cmdarg);
1749a1828,1831
>     // btech stuff
>     if(local_handled_command(executor, pCommand)) 
>         return preserve_cmd;
> 
2858d2939
<                 free_sbuf(buff);
2947,2966c3028,3045
<         // Got it, create the new command table entry.
<         //
<         cmd2 = (CMDENT *)MEMALLOC(sizeof(CMDENT));
<         ISOUTOFMEMORY(cmd2);
<         cmd2->cmdname = StringClone(alias);
<         cmd2->switches = cmdp->switches;
<         cmd2->perms = cmdp->perms | nt->perm;
<         cmd2->extra = (cmdp->extra | nt->flag) & ~SW_MULTIPLE;
<         if (!(nt->flag & SW_MULTIPLE))
<         {
<             cmd2->extra |= SW_GOT_UNIQUE;
<         }
<         cmd2->callseq = cmdp->callseq;
<         cmd2->handler = cmdp->handler;
<         if (hashaddLEN(cmd2->cmdname, strlen(cmd2->cmdname), cmd2, (CHashTable *) vp))
<         {
<             MEMFREE(cmd2->cmdname);
<             cmd2->cmdname = NULL;
<             MEMFREE(cmd2);
<             cmd2 = NULL;
---
>         if (!hashfindLEN(alias, strlen(alias), (CHashTable *)vp))
>         {
>             // Create the new command table entry.
>             //
>             cmd2 = (CMDENT *)MEMALLOC(sizeof(CMDENT));
>             ISOUTOFMEMORY(cmd2);
>             cmd2->cmdname = StringClone(alias);
>             cmd2->switches = cmdp->switches;
>             cmd2->perms = cmdp->perms | nt->perm;
>             cmd2->extra = (cmdp->extra | nt->flag) & ~SW_MULTIPLE;
>             if (!(nt->flag & SW_MULTIPLE))
>             {
>                 cmd2->extra |= SW_GOT_UNIQUE;
>             }
>             cmd2->callseq = cmdp->callseq;
>             cmd2->handler = cmdp->handler;
> 
>             hashaddLEN(cmd2->cmdname, strlen(cmd2->cmdname), cmd2, (CHashTable *) vp);
diff /home/nick/sandbox/mux2.4.20/mux/src/command.h ./command.h
3c3
< // $Id: command.h,v 1.7 2005/10/12 05:36:21 sdennis Exp $
---
> // $Id: command.h,v 1.8 2005/10/17 06:13:05 sdennis Exp $
256a257,264
> void commands_no_arg_add(CMDENT_NO_ARG cmdent[]);
> void commands_one_arg_add(CMDENT_ONE_ARG cmdent[]);
> void commands_one_arg_cmdarg_add(CMDENT_ONE_ARG_CMDARG cmdent[]);
> void commands_two_arg_add(CMDENT_TWO_ARG cmdent[]);
> void commands_two_arg_cmdarg_add(CMDENT_TWO_ARG_CMDARG cmdent[]);
> void commands_two_arg_argv_add(CMDENT_TWO_ARG_ARGV cmdent[]);
> void commands_two_arg_argv_cmdarg_add(CMDENT_TWO_ARG_ARGV_CMDARG cmdent[]);
> 
Only in .: command.o
diff /home/nick/sandbox/mux2.4.20/mux/src/comsys.cpp ./comsys.cpp
3c3
< // $Id: comsys.cpp,v 1.37 2005/10/12 05:36:21 sdennis Exp $
---
> // $Id: comsys.cpp,v 1.38 2005/10/16 03:01:21 sdennis Exp $
1014c1014
<     else if (!do_test_access(player, CHANNEL_TRANSMIT, ch))
---
>     else if (!test_transmit_access(player, ch))
1043,1049c1043
< void SendChannelMessage
< (
<     dbref executor,
<     struct channel *ch,
<     char *msgNormal,
<     char *msgNoComtitle
< )
---
> void SendChannelMessage(dbref executor, struct channel *ch, char *msgNormal, char *msgNoComtitle)
1058c1052
<            && do_test_access(user->who, CHANNEL_RECEIVE, ch))
---
>            && test_receive_access(user->who, ch))
1111c1105
<     if (msgNormal)
---
> /*    if (msgNormal)
1115,1116c1109
<     if (  msgNoComtitle
<        && msgNoComtitle != msgNormal)
---
>     if (  msgNoComtitle && msgNoComtitle != msgNormal)
1119c1112
<     }
---
>     } */
1506c1499
<     if (!do_test_access(executor, CHANNEL_JOIN, ch))
---
>     if (!test_join_access(executor, ch))
1817c1810
<                 if (!do_test_access(user->who, CHANNEL_JOIN, ch))
---
>                 if (!test_join_access(user->who, ch))
1912,1914c1905,1907
<                 (ch->type & (CHANNEL_PUBLIC)) ? 'P' : '-',
<                 (ch->type & (CHANNEL_LOUD)) ? 'L' : '-',
<                 (ch->type & (CHANNEL_SPOOF)) ? 'S' : '-',
---
>                 (ch->type & CHANNEL_PUBLIC) ? 'P' : '-',
>                 (ch->type & CHANNEL_LOUD) ? 'L' : '-',
>                 (ch->type & CHANNEL_SPOOF) ? 'S' : '-',
1916,1921c1909,1914
<                 (ch->type & (CHANNEL_PL_MULT * CHANNEL_JOIN)) ? 'J' : '-',
<                 (ch->type & (CHANNEL_PL_MULT * CHANNEL_TRANSMIT)) ? 'X' : '-',
<                 (ch->type & (CHANNEL_PL_MULT * CHANNEL_RECEIVE)) ? 'R' : '-',
<                 (ch->type & (CHANNEL_OBJ_MULT * CHANNEL_JOIN)) ? 'j' : '-',
<                 (ch->type & (CHANNEL_OBJ_MULT * CHANNEL_TRANSMIT)) ? 'x' : '-',
<                 (ch->type & (CHANNEL_OBJ_MULT * CHANNEL_RECEIVE)) ? 'r' : '-',
---
>                 (ch->type & CHANNEL_PLAYER_JOIN) ? 'J' : '-',
>                 (ch->type & CHANNEL_PLAYER_TRANSMIT) ? 'X' : '-',
>                 (ch->type & CHANNEL_PLAYER_RECEIVE) ? 'R' : '-',
>                 (ch->type & CHANNEL_OBJECT_JOIN) ? 'j' : '-',
>                 (ch->type & CHANNEL_OBJECT_TRANSMIT) ? 'x' : '-',
>                 (ch->type & CHANNEL_OBJECT_RECEIVE) ? 'r' : '-',
2422d2414
<         if (strcmp(s, "join") == 0)
2424c2416,2417
<             if (add_remove)
---
>             int access = 0;
>             if (strcmp(s, "join") == 0)
2426,2427c2419
<                 ch->type |= (CHANNEL_PL_MULT * CHANNEL_JOIN);
<                 raw_notify(executor, "@cpflags: Set.");
---
>                 access = CHANNEL_PLAYER_JOIN;
2429c2421
<             else
---
>             else if (strcmp(s, "receive") == 0)
2431,2432c2423
<                 ch->type &= ~(CHANNEL_PL_MULT * CHANNEL_JOIN);
<                 raw_notify(executor, "@cpflags: Cleared.");
---
>                 access = CHANNEL_PLAYER_RECEIVE;
2434,2437c2425
<         }
<         else if (strcmp(s, "receive") == 0)
<         {
<             if (add_remove)
---
>             else if (strcmp(s, "transmit") == 0)
2439,2440c2427
<                 ch->type |= (CHANNEL_PL_MULT * CHANNEL_RECEIVE);
<                 raw_notify(executor, "@cpflags: Set.");
---
>                 access = CHANNEL_PLAYER_TRANSMIT;
2444,2453c2431
<                 ch->type &= ~(CHANNEL_PL_MULT * CHANNEL_RECEIVE);
<                 raw_notify(executor, "@cpflags: Cleared.");
<             }
<         }
<         else if (strcmp(s, "transmit") == 0)
<         {
<             if (add_remove)
<             {
<                 ch->type |= (CHANNEL_PL_MULT * CHANNEL_TRANSMIT);
<                 raw_notify(executor, "@cpflags: Set.");
---
>                 raw_notify(executor, "@cpflags: Unknown Flag.");
2455c2433,2434
<             else
---
> 
>             if (access)
2457,2458c2436,2445
<                 ch->type &= ~(CHANNEL_PL_MULT * CHANNEL_TRANSMIT);
<                 raw_notify(executor, "@cpflags: Cleared.");
---
>                 if (add_remove)
>                 {
>                     ch->type |= access;
>                     raw_notify(executor, "@cpflags: Set.");
>                 }
>                 else
>                 {
>                     ch->type &= ~access;
>                     raw_notify(executor, "@cpflags: Cleared.");
>                 }
2461,2464d2447
<         else
<         {
<             raw_notify(executor, "@cpflags: Unknown Flag.");
<         }
2468d2450
<         if (strcmp(s, "join") == 0)
2470c2452,2453
<             if (add_remove)
---
>             int access = 0;
>             if (strcmp(s, "join") == 0)
2472,2473c2455
<                 ch->type |= (CHANNEL_OBJ_MULT * CHANNEL_JOIN);
<                 raw_notify(executor, "@coflags: Set.");
---
>                 access = CHANNEL_OBJECT_JOIN;
2475c2457
<             else
---
>             else if (strcmp(s, "receive") == 0)
2477,2478c2459
<                 ch->type &= ~(CHANNEL_OBJ_MULT * CHANNEL_JOIN);
<                 raw_notify(executor, "@coflags: Cleared.");
---
>                 access = CHANNEL_OBJECT_RECEIVE;
2480,2483c2461
<         }
<         else if (strcmp(s, "receive") == 0)
<         {
<             if (add_remove)
---
>             else if (strcmp(s, "transmit") == 0)
2485,2486c2463
<                 ch->type |= (CHANNEL_OBJ_MULT * CHANNEL_RECEIVE);
<                 raw_notify(executor, "@coflags: Set.");
---
>                 access = CHANNEL_OBJECT_TRANSMIT;
2490,2491c2467
<                 ch->type &= ~(CHANNEL_OBJ_MULT * CHANNEL_RECEIVE);
<                 raw_notify(executor, "@coflags: Cleared.");
---
>                 raw_notify(executor, "@coflags: Unknown Flag.");
2493,2501c2469,2470
<         }
<         else if (strcmp(s, "transmit") == 0)
<         {
<             if (add_remove)
<             {
<                 ch->type |= (CHANNEL_OBJ_MULT * CHANNEL_TRANSMIT);
<                 raw_notify(executor, "@coflags: Set.");
<             }
<             else
---
> 
>             if (access)
2503,2504c2472,2481
<                 ch->type &= ~(CHANNEL_OBJ_MULT * CHANNEL_TRANSMIT);
<                 raw_notify(executor, "@coflags: Cleared.");
---
>                 if (add_remove)
>                 {
>                     ch->type |= access;
>                     raw_notify(executor, "@coflags: Set.");
>                 }
>                 else
>                 {
>                     ch->type &= ~access;
>                     raw_notify(executor, "@coflags: Cleared.");
>                 }
2507,2510d2483
<         else
<         {
<             raw_notify(executor, "@coflags: Unknown Flag.");
<         }
2515c2488
< bool do_test_access(dbref player, long access, struct channel *chan)
---
> bool test_join_access(dbref player, struct channel *chan)
2522,2532c2495,2496
<     // Channel objects allow custom locks for channels.  The normal
<     // lock is used to see if they can join that channel. The enterlock
<     // is checked to see if they can receive messages on it. The
<     // Uselock is checked to see if they can transmit on it. Note:
<     // These checks do not supercede the normal channel flags. If a
<     // channel is set JOIN for players, ALL players can join the
<     // channel, whether or not they pass the lock.  Same for all
<     // channel object locks.
<     //
<     long flag_value = access;
<     if (chan->chan_obj != NOTHING && chan->chan_obj != 0)
---
>     int access;
>     if (isPlayer(player))
2534,2548c2498,2502
<         if (flag_value & CHANNEL_JOIN)
<         {
<             if (could_doit(player, chan->chan_obj, A_LOCK))
<                 return true;
<         }
<         if (flag_value & CHANNEL_TRANSMIT)
<         {
<             if (could_doit(player, chan->chan_obj, A_LUSE))
<                 return true;
<         }
<         if (flag_value & CHANNEL_RECEIVE)
<         {
<             if (could_doit(player, chan->chan_obj, A_LENTER))
<                 return true;
<         }
---
>         access = CHANNEL_PLAYER_JOIN;
>     }
>     else
>     {
>         access = CHANNEL_OBJECT_JOIN;
2549a2504,2506
>     return (  (chan->type & access) != 0
>            || could_doit(player, chan->chan_obj, A_LOCK));
> }
2550a2508,2515
> bool test_transmit_access(dbref player, struct channel *chan)
> {
>     if (Comm_All(player))
>     {
>         return true;
>     }
> 
>     int access;
2553c2518
<         flag_value *= CHANNEL_PL_MULT;
---
>         access = CHANNEL_PLAYER_TRANSMIT;
2557c2522
<         flag_value *= CHANNEL_OBJ_MULT;
---
>         access = CHANNEL_OBJECT_TRANSMIT;
2558a2524,2525
>     return (  (chan->type & access) != 0
>            || could_doit(player, chan->chan_obj, A_LUSE));
2560,2562c2527,2546
<     // Mask out CHANNEL_PUBLIC, CHANNEL_LOUD, and CHANNEL_SPOOF
<     //
<     flag_value &= 0xFF;
---
> }
> 
> bool test_receive_access(dbref player, struct channel *chan)
> {
>     if (Comm_All(player))
>     {
>         return true;
>     }
> 
>     int access;
>     if (isPlayer(player))
>     {
>         access = CHANNEL_PLAYER_RECEIVE;
>     }
>     else
>     {
>         access = CHANNEL_OBJECT_RECEIVE;
>     }
>     return (  (chan->type & access) != 0
>            || could_doit(player, chan->chan_obj, A_LENTER));
2564d2547
<     return (((long)chan->type & flag_value) ? true : false);
diff /home/nick/sandbox/mux2.4.20/mux/src/comsys.h ./comsys.h
3c3
< // $Id: comsys.h,v 1.3 2005/08/11 21:38:46 ian Exp $
---
> // $Id: comsys.h,v 1.4 2005/10/16 03:01:21 sdennis Exp $
67c67,69
< bool do_test_access(dbref player, long access, struct channel *chan);
---
> bool test_join_access(dbref player, struct channel *chan);
> bool test_transmit_access(dbref player, struct channel *chan);
> bool test_receive_access(dbref player, struct channel *chan);
119,128c121,129
< #define CHANNEL_JOIN      0x1
< #define CHANNEL_TRANSMIT  0x2
< #define CHANNEL_RECEIVE   0x4
< 
< #define CHANNEL_PL_MULT   0x001 // See JOIN, TRANSMIT, RECEIVE
< #define CHANNEL_OBJ_MULT  0x010 // See JOIN, TRANSMIT, RECEIVE
< #define CHANNEL_LOUD      0x100
< #define CHANNEL_PUBLIC    0x200
< #define CHANNEL_SPOOF     0x400
< 
---
> #define CHANNEL_PLAYER_JOIN     (0x00000001UL)
> #define CHANNEL_PLAYER_TRANSMIT (0x00000002UL)
> #define CHANNEL_PLAYER_RECEIVE  (0x00000004UL)
> #define CHANNEL_OBJECT_JOIN     (0x00000010UL)
> #define CHANNEL_OBJECT_TRANSMIT (0x00000020UL)
> #define CHANNEL_OBJECT_RECEIVE  (0x00000040UL)
> #define CHANNEL_LOUD            (0x00000100UL)
> #define CHANNEL_PUBLIC          (0x00000200UL)
> #define CHANNEL_SPOOF           (0x00000400UL)
Only in .: comsys.o
diff /home/nick/sandbox/mux2.4.20/mux/src/conf.cpp ./conf.cpp
3c3
< // $Id: conf.cpp,v 1.60 2005/10/12 05:34:32 sdennis Exp $
---
> // $Id: conf.cpp,v 1.64 2005/10/27 05:09:06 sdennis Exp $
702c702,705
<         hashaddLEN(alias, strlen(alias), cp, (CHashTable *) vp);
---
>         if (!hashfindLEN(alias, strlen(alias), (CHashTable *) vp))
>         {
>             hashaddLEN(alias, strlen(alias), cp, (CHashTable *) vp);
>         }
730,731c733,737
<             hashaddLEN(pName, nName, cp, &mudstate.flags_htab);
<             success = true;
---
>             if (!hashfindLEN(pName, nName, &mudstate.flags_htab))
>             {
>                 hashaddLEN(pName, nName, cp, &mudstate.flags_htab);
>                 success = true;
>             }
1385c1391,1392
<             if (tp->flags & CA_STATIC)
---
>             if (  tp->flags & CA_STATIC
>                && !mudstate.bReadingConfiguration)
Only in .: conf.o
Only in .: config.log
Only in .: config.status
Only in .: coolmenu.o
diff /home/nick/sandbox/mux2.4.20/mux/src/copyright.h ./copyright.h
3c3
< /* $Id: copyright.h,v 1.7 2004/12/24 15:22:58 sdennis Exp $ */
---
> /* $Id: copyright.h,v 1.8 2005/10/28 01:29:32 sdennis Exp $ */
8c8
<  * Contact: Stephen Dennis
---
>  * Copyright (C) 2005 Stephen Dennis
26d25
<  *
36d34
<  *
53d50
<  *
208d204
<  *
diff /home/nick/sandbox/mux2.4.20/mux/src/cque.cpp ./cque.cpp
3c3
< // $Id: cque.cpp,v 1.29 2005/10/14 17:34:09 sdennis Exp $
---
> // $Id: cque.cpp,v 1.30 2005/10/30 00:01:55 sdennis Exp $
676a677,678
>         a_Queue(Owner(executor), -1);
> 
Only in .: cque.o
diff /home/nick/sandbox/mux2.4.20/mux/src/create.cpp ./create.cpp
3c3
< // $Id: create.cpp,v 1.16 2005/10/12 05:32:44 sdennis Exp $
---
> // $Id: create.cpp,v 1.17 2005/10/19 23:52:39 sdennis Exp $
615c615
<        && (key & CLONE_PARENT))
---
>        && (key & CLONE_FROM_PARENT))
620c620
<         key &= ~CLONE_PARENT;
---
>         key &= ~CLONE_FROM_PARENT;
683c683
<     if (key & CLONE_PARENT)
---
>     if (key & CLONE_FROM_PARENT)
759c759
<         if (!(key & CLONE_PARENT))
---
>         if (!(key & CLONE_FROM_PARENT))
768c768
<         if (  !(key & CLONE_PARENT)
---
>         if (  !(key & CLONE_FROM_PARENT)
Only in .: create.o
Only in .: crit.o
Common subdirectories: /home/nick/sandbox/mux2.4.20/mux/src/crypt and ./crypt
diff /home/nick/sandbox/mux2.4.20/mux/src/db.cpp ./db.cpp
3c3
< // $Id: db.cpp,v 1.59 2005/10/12 05:30:31 sdennis Exp $
---
> // $Id: db.cpp,v 1.64 2005/10/24 15:47:44 sdennis Exp $
1340,1343c1340,1353
<     char *s, *as, c;
<     int atr, aflags;
<     dbref aowner;
<     ATTR *ap;
---
>     if (mudstate.bfNoCommands.IsSet(thing))
>     {
>         // We already know that there are no commands on this thing.
>         //
>         return false;
>     }
>     else if (mudstate.bfCommands.IsSet(thing))
>     {
>         // We already know that there are definitely commands on this thing.
>         //
>         return true;
>     }
> 
>     bool bFoundListens = false;
1344a1355
>     char *as;
1346c1357,1358
<     for (atr = atr_head(thing, &as); atr; atr = atr_next(&as))
---
>     char *buff = alloc_lbuf("Commer");
>     for (int atr = atr_head(thing, &as); atr; atr = atr_next(&as))
1348,1349c1360,1387
<         ap = atr_num(atr);
<         if (!ap || (ap->flags & AF_NOPROG))
---
>         ATTR *ap = atr_num(atr);
>         if (  !ap
>            || (ap->flags & AF_NOPROG))
>         {
>             continue;
>         }
> 
>         int   aflags;
>         dbref aowner;
> 
>         atr_get_str(buff, thing, atr, &aowner, &aflags);
> 
>         if (aflags & AF_NOPROG)
>         {
>             continue;
>         }
> 
>         if (  AMATCH_CMD != buff[0]
>            && AMATCH_LISTEN != buff[0])
>         {
>             continue;
>         }
> 
>         // Search for unescaped ':'
>         //
>         char *s = strchr(buff+1, ':');
>         if (!s)
>         {
1350a1389
>         }
1352,1355c1391
<         s = atr_get(thing, atr, &aowner, &aflags);
<         c = *s;
<         free_lbuf(s);
<         if ((c == '$') && !(aflags & AF_NOPROG))
---
>         if (AMATCH_CMD == buff[0])
1356a1393
>             free_lbuf(buff);
1357a1395,1400
>             mudstate.bfCommands.Set(thing);
>             if (bFoundListens)
>             {
>                 mudstate.bfListens.Set(thing);
>                 mudstate.bfNoListens.Clear(thing);
>             }
1359a1403,1406
>         else // AMATCH_LISTEN == buff[0]
>         {
>             bFoundListens = true;
>         }
1360a1408
>     free_lbuf(buff);
1361a1410,1420
>     mudstate.bfNoCommands.Set(thing);
>     if (bFoundListens)
>     {
>         mudstate.bfListens.Set(thing);
>         mudstate.bfNoListens.Clear(thing);
>     }
>     else
>     {
>         mudstate.bfNoListens.Set(thing);
>         mudstate.bfListens.Clear(thing);
>     }
1707a1767
> 
1744a1805,1813
> 
>     default:
> 
>         // Since this could overwrite an existing ^-Command or $-Command, we
>         // longer assert that the object has one.
>         //
>         mudstate.bfListens.Clear(thing);
>         mudstate.bfCommands.Clear(thing);
>         break;
1754,1755d1822
< #ifdef MEMORY_BASED
< 
1762,1765c1829
<     if (nValue > LBUF_SIZE-1)
<     {
<         nValue = LBUF_SIZE-1;
<     }
---
> #ifdef MEMORY_BASED
1843,1844d1906
< #else // MEMORY_BASED
<     Aname okey;
1846,1852c1908
<     makekey(thing, atr, &okey);
<     if (!szValue || szValue[0] == '\0')
<     {
<         cache_del(&okey);
<         al_delete(thing, atr);
<         return;
<     }
---
> #else // MEMORY_BASED
1858a1915,1916
>     Aname okey;
>     makekey(thing, atr, &okey);
1923a1982,2006
>         switch (buff[0])
>         {
>         case AMATCH_LISTEN:
> 
>             // Since this could be a ^-Command, we no longer assert that the
>             // object has none.
>             //
>             mudstate.bfNoListens.Clear(thing);
>             break;
> 
>         case AMATCH_CMD:
> 
>             // Since this could be a $-Command, we no longer assert that the
>             // object has none.
>             //
>             mudstate.bfNoCommands.Clear(thing);
>             break;
>         }
> 
>         // Since this could overwrite an existing ^-Command or $-Command, we
>         // longer assert that the object has one.
>         //
>         mudstate.bfListens.Clear(thing);
>         mudstate.bfCommands.Clear(thing);
> 
2166d2248
<     int atr;
2169c2251
<     for (atr = atr_head(thing, &as); atr; atr = atr_next(&as))
---
>     for (int atr = atr_head(thing, &as); atr; atr = atr_next(&as))
2179a2262,2266
> 
>     mudstate.bfCommands.Clear(thing);
>     mudstate.bfNoCommands.Set(thing);
>     mudstate.bfListens.Clear(thing);
>     mudstate.bfNoListens.Set(thing);
2188,2192d2274
<     int atr, aflags;
<     dbref aowner;
<     char *as, *buf;
<     ATTR *at;
< 
2193a2276,2277
> 
>     char *as;
2195c2279
<     for (atr = atr_head(source, &as); atr; atr = atr_next(&as))
---
>     for (int atr = atr_head(source, &as); atr; atr = atr_next(&as))
2197c2281,2284
<         buf = atr_get(source, atr, &aowner, &aflags);
---
>         int   aflags;
>         dbref aowner;
>         char *buf = atr_get(source, atr, &aowner, &aflags);
> 
2204c2291,2292
<         at = atr_num(atr);
---
> 
>         ATTR *at = atr_num(atr);
2235,2238d2322
<     int atr, aflags;
<     dbref aowner;
<     char *as, *buf;
< 
2239a2324,2325
> 
>     char *as;
2241c2327
<     for (atr = atr_head(obj, &as); atr; atr = atr_next(&as))
---
>     for (int atr = atr_head(obj, &as); atr; atr = atr_next(&as))
2243c2329,2331
<         buf = atr_get(obj, atr, &aowner, &aflags);
---
>         int   aflags;
>         dbref aowner;
>         char *buf = atr_get(obj, atr, &aowner, &aflags);
2428a2517,2521
>     mudstate.bfCommands.Resize(newtop);
>     mudstate.bfNoCommands.Resize(newtop);
>     mudstate.bfListens.Resize(newtop);
>     mudstate.bfNoListens.Resize(newtop);
> 
Only in .: db.o
Only in .: db_rw.o
Only in .: debug.o
Only in .: ds.bay.o
Only in .: ds.turret.o
Only in .: econ.o
Only in .: econ_cmds.o
Only in .: eject.o
Only in .: eval.o
Only in .: event.o
Only in .: events.o
diff /home/nick/sandbox/mux2.4.20/mux/src/externs.h ./externs.h
3c3
< // $Id: externs.h,v 1.40 2005/10/12 05:30:31 sdennis Exp $
---
> // $Id: externs.h,v 1.46 2005/10/22 16:21:47 sdennis Exp $
23a24,25
> extern void local_presync_database(void);
> extern void local_presync_database_sigsegv(void);
24a27
> extern void local_dump_complete_signal(void);
31a35,37
> // added btech stuff
> extern int local_handled_flag(dbref target, dbref player, FLAG flag, int fflags, bool reset);
> extern int local_handled_command(dbref executor, char *pCommand);
145a152
> extern void DCL_CDECL log_printf(const char *fmt, ...);
235c242
< extern bool xlate(char *);
---
> bool xlate(char *);
343c350
< #define CLONE_PARENT    64  /* Set parent on obj instd of cloning attrs */
---
> #define CLONE_FROM_PARENT 64 /* Set parent on obj instd of cloning attrs */
Only in .: failures.o
Only in .: file_c.o
diff /home/nick/sandbox/mux2.4.20/mux/src/flags.cpp ./flags.cpp
3c3
< // $Id: flags.cpp,v 1.20 2005/10/12 04:36:40 sdennis Exp $
---
> // $Id: flags.cpp,v 1.22 2005/10/28 06:03:47 sdennis Exp $
105c105
<     return fh_any(target, player, flag, fflags, reset);
---
>     return (fh_any(target, player, flag, fflags, reset));
132c132
<     return fh_any(target, player, flag, fflags, reset);
---
>     return (fh_any(target, player, flag, fflags, reset));
164c164
<     return fh_any(target, player, flag, fflags, reset);
---
>     return (fh_any(target, player, flag, fflags, reset));
179c179
<         return fh_any(target, player, flag, fflags, reset);
---
>         return (fh_any(target, player, flag, fflags, reset));
198c198
<     return fh_any(target, player, flag, fflags, reset);
---
>     return (fh_any(target, player, flag, fflags, reset));
212c212
<             fh_any(target, player, flag, fflags, reset);
---
>             return (fh_any(target, player, flag, fflags, reset));
221c221
<     fh_any(target, player, flag, fflags, reset);
---
>     bool result = fh_any(target, player, flag, fflags, reset);
223c223
<     return true;
---
>     return result;
243c243
<     return fh_any(target, player, flag, fflags, reset);
---
>     return (fh_any(target, player, flag, fflags, reset));
265a266,273
> bool fh_local(dbref target, dbref player, FLAG flag, int fflags, bool reset)
> {
>     if(local_handled_flag(target, player, flag, fflags, reset)) 
>         return fh_any(target, player, flag, fflags, reset);
>     else
>         return fh_god(target, player, flag, fflags, reset);
> }
> 
346,355c354,363
< static FLAGBITENT fbeMarker0        = { MARK_0,       '0',    FLAG_WORD3, 0,                    fh_god};
< static FLAGBITENT fbeMarker1        = { MARK_1,       '1',    FLAG_WORD3, 0,                    fh_god};
< static FLAGBITENT fbeMarker2        = { MARK_2,       '2',    FLAG_WORD3, 0,                    fh_god};
< static FLAGBITENT fbeMarker3        = { MARK_3,       '3',    FLAG_WORD3, 0,                    fh_god};
< static FLAGBITENT fbeMarker4        = { MARK_4,       '4',    FLAG_WORD3, 0,                    fh_god};
< static FLAGBITENT fbeMarker5        = { MARK_5,       '5',    FLAG_WORD3, 0,                    fh_god};
< static FLAGBITENT fbeMarker6        = { MARK_6,       '6',    FLAG_WORD3, 0,                    fh_god};
< static FLAGBITENT fbeMarker7        = { MARK_7,       '7',    FLAG_WORD3, 0,                    fh_god};
< static FLAGBITENT fbeMarker8        = { MARK_8,       '8',    FLAG_WORD3, 0,                    fh_god};
< static FLAGBITENT fbeMarker9        = { MARK_9,       '9',    FLAG_WORD3, 0,                    fh_god};
---
> static FLAGBITENT fbeMarker0        = { MARK_0,       '0',    FLAG_WORD3, 0,                    fh_local};
> static FLAGBITENT fbeMarker1        = { MARK_1,       '1',    FLAG_WORD3, 0,                    fh_local};
> static FLAGBITENT fbeMarker2        = { MARK_2,       '2',    FLAG_WORD3, 0,                    fh_local};
> static FLAGBITENT fbeMarker3        = { MARK_3,       '3',    FLAG_WORD3, 0,                    fh_local};
> static FLAGBITENT fbeMarker4        = { MARK_4,       '4',    FLAG_WORD3, 0,                    fh_local};
> static FLAGBITENT fbeMarker5        = { MARK_5,       '5',    FLAG_WORD3, 0,                    fh_local};
> static FLAGBITENT fbeMarker6        = { MARK_6,       '6',    FLAG_WORD3, 0,                    fh_local};
> static FLAGBITENT fbeMarker7        = { MARK_7,       '7',    FLAG_WORD3, 0,                    fh_local};
> static FLAGBITENT fbeMarker8        = { MARK_8,       '8',    FLAG_WORD3, 0,                    fh_local};
> static FLAGBITENT fbeMarker9        = { MARK_9,       '9',    FLAG_WORD3, 0,                    fh_local};
471c479,482
<         hashaddLEN(nbuf, strlen(nbuf), fp, &mudstate.flags_htab);
---
>         if (!hashfindLEN(nbuf, strlen(nbuf), &mudstate.flags_htab))
>         {
>             hashaddLEN(nbuf, strlen(nbuf), fp, &mudstate.flags_htab);
>         }
diff /home/nick/sandbox/mux2.4.20/mux/src/flags.h ./flags.h
334a335,345
> #define Marker0(x)          ((Flags3(x) & MARK_0) != 0)
> #define Marker1(x)          ((Flags3(x) & MARK_1) != 0)
> #define Marker2(x)          ((Flags3(x) & MARK_2) != 0)
> #define Marker3(x)          ((Flags3(x) & MARK_3) != 0)
> #define Marker4(x)          ((Flags3(x) & MARK_4) != 0)
> #define Marker5(x)          ((Flags3(x) & MARK_5) != 0)
> #define Marker6(x)          ((Flags3(x) & MARK_6) != 0)
> #define Marker7(x)          ((Flags3(x) & MARK_7) != 0)
> #define Marker8(x)          ((Flags3(x) & MARK_8) != 0)
> #define Marker9(x)          ((Flags3(x) & MARK_9) != 0)
> 
Only in .: flags.o
diff /home/nick/sandbox/mux2.4.20/mux/src/funceval.cpp ./funceval.cpp
3c3
< // $Id: funceval.cpp,v 1.92 2005/08/12 14:37:11 sdennis Exp $
---
> // $Id: funceval.cpp,v 1.95 2005/10/19 06:17:36 sdennis Exp $
1248,1249d1247
<     int ca;
<     char *as;
1251c1249,1251
<     for (ca = atr_head(thing, &as); ca; ca = atr_next(&as))
---
> 
>     char *as;
>     for (int ca = atr_head(thing, &as); ca; ca = atr_next(&as))
3720,3738d3719
< class CBitField
< {
<     unsigned int nBitsPer;
<     unsigned int nShift;
<     unsigned int nMask;
<     unsigned int nMaximum;
<     size_t  nInts;
<     UINT32 *pInts;
<     UINT32 *pMasks;
< 
< public:
<     CBitField(unsigned int max);
<     ~CBitField(void);
<     void ClearAll(void);
<     void Set(unsigned int i);
<     void Clear(unsigned int i);
<     bool IsSet(unsigned int i);
< };
< 
3744,3747c3725,3756
<     nInts  = 0;
<     pInts  = NULL;
<     pMasks = NULL;
<     if (0 < nMaximum_arg)
---
>     nMaximum = 0;
>     nInts    = 0;
>     pInts    = NULL;
>     pMasks   = NULL;
> 
>     nBitsPer = sizeof(UINT32)*8;
> 
>     // Calculate Shift
>     //
>     nShift = 0;
>     unsigned int i = 1;
>     while (i < nBitsPer)
>     {
>         nShift++;
>         i <<= 1;
>     }
> 
>     // Calculate Mask
>     //
>     nMask = nBitsPer - 1;
> 
>     // Allocate array of UINT32s.
>     //
>     Resize(nMaximum_arg);
> }
> 
> #define MINIMUM_RESIZE (4096*sizeof(UINT32))
> 
> void CBitField::Resize(unsigned int nMaximum_arg)
> {
>     if (  0 < nMaximum_arg
>        && nMaximum < nMaximum_arg)
3749,3750c3758
<         nMaximum = nMaximum_arg;
<         nBitsPer = sizeof(UINT32)*8;
---
>         unsigned int nNewMaximum = nMaximum_arg;
3752c3760
<         // Calculate Shift
---
>         // This provides some assurances that we are not resizing too often.
3754,3756c3762,3763
<         nShift = 0;
<         unsigned int i = 1;
<         while (i < nBitsPer)
---
>         if (  pMasks
>            && nNewMaximum < nMaximum + MINIMUM_RESIZE)
3758,3759c3765
<             nShift++;
<             i <<= 1;
---
>             nNewMaximum = nMaximum + MINIMUM_RESIZE;
3762,3764c3768,3772
<         // Calculate Mask
<         //
<         nMask = nBitsPer - 1;
---
>         size_t  nNewInts = (nNewMaximum+nBitsPer) >> nShift;
>         UINT32 *pNewMasks = (UINT32 *)MEMALLOC((nNewInts+nBitsPer)
>                           * sizeof(UINT32));
>         ISOUTOFMEMORY(pNewMasks);
>         UINT32 *pNewInts = pNewMasks + nBitsPer;
3766c3774
<         // Allocate array of UINT32s.
---
>         // Is this the first sizing or a re-sizing?
3768,3771c3776,3782
<         nInts    = (nMaximum+nBitsPer) >> nShift;
<         pMasks   = (UINT32 *)MEMALLOC((nInts+nBitsPer)*sizeof(UINT32));
<         ISOUTOFMEMORY(pMasks);
<         pInts    = pMasks + nBitsPer;
---
>         if (pMasks)
>         {
>             // Copy existing masks and bits to the new location, and
>             // clear the new bits.
>             //
>             memcpy(pNewMasks, pMasks, (nInts+nBitsPer)*sizeof(UINT32));
>             memset(pNewInts + nInts, 0, (nNewInts - nInts)*sizeof(UINT32));
3773,3775c3784,3795
<         // Calculate all possible single bits.
<         //
<         for (i = 0; i < nBitsPer; i++)
---
>             // Free the previous allocation.
>             //
>             MEMFREE(pMasks);
> 
>             // A reallocation.
>             //
>             nMaximum = nNewMaximum;
>             nInts    = nNewInts;
>             pMasks   = pNewMasks;
>             pInts    = pNewInts;
>         }
>         else
3777c3797,3813
<             pMasks[i] = ((UINT32)1) << i;
---
>             // First allocation.
>             //
>             nMaximum = nNewMaximum;
>             nInts    = nNewInts;
>             pMasks   = pNewMasks;
>             pInts    = pNewInts;
> 
>             // Initialize masks by calculating all possible single bits.
>             //
>             for (int i = 0; i < nBitsPer; i++)
>             {
>                 pMasks[i] = ((UINT32)1) << i;
>             }
> 
>             // Initialize bits by clearing them all.
>             //
>             ClearAll();
3843,3844d3878
<     CBitField &bfTraverse,
<     CBitField &bfReport,
3858c3892
<         bfReport.Set(room);
---
>         mudstate.bfReport.Set(room);
3899c3933
<                && !bfTraverse.IsSet(loc))
---
>                && !mudstate.bfTraverse.IsSet(loc))
3901,3903c3935,3936
<                 bfTraverse.Set(loc);
<                 room_list(player, enactor, loc, bfTraverse, bfReport,
<                     (level + 1), maxlevels, showall);
---
>                 mudstate.bfTraverse.Set(loc);
>                 room_list(player, enactor, loc, (level + 1), maxlevels, showall);
3949,3956c3982,3989
<     CBitField bfReport(mudstate.db_top-1);
<     CBitField bfTraverse(mudstate.db_top-1);
<     bfReport.ClearAll();
<     bfTraverse.ClearAll();
< 
<     bfTraverse.Set(room);
<     room_list(executor, enactor, room, bfTraverse, bfReport, 0, N, B);
<     bfReport.Clear(room);
---
>     mudstate.bfReport.Resize(mudstate.db_top-1);
>     mudstate.bfTraverse.Resize(mudstate.db_top-1);
>     mudstate.bfReport.ClearAll();
>     mudstate.bfTraverse.ClearAll();
> 
>     mudstate.bfTraverse.Set(room);
>     room_list(executor, enactor, room, 0, N, B);
>     mudstate.bfReport.Clear(room);
3963c3996
<         if (  bfReport.IsSet(i)
---
>         if (  mudstate.bfReport.IsSet(i)
Only in .: funceval.o
diff /home/nick/sandbox/mux2.4.20/mux/src/functions.cpp ./functions.cpp
3c3
< // $Id: functions.cpp,v 1.148 2005/10/08 02:47:28 sdennis Exp $
---
> // $Id: functions.cpp,v 1.152 2005/10/24 01:48:12 sdennis Exp $
2554,2555c2554,2559
<                    && !See_Hidden(executor)
<                    && !ItemToList_AddInteger(&pContext, thing))
---
>                    && !See_Hidden(executor))
>                 {
>                     continue;
>                 }
>  
>                 if (!ItemToList_AddInteger(&pContext, thing))
4542c4546,4549
<     if (nfargs == 0 || (!fargs[0]) || !*fargs[0] || !string_compare(fargs[0], "all"))
---
>     if (  nfargs == 0
>        || (!fargs[0])
>        || !*fargs[0]
>        || !string_compare(fargs[0], "all"))
5423c5430
<         if (bSwitch ? wild_match(tbuff, mbuff) : string_compare(tbuff, mbuff) == 0)
---
>         if (bSwitch ? wild_match(tbuff, mbuff) : strcmp(tbuff, mbuff) == 0)
7767c7774
< FUN flist[] =
---
> FUN builtin_function_list[] =
8114a8122,8131
> void function_add(FUN *fp)
> {
>     char *buff = alloc_sbuf("init_functab");
>     char *bp = buff;
>     safe_sb_str(fp->name, buff, &bp);
>     *bp = '\0';
>     mux_strlwr(buff);
>     hashaddLEN(buff, strlen(buff), fp, &mudstate.func_htab);
>     free_sbuf(buff);
> }
8116c8133
< void init_functab(void)
---
> void functions_add(FUN funlist[])
8119c8136
<     for (FUN *fp = flist; fp->name; fp++)
---
>     for (FUN *fp = funlist; fp->name; fp++)
8127a8145,8149
> }
> 
> void init_functab(void)
> {
>     functions_add(builtin_function_list);
8283c8305
<     for (fp = flist; fp->name && bp < buff + (LBUF_SIZE-1); fp++)
---
>     for (fp = builtin_function_list; fp->name && bp < buff + (LBUF_SIZE-1); fp++)
8321c8343
<         ; // Nothing.
---
>         *ap = mux_tolower(*ap); // Nothing.
8322a8345,8346
>     int nstr = ap - str;
> 
8327,8328c8351,8353
<     FUN *fp;
<     for (fp = flist; fp->name; fp++)
---
> 
>     FUN *fp = (FUN *)hashfindLEN(str, nstr, &mudstate.func_htab);
>     if (fp)
8330,8333c8355
<         if (!string_compare(fp->name, str))
<         {
<             return cf_modify_bits(&fp->perms, ap, pExtra, nExtra, player, cmd);
<         }
---
>         return cf_modify_bits(&fp->perms, ap, pExtra, nExtra, player, cmd);
8335,8336c8357,8358
<     UFUN *ufp;
<     for (ufp = ufun_head; ufp; ufp = ufp->next)
---
>     UFUN *ufp = (UFUN *)hashfindLEN(str, nstr, &mudstate.ufunc_htab);
>     if (ufp)
8338,8341c8360
<         if (!string_compare(ufp->name, str))
<         {
<             return cf_modify_bits(&ufp->perms, ap, pExtra, nExtra, player, cmd);
<         }
---
>         return cf_modify_bits(&ufp->perms, ap, pExtra, nExtra, player, cmd);
diff /home/nick/sandbox/mux2.4.20/mux/src/functions.h ./functions.h
3c3
< // $Id: functions.h,v 1.14 2005/07/12 05:50:06 sdennis Exp $
---
> // $Id: functions.h,v 1.15 2005/10/17 03:55:02 sdennis Exp $
96a97,101
> // Interface for adding additional hardcode functions.
> //
> void function_add(FUN *fp);
> void functions_add(FUN funlist[]);
> 
Only in .: functions.o
Only in .: funmath.o
diff /home/nick/sandbox/mux2.4.20/mux/src/game.cpp ./game.cpp
3c3
< // $Id: game.cpp,v 1.72 2005/10/13 14:54:07 sdennis Exp $
---
> // $Id: game.cpp,v 1.78 2005/10/21 03:36:01 sdennis Exp $
197c197,210
<     int atr;
---
>     if (  AMATCH_CMD == type
>        && mudstate.bfNoCommands.IsSet(parent))
>     {
>         return match;
>     }
>     else if ( AMATCH_LISTEN == type
>             && mudstate.bfNoListens.IsSet(parent))
>     {
>         return match;
>     }
> 
>     bool bFoundCommands = false;
>     bool bFoundListens  = false;
> 
200c213
<     for (atr = atr_head(parent, &as); atr; atr = atr_next(&as))
---
>     for (int atr = atr_head(parent, &as); atr; atr = atr_next(&as))
212,213c225,227
<         // If we aren't the bottom level check if we saw this attr
<         // before. Also exclude it if the attribute type is PRIVATE.
---
>         // We need to grab the attribute even before we know whether we'll use
>         // it or not in order to maintain cached knowledge about ^-Commands
>         // and $-Commands.
215,220d228
<         if (  check_exclude
<            && (  (ap->flags & AF_PRIVATE)
<               || hashfindLEN(&(ap->number), sizeof(ap->number), &mudstate.parent_htab)))
<         {
<             continue;
<         }
226c234,258
<         // Skip if private and on a parent.
---
>         if (aflags & AF_NOPROG)
>         {
>             continue;
>         }
> 
>         char *s = NULL;
>         if (  AMATCH_CMD    == buff[0]
>            || AMATCH_LISTEN == buff[0])
>         {
>             s = strchr(buff+1, ':');
>             if (s)
>             {
>                 if (AMATCH_CMD == buff[0])
>                 {
>                     bFoundCommands = true;
>                 }
>                 else
>                 {
>                     bFoundListens = true;
>                 }
>             }
>         }
> 
>         // If we aren't the bottom level, check if we saw this attr
>         // before. Also exclude it if the attribute type is PRIVATE.
229c261,263
<            && (aflags & AF_PRIVATE))
---
>            && (  (ap->flags & AF_PRIVATE)
>               || (aflags & AF_PRIVATE)
>               || hashfindLEN(&(ap->number), sizeof(ap->number), &mudstate.parent_htab)))
234c268
<         // If we aren't the top level remember this attr so we
---
>         // If we aren't the top level, remember this attr so we
246,247c280
<         if (  buff[0] != type
<            || (aflags & AF_NOPROG))
---
>         if (buff[0] != type)
252c285
<         // Decode it: search for first unescaped :
---
>         // Was there a ':'?
254d286
<         char *s = strchr(buff+1, ':');
259a292
> 
282a316,337
> 
>     if (bFoundCommands)
>     {
>         mudstate.bfNoCommands.Clear(parent);
>         mudstate.bfCommands.Set(parent);
>     }
>     else
>     {
>         mudstate.bfCommands.Clear(parent);
>         mudstate.bfNoCommands.Set(parent);
>     }
> 
>     if (bFoundListens)
>     {
>         mudstate.bfNoListens.Clear(parent);
>         mudstate.bfListens.Set(parent);
>     }
>     else
>     {
>         mudstate.bfListens.Clear(parent);
>         mudstate.bfNoListens.Set(parent);
>     }
1130c1185,1192
< void do_shutdown(dbref executor, dbref caller, dbref enactor, int key, char *message)
---
> void do_shutdown
> (
>     dbref executor,
>     dbref caller,
>     dbref enactor,
>     int   key,
>     char *message
> )
1170a1233,1234
>         local_presync_database();
> 
1173d1236
< 
1446a1510,1511
>     local_presync_database();
> 
1468a1534
>     local_dump_complete_signal();
1530a1597,1598
>     local_presync_database();
> 
1620d1687
<         mudstate.dumping = false;
1621a1689,1690
>         mudstate.dumping = false;
>         local_dump_complete_signal();
1841,1845d1909
<     char *as, *buff, *s;
<     dbref aowner;
<     int atr, aflags;
<     ATTR *ap;
< 
1853c1917,1919
<        || Puppet(thing))
---
>        || Puppet(thing)
>        || H_Listen(thing)
>        || mudstate.bfListens.IsSet(thing))
1858,1867c1924,1925
<     if (Monitor(thing))
<     {
<         buff = alloc_lbuf("Hearer");
<     }
<     else
<     {
<         buff = NULL;
<     }
<     atr_push();
<     for (atr = atr_head(thing, &as); atr; atr = atr_next(&as))
---
>     if (  !mudstate.bfNoListens.IsSet(thing)
>        && Monitor(thing))
1869,1879c1927,1932
<         if (atr == A_LISTEN)
<         {
<             if (buff)
<             {
<                 free_lbuf(buff);
<                 buff = NULL;
<             }
<             atr_pop();
<             return true;
<         }
<         if (buff)
---
>         bool bFoundCommands = false;
> 
>         char *buff = alloc_lbuf("Hearer");
>         char *as;
>         atr_push();
>         for (int atr = atr_head(thing, &as); atr; atr = atr_next(&as))
1881c1934
<             ap = atr_num(atr);
---
>             ATTR *ap = atr_num(atr);
1887a1941,1942
>             int   aflags;
>             dbref aowner;
1890,1893c1945
<             // Make sure we can execute it.
<             //
<             if (  buff[0] != AMATCH_LISTEN
<                || (aflags & AF_NOPROG))
---
>             if (aflags & AF_NOPROG)
1898,1904c1950,1952
<             // Make sure there's a : in it.
<             //
<             for (s = buff + 1; *s && *s != ':'; s++)
<             {
<                 ; // Nothing
<             }
<             if (s)
---
>             char *s = NULL;
>             if (  AMATCH_CMD    == buff[0]
>                || AMATCH_LISTEN == buff[0])
1906,1909c1954,1968
<                 free_lbuf(buff);
<                 buff = NULL;
<                 atr_pop();
<                 return true;
---
>                 s = strchr(buff+1, ':');
>                 if (s)
>                 {
>                     if (AMATCH_CMD == buff[0])
>                     {
>                         bFoundCommands = true;
>                     }
>                     else
>                     {
>                         free_lbuf(buff);
>                         atr_pop();
>                         mudstate.bfListens.Set(thing);
>                         return true;
>                     }
>                 }
1912,1914d1970
<     }
<     if (buff)
<     {
1916c1972,1985
<         buff = NULL;
---
>         atr_pop();
> 
>         mudstate.bfNoListens.Set(thing);
> 
>         if (bFoundCommands)
>         {
>             mudstate.bfNoCommands.Clear(thing);
>             mudstate.bfCommands.Set(thing);
>         }
>         else
>         {
>             mudstate.bfCommands.Clear(thing);
>             mudstate.bfNoCommands.Set(thing);
>         }
1918d1986
<     atr_pop();
Only in .: game.o
Only in .: glue.hcode.o
Only in .: glue.o
Only in .: glue.scode.o
diff /home/nick/sandbox/mux2.4.20/mux/src/help.cpp ./help.cpp
3c3
< // $Id: help.cpp,v 1.12 2005/08/05 15:35:14 sdennis Exp $
---
> // $Id: help.cpp,v 1.14 2005/10/24 16:52:17 sdennis Exp $
169c169,170
<         // Convert the entry to all lowercase letters and add all leftmost substrings.
---
>         // Convert the entry to all lowercase letters and add all leftmost
>         // substrings.
171c172,175
<         // Substrings already added will be rejected by hashaddLEN.
---
>         // Topic names which appear earlier in the help file have priority
>         // over topics names which appear later in the help file.  That is,
>         // we do not associate prefixes with this topic if they have already
>         // been used on a previous topic.
190c194
<             if ((hashaddLEN(entry.topic, nTopic, htab_entry, htab)) == 0)
---
>             if (!hashfindLEN(entry.topic, nTopic, htab))
191a196
>                 hashaddLEN(entry.topic, nTopic, htab_entry, htab);
Only in .: help.o
diff /home/nick/sandbox/mux2.4.20/mux/src/htab.cpp ./htab.cpp
1,8c1,21
< // htab.cpp -- Table hashing routines.
< //
< // $Id: htab.cpp,v 1.19 2005/01/11 19:43:26 sdennis Exp $
< //
< // MUX 2.4
< // Copyright (C) 1998 through 2004 Solid Vertical Domains, Ltd. All
< // rights not explicitly given are reserved.
< //
---
> /*! \file htab.cpp
>  *  Table hashing routines.
>  *
>  * $Id: htab.cpp,v 1.28 2005/10/30 05:18:28 sdennis Exp $
>  *
>  * The functions here outsource most of their work to CHashTable.  There are
>  * several reasons to use the functions here instead of using CHashTable
>  * directly: 1) they are briefer to use, 2) this interface predates
>  * CHashTable, 3) there are many references to these functions throughout the
>  * code, and 4) MUSH hardcoders are generally more familiar with this
>  * interface than with the CHashTable interface.
>  *
>  * To replace them all would require rexamining the assumptions near every
>  * reference.
>  *
>  * CHashTable is not aware of Keys -- only hashes of Keys. In fact, CHashTable
>  * could not tell you anything about the Keys kept within its records.  It
>  * will give you all the records stored under a specific hash, but it leaves
>  * to its callers the small chore of looking in each record for a desired Key.
>  */
> 
14,16c27,36
< /*
<  * ---------------------------------------------------------------------------
<  * hashreset: Reset hash table stats.
---
> /*! \brief Reset hash table statistics.
>  *
>  * Each Hash Table maintains certain statistics regarding the type and
>  * number of requests they receive as well as the hash table's performance
>  * in responding to those requests. The hashreset() function allows callers
>  * to reset these statistics. Typically, this is done when the caller knows
>  * future access patterns are of more interest than past access paterns. 
>  *
>  * \param htab     Hash Table.
>  * \return         None.
17a38
> 
22a44,51
> /*! \brief Staging area for reads and writes into CHashTable.
>  *
>  * The htab_rec structure is a fixed size, but only part of htab_rec is used.
>  * Since requests use variable-sized Keys, the portion of htab_rec used on
>  * any particular request is also variable-sized. pData is always present,
>  * but aKey may occupy as little as a single byte.
>  */
> 
26,27c55,56
<     void *hashdata;
<     char aTarget[LBUF_SIZE+125];
---
>     void *pData;
>     char  aKey[LBUF_SIZE+125];
31,34c60,73
< /*
<  * ---------------------------------------------------------------------------
<  * * hashfindLEN: Look up an entry in a hash table and return a pointer to its
<  * * hash data.
---
> /*! \brief Look for a previously-added (Key, Data) pair in a hash table, and
>  *         return its data pointer.
>  *
>  * Given a variable-sized Key, hashfindLEN() uses the associations previously
>  * created with hashaddLEN() to find and return the corresponding 'Data' part
>  * of a (Key, Data) pair, if it exists.
>  *
>  * NULL is returned if the request is not valid or if the (Key, Data) pair
>  * is not found.
>  *
>  * \param pKey     Pointer to Key to find.
>  * \param nKey     Size (in bytes) of the above Key.
>  * \param htab     Hash Table.
>  * \return         pData or NULL.
37c76
< void *hashfindLEN(const void *str, size_t nStr, CHashTable *htab)
---
> void *hashfindLEN(const void *pKey, size_t nKey, CHashTable *htab)
39,40c78,79
<     if (  str == NULL
<        || nStr <= 0)
---
>     if (  pKey == NULL
>        || nKey <= 0)
45c84
<     UINT32 nHash = HASH_ProcessBuffer(0, str, nStr);
---
>     UINT32 nHash = HASH_ProcessBuffer(0, pKey, nKey);
55,56c94,95
<         if (  nTarget == nStr
<            && memcmp(str, htab_rec.aTarget, nStr) == 0)
---
>         if (  nTarget == nKey
>            && memcmp(pKey, htab_rec.aKey, nKey) == 0)
58c97
<             return htab_rec.hashdata;
---
>             return htab_rec.pData;
65,67c104,120
< /*
<  * ---------------------------------------------------------------------------
<  * * hashaddLEN: Add a new entry to a hash table.
---
> /*! \brief Add a new (Key, Data) pair to a hash table.
>  *
>  * hashaddLEN() associates a variable-sized key with a pointer using a hash
>  * table. The pointer, pData, given to hashaddLEN() may be obtained again
>  * later by presenting the the same key to hashfindLEN(). The data given in
>  * (pKey, nKey) is saved, so the caller is free to reuse the Key buffer.
>  * While the value of pData is also saved, the data that pData points to is
>  * not.
>  *
>  * This function requires that the Key does not already exist in the hash
>  * table. It may be necessary to use hashfindLEN() to insure this.
>  *
>  * \param pKey     Pointer to Key of (Key, Data) pair to add.
>  * \param nKey     Size (in bytes) of the above Key.
>  * \param pData    Pointer to Data part of (Key, Data) pair.
>  * \param htab     Hash Table.
>  * \return         -1 for failure. 0 for success.
70c123
< int hashaddLEN(const void *str, size_t nStr, void *hashdata, CHashTable *htab)
---
> int hashaddLEN(const void *pKey, size_t nKey, void *pData, CHashTable *htab)
72,76c125,126
<     // Make sure that the entry isn't already in the hash table.  If it
<     // is, exit with an error.
<     //
<     if (  str == NULL
<        || nStr <= 0)
---
>     if (  pKey == NULL
>        || nKey <= 0)
81c131
<     UINT32 nHash = HASH_ProcessBuffer(0, str, nStr);
---
>     UINT32 nHash = HASH_ProcessBuffer(0, pKey, nKey);
83,102c133,135
<     HP_DIRINDEX iDir = htab->FindFirstKey(nHash);
<     while (iDir != HF_FIND_END)
<     {
<         HP_HEAPLENGTH nRecord;
<         htab->Copy(iDir, &nRecord, &htab_rec);
<         size_t nTarget = nRecord - sizeof(int *);
< 
<         if (  nTarget == nStr
<            && memcmp(str, htab_rec.aTarget, nStr) == 0)
<         {
<             return -1;
<         }
<         iDir = htab->FindNextKey(iDir, nHash);
<     }
< 
<     // Otherwise, add it.
<     //
<     htab_rec.hashdata = hashdata;
<     memcpy(htab_rec.aTarget, str, nStr);
<     unsigned int nRecord = nStr + sizeof(int *);
---
>     htab_rec.pData = pData;
>     memcpy(htab_rec.aKey, pKey, nKey);
>     unsigned int nRecord = nKey + sizeof(void *);
107,109c140,150
< /*
<  * ---------------------------------------------------------------------------
<  * * hashdelete: Remove an entry from a hash table.
---
> /*! \brief Removes a (Key, Data) pair from a hash table.
>  *
>  * hashdeleteLEN() disassociates a variable-sized Key from its Data pointer
>  * by removing the (Key, Data) pair from the hash table and freeing any
>  * related storage. However, it is the caller's responsibility to free any
>  * memory that Data points to.
>  *
>  * \param pKey     The Key to remove.
>  * \param nKey     Size (in bytes) of the above Key.
>  * \param htab     Hash Table.
>  * \return         None.
112c153
< void hashdeleteLEN(const void *str, size_t nStr, CHashTable *htab)
---
> void hashdeleteLEN(const void *pKey, size_t nKey, CHashTable *htab)
114,115c155,156
<     if (  str == NULL
<        || nStr <= 0)
---
>     if (  pKey == NULL
>        || nKey <= 0)
120c161
<     UINT32 nHash = HASH_ProcessBuffer(0, str, nStr);
---
>     UINT32 nHash = HASH_ProcessBuffer(0, pKey, nKey);
129,130c170,171
<         if (  nTarget == nStr
<            && memcmp(str, htab_rec.aTarget, nStr) == 0)
---
>         if (  nTarget == nKey
>            && memcmp(pKey, htab_rec.aKey, nKey) == 0)
138,140c179,185
< /*
<  * ---------------------------------------------------------------------------
<  * * hashflush: free all the entries in a hashtable.
---
> /*! \brief Removes all (Key, Data) entries in a hash table.
>  *
>  * The Hash Table is re-initialized from scratch and all storage is
>  * reclaimed. The resulting Hash Table is empty.
>  *
>  * \param htab     Hash Table.
>  * \return         None.
153c198
< bool hashreplLEN(const void *str, size_t nStr, void *hashdata, CHashTable *htab)
---
> bool hashreplLEN(const void *str, size_t nStr, void *pData, CHashTable *htab)
171c216
<            && memcmp(str, htab_rec.aTarget, nStr) == 0)
---
>            && memcmp(str, htab_rec.aKey, nStr) == 0)
173c218
<             htab_rec.hashdata = hashdata;
---
>             htab_rec.pData = pData;
189c234
<         if (htab_rec.hashdata == old)
---
>         if (htab_rec.pData == old)
191c236
<             htab_rec.hashdata = new0;
---
>             htab_rec.pData = new0;
207c252
<         return htab_rec.hashdata;
---
>         return htab_rec.pData;
218c263
<         return htab_rec.hashdata;
---
>         return htab_rec.pData;
230,231c275,276
<         *pKey = htab_rec.aTarget;
<         return htab_rec.hashdata;
---
>         *pKey = htab_rec.aKey;
>         return htab_rec.pData;
245,246c290,291
<         *pKey = htab_rec.aTarget;
<         return htab_rec.hashdata;
---
>         *pKey = htab_rec.aKey;
>         return htab_rec.pData;
diff /home/nick/sandbox/mux2.4.20/mux/src/htab.h ./htab.h
3c3
< // $Id: htab.h,v 1.7 2004/07/19 21:33:54 sdennis Exp $
---
> // $Id: htab.h,v 1.9 2005/10/27 06:27:53 sdennis Exp $
42,52c42,74
< extern void hashreset(CHashTable *);
< extern void *hashfindLEN(const void *Str, size_t nStr, CHashTable *htab);
< extern int  hashaddLEN(const void *Str, size_t nStr, void *hashdata, CHashTable *htab);
< extern void hashdeleteLEN(const void *Str, size_t nStr, CHashTable *htab);
< extern void hashflush(CHashTable *);
< extern bool hashreplLEN(const void *Str, size_t nStr, void *hashdata, CHashTable *htab);
< extern void hashreplall(const void *, void *, CHashTable *);
< extern void *hash_nextentry(CHashTable *htab);
< extern void *hash_firstentry(CHashTable *htab);
< extern void *hash_firstkey(CHashTable *htab, int *, char **);
< extern void *hash_nextkey(CHashTable *htab, int *, char **);
---
> class CBitField
> {
>     unsigned int nBitsPer;
>     unsigned int nShift;
>     unsigned int nMask;
>     unsigned int nMaximum;
>     size_t  nInts;
>     UINT32 *pInts;
>     UINT32 *pMasks;
> 
> public:
>     CBitField(unsigned int max = 0);
>     void Resize(unsigned int max);
>     ~CBitField(void);
>     void ClearAll(void);
>     void Set(unsigned int i);
>     void Clear(unsigned int i);
>     bool IsSet(unsigned int i);
> };
> 
> void hashreset(CHashTable *);
> void *hashfindLEN(const void *pKey, size_t nKey, CHashTable *htab);
> int  hashaddLEN(const void *pKey, size_t nKey, void *pData,
>                 CHashTable *htab);
> void hashdeleteLEN(const void *Str, size_t nStr, CHashTable *htab);
> void hashflush(CHashTable *);
> bool hashreplLEN(const void *Str, size_t nStr, void *hashdata,
>                  CHashTable *htab);
> void hashreplall(const void *, void *, CHashTable *);
> void *hash_nextentry(CHashTable *htab);
> void *hash_firstentry(CHashTable *htab);
> void *hash_firstkey(CHashTable *htab, int *, char **);
> void *hash_nextkey(CHashTable *htab, int *, char **);
Only in .: htab.o
Only in .: hudinfo.o
diff /home/nick/sandbox/mux2.4.20/mux/src/interface.h ./interface.h
85a86,87
> #define HUDKEYLEN 21
> 
138a141
>   char hudkey[HUDKEYLEN];
diff /home/nick/sandbox/mux2.4.20/mux/src/local.cpp ./local.cpp
1,5d0
< #include "copyright.h"
< #include "autoconf.h"
< #include "config.h"
< #include "externs.h"
< 
11a7,213
> #include <map>
> 
> #include "copyright.h"
> #include "autoconf.h"
> #include "config.h"
> #include "externs.h"
> #include "functions.h"
> #include "command.h"
> // btech includes start here
> #include "mech.h"
> #include "glue.h"
> #include "p.glue.h"
> #include "p.glue.scode.h"
> 
> #include "python.h"
> 
> Python *python;
> 
> // ----------------------------------------------------------------------------
> // local_funlist: List of existing functions in alphabetical order.
> //
> //   Name          Handler      # of args   min #    max #   flags  permissions
> //                               to parse  of args  of args
> //
> FUN local_funlist[] =
> {
>     {"BTADDPARTS",          fun_btaddparts,         MAX_ARG, 3, 3, 0,   CA_WIZARD},
>     {"BTARMORSTATUS",       fun_btarmorstatus,      MAX_ARG, 2, 2, 0,   CA_WIZARD},
>     {"BTCRITSTATUS",        fun_btcritstatus,       MAX_ARG, 2, 2, 0,   CA_WIZARD},
>     {"BTDAMAGEMECH",        fun_btdamagemech,       MAX_ARG, 7, 7, 0,   CA_WIZARD},
>     {"BTDAMAGES",           fun_btdamages,          MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTDESIGNEX",          fun_btdesignex,         MAX_ARG, 1, 1, 0,   CA_PUBLIC},
>     {"BTGETCHARVALUE",      fun_btgetcharvalue,     MAX_ARG, 3, 3, 0,   CA_WIZARD},
>     {"BTGETXCODEVALUE",     fun_btgetxcodevalue,    MAX_ARG, 2, 2, 0,   CA_WIZARD},
>     {"BTLOADMAP",           fun_btloadmap,          MAX_ARG, 2, 3, 0,   CA_WIZARD},
>     {"BTLOADMECH",          fun_btloadmech,         MAX_ARG, 2, 2, 0,   CA_WIZARD},
>     {"BTMAKEMECHS",         fun_btmakemechs,        MAX_ARG, 2, 5, 0,   CA_WIZARD},
>     {"BTMAKEPILOTROLL",     fun_btmakepilotroll,    MAX_ARG, 3, 3, 0,   CA_WIZARD},
>     {"BTMAPELEV",           fun_btmapelev,          MAX_ARG, 3, 3, 0,   CA_WIZARD},
>     {"BTMAPTERR",           fun_btmapterr,          MAX_ARG, 3, 3, 0,   CA_WIZARD},
>     {"BTMECHFREQS",         fun_btmechfreqs,        MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTPARTMATCH",         fun_btpartmatch,        MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTPARTNAME",          fun_btpartname,         MAX_ARG, 2, 2, 0,   CA_WIZARD},
>     {"BTSETARMORSTATUS",    fun_btsetarmorstatus,   MAX_ARG, 4, 4, 0,   CA_WIZARD},
>     {"BTSETCHARVALUE",      fun_btsetcharvalue,     MAX_ARG, 4, 4, 0,   CA_WIZARD},
>     {"BTSETXCODEVALUE",     fun_btsetxcodevalue,    MAX_ARG, 3, 3, 0,   CA_WIZARD},
>     {"BTSTORES",            fun_btstores,           MAX_ARG, 1, 2, 0,   CA_WIZARD},
>     {"BTTECHSTATUS",        fun_bttechstatus,       MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTTHRESHOLD",         fun_btthreshold,        MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTUNDERREPAIR",       fun_btunderrepair,      MAX_ARG, 1, 1, 0,   CA_BUILDER},
>     {"BTWEAPONSTATUS",      fun_btweaponstatus,     MAX_ARG, 1, 2, 0,   CA_WIZARD},
>     {"BTADDSTORES",         fun_btaddstores,        MAX_ARG, 3, 3, 0,   CA_WIZARD},
>     {"BTARMORSTATUS_REF",   fun_btarmorstatus_ref,  MAX_ARG, 2, 2, 0,   CA_WIZARD},
>     {"BTCHARLIST",          fun_btcharlist,         MAX_ARG, 1, 2, 0,   CA_WIZARD},
>     {"BTCRITSLOT",          fun_btcritslot,         MAX_ARG, 3, 4, 0,   CA_WIZARD},
>     {"BTCRITSLOT_REF",      fun_btcritslot_ref,     MAX_ARG, 3, 4, 0,   CA_WIZARD},
>     {"BTCRITSTATUS_REF",    fun_btcritstatus_ref,   MAX_ARG, 2, 2, 0,   CA_WIZARD},
>     {"BTENGRATE",           fun_btengrate,          MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTENGRATE_REF",       fun_btengrate_ref,      MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTFASABASECOST_REF",  fun_btfasabasecost_ref, MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTGETBV",             fun_btgetbv,            MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTGETBV_REF",         fun_btgetbv_ref,        MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTGETPARTCOST",       fun_btgetpartcost,      MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTGETRANGE",          fun_btgetrange,         MAX_ARG, 3, 5, 0,   CA_WIZARD},                                             
>     {"BTGETREALMAXSPEED",   fun_btgetrealmaxspeed,  MAX_ARG, 1, 1, 0,   CA_WIZARD},                                    
>     {"BTGETREFTECH_REF",    fun_btgetreftech_ref,   MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTGETWEIGHT",         fun_btgetweight,        MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTGETXCODEVALUE_REF", fun_btgetxcodevalue_ref,MAX_ARG, 2, 2, 0,   CA_WIZARD},
>     {"BTHEXEMIT",           fun_bthexemit,          MAX_ARG, 4, 4, 0,   CA_WIZARD},
>     {"BTHEXINBLZ",          fun_bthexinblz,         MAX_ARG, 3, 3, 0,   CA_WIZARD},
>     {"BTHEXLOS",            fun_bthexlos,           MAX_ARG, 3, 3, 0,   CA_WIZARD},
>     {"BTID2DB",             fun_btid2db,            MAX_ARG, 2, 2, 0,   CA_WIZARD},
>     {"BTLISTBLZ",           fun_btlistblz,          MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTLOSM2M",            fun_btlosm2m,           MAX_ARG, 2, 2, 0,   CA_WIZARD},
>     {"BTMAPEMIT",           fun_btmapemit,          MAX_ARG, 2, 2, 0,   CA_WIZARD},
>     {"BTNUMREPJOBS",        fun_btnumrepjobs,       MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTPARTTYPE",          fun_btparttype,         MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTPARTWEIGHT",        fun_btgetweight,        MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTPAYLOAD_REF",       fun_btpayload_ref,      MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTREMOVESTORES",      fun_btremovestores,     MAX_ARG, 3, 3, 0,   CA_WIZARD},
>     {"BTSETMAXSPEED",       fun_btsetmaxspeed,      MAX_ARG, 2, 2, 0,   CA_WIZARD},
>     {"BTSETPARTCOST",       fun_btsetpartcost,      MAX_ARG, 2, 2, 0,   CA_WIZARD},
>     {"BTSETXY",             fun_btsetxy,            MAX_ARG, 5, 5, 0,   CA_WIZARD},
>     {"BTSHOWCRITSTATUS_REF",fun_btshowcritstatus_ref,MAX_ARG,3, 3, 0,   CA_WIZARD},
>     {"BTSHOWSTATUS_REF",    fun_btshowstatus_ref,   MAX_ARG, 2, 2, 0,   CA_WIZARD},
>     {"BTSHOWWSPECS_REF",    fun_btshowwspecs_ref,   MAX_ARG, 2, 2, 0,   CA_WIZARD},
>     {"BTTECH_REF",          fun_bttech_ref,         MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTTECHLIST",          fun_bttechlist,         MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTTECHLIST_REF",      fun_bttechlist_ref,     MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTTECHTIME",          fun_bttechtime,         MAX_ARG, 0, 0, 0,   CA_WIZARD},
>     {"BTUNITFIXABLE",       fun_btunitfixable,      MAX_ARG, 1, 1, 0,   CA_WIZARD},
>     {"BTWEAPONSTATUS_REF",  fun_btweaponstatus_ref, MAX_ARG, 1, 2, 0,   CA_WIZARD},
>     {"BTWEAPSTAT",          fun_btweapstat,         MAX_ARG, 2, 2, 0,   CA_WIZARD},
>     {"PYTHON",              fun_python,             MAX_ARG, 1, MAX_ARG, 0, CA_WIZARD},
> };
> 
> // ---------------------------------------------------------------------------
> // Local command tables: Definitions for local hardcode commands.
> //
> //   Name       Switches    Permissions    Key Calling Seq   hook mask  Handler
> //
> CMDENT_NO_ARG local_command_table_no_arg[] =
> {
>     {NULL,          NULL,       0,           0,          0,          0, NULL}
> };
> 
> CMDENT_ONE_ARG local_command_table_one_arg[] =
> {
>     {NULL,          NULL,       0,           0,          0,          0, NULL}
> };
> 
> CMDENT_ONE_ARG_CMDARG local_command_table_one_arg_cmdarg[] =
> {
>     {NULL,          NULL,       0,           0,          0,          0, NULL}
> };
> 
> CMDENT_TWO_ARG local_command_table_two_arg[] =
> {
>     {NULL,          NULL,       0,           0,          0,          0, NULL}
> };
> 
> CMDENT_TWO_ARG_CMDARG local_command_table_two_arg_cmdarg[] =
> {
>     {NULL,          NULL,       0,           0,          0,          0, NULL}
> };
> 
> CMDENT_TWO_ARG_ARGV local_command_table_two_arg_argv[] =
> {
>     {NULL,          NULL,       0,           0,          0,          0, NULL}
> };
> 
> CMDENT_TWO_ARG_ARGV_CMDARG local_command_table_two_argv_cmdarg[] =
> {
>     {NULL,          NULL,       0,           0,          0,          0, NULL}
> };
> 
>     BTECHDATA btechconf;
> CONF2 btechconftable[] = {      
>     {"btech_engine",                cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_engine,                 NULL,  0},
>     {"btech_failures",              cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_parts,                  NULL,  0},
>     {"btech_ic",                    cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_ic,                     NULL,  0},
>     {"btech_afterlife_dbref",       cf_int,     CA_GOD,     CA_GOD,         &btechconf.afterlife_dbref,              NULL,  0},
>     {"btech_afterscen_dbref",       cf_int,     CA_GOD,     CA_GOD,         &btechconf.afterscen_dbref,              NULL,  0},
>     {"btech_vcrit",                 cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_vcrit,                  NULL,  0},
>     {"btech_dynspeed",              cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_dynspeed,               NULL,  0},
>     {"btech_slowdown",              cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_slowdown,               NULL,  0},
>     {"btech_fasaturn",              cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_fasaturn,               NULL,  0},
>     {"btech_fasacrit",              cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_fasacrit,               NULL,  0},
>     {"btech_fasaadvvtolcrit",       cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_fasaadvvtolcrit,        NULL,  0},
>     {"btech_fasaadvvhlcrit",        cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_fasaadvvhlcrit,         NULL,  0},
>     {"btech_fasaadvvhlfire",        cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_fasaadvvhlfire,         NULL,  0},
>     {"btech_divrotordamage",        cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_divrotordamage,         NULL,  0},
>     {"btech_moddamagewithrange",    cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_moddamagewithrange,     NULL,  0},
>     {"btech_moddamagewithwoods",    cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_moddamagewithwoods,     NULL,  0},
>     {"btech_hotloadaddshalfbthmod", cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_hotloadaddshalfbthmod,  NULL,  0},
>     {"btech_nofusionvtolfuel",      cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_nofusionvtolfuel,       NULL,  0},
>     {"btech_tankfriendly",          cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_tankfriendly,           NULL,  0},
>     {"btech_newcharge",             cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_newcharge,              NULL,  0},
>     {"btech_newterrain",            cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_newterrain,             NULL,  0},
>     {"btech_xploss",                cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_xploss,                 NULL,  0},
>     {"btech_critlevel",             cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_critlevel,              NULL,  0},
>     {"btech_tankshield",            cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_tankshield,             NULL,  0},
>     {"btech_newstagger",            cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_newstagger,             NULL,  0},
>     {"btech_skidcliff",             cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_skidcliff,              NULL,  0},
>     {"btech_xp_bthmod",             cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_xp_bthmod,              NULL,  0},
>     {"btech_xp_missilemod",         cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_xp_missilemod,          NULL,  0},
>     {"btech_xp_ammomod",            cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_xp_ammomod,             NULL,  0},
>     {"btech_defaultweapdam",        cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_defaultweapdam,         NULL,  0},
>     {"btech_xp_modifier",           cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_xp_modifier,            NULL,  0},
>     {"btech_defaultweapbv",         cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_defaultweapbv,          NULL,  0},
>     {"btech_xp_usePilotBVMod",      cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_xp_usePilotBVMod,       NULL,  0},
>     {"btech_oldxpsystem",           cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_oldxpsystem,            NULL,  0},
>     {"btech_xp_vrtmod",             cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_xp_vrtmod,              NULL,  0},
>     {"btech_extendedmovemod",       cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_extendedmovemod,        NULL,  0},
>     {"btech_stacking",              cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_stacking,               NULL,  0},
>     {"btech_stackdamage",           cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_stackdamage,            NULL,  0},
>     {"btech_mw_losmap",             cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_mw_losmap,              NULL,  0},
>     {"btech_use_tech_bsuit",        cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_use_tech_bsuit,         NULL,  0},
>     {"btech_usedmechstore",         cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_usedmechstore,          NULL,  0},
>     {"btech_ooc_comsys",            cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_ooc_comsys,             NULL,  0},
>     {"btech_complexrepair",         cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_complexrepair,          NULL,  0},
>     {"hudinfo_show_mapinfo",        cf_int,     CA_GOD,     CA_GOD,         &btechconf.hudinfo_show_mapinfo,         NULL,  0},
>     {"hudinfo_enabled",             cf_int,     CA_GOD,     CA_GOD,         &btechconf.hudinfo_enabled,              NULL,  0},
>     {"btech_limitedrepairs",        cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_limitedrepairs,         NULL,  0},
>     {"btech_stackpole",             cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_stackpole,              NULL,  0},
>     {"phys_use_pskill",             cf_int,     CA_GOD,     CA_GOD,         &btechconf.phys_use_pskill,              NULL,  0},             
>     {"btech_erange",                cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_erange,                 NULL,  0},             
>     {"btech_dig_only_fs",           cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_dig_only_fs,            NULL,  0},
>     {"btech_digbonus",              cf_int,     CA_GOD,     CA_GOD,         &btechconf.btech_digbonus,               NULL,  0},
>     {"have_specials",             cf_bool,        CA_STATIC, CA_PUBLIC,   (int *)&btechconf.have_specials,     NULL,        0},
>     {"hcode_database",            cf_string_dyn,  CA_GOD,    CA_GOD,      (int *)&btechconf.hcode_db,        NULL, SIZEOF_PATHNAME},
>     {"econ_database",             cf_string_dyn,  CA_GOD,    CA_GOD,      (int *)&btechconf.econ_db,         NULL, SIZEOF_PATHNAME},
>     {"mech_database",             cf_string_dyn,  CA_GOD,    CA_GOD,      (int *)&btechconf.mech_db,         NULL, SIZEOF_PATHNAME},
>     {"map_database",              cf_string_dyn,  CA_GOD,    CA_GOD,      (int *)&btechconf.map_db,          NULL, SIZEOF_PATHNAME},
>     { NULL,                       NULL,           0,         0,           NULL,                            NULL,    0},
> };
> 
> // add function to mux scheduler, and recall itself every 1s
> void dispatch_btech(void *pUnused, int iUnused) {
>     UpdateSpecialObjects();
> 
>     CLinearTimeAbsolute ltaNextTime;
>     ltaNextTime.GetUTC();
>     ltaNextTime += time_1s;
>     scheduler.DeferTask(ltaNextTime, PRIORITY_SYSTEM+1, dispatch_btech, 0, 0);
> }
> 
15a218,337
>     // Add additional hardcode functions to the above table.
>     //
>     functions_add(local_funlist);
> 
>     // Add additional CMDENT_NO_ARG commands to the above table.
>     //
>     commands_no_arg_add(local_command_table_no_arg);
>     commands_one_arg_add(local_command_table_one_arg);
>     commands_one_arg_cmdarg_add(local_command_table_one_arg_cmdarg);
>     commands_two_arg_add(local_command_table_two_arg);
>     commands_two_arg_cmdarg_add(local_command_table_two_arg_cmdarg);
>     commands_two_arg_argv_add(local_command_table_two_arg_argv);
>     commands_two_arg_argv_cmdarg_add(local_command_table_two_argv_cmdarg);
> 
>     python = new Python;
>     python->Load();
> 
>     LoadSpecialObjects();
> 
>     // start running UpdateSpecialObjects() in 15 seconds to allow everything a chance to get going
>     CLinearTimeAbsolute ltaNextTime;
>     ltaNextTime.GetUTC();
>     ltaNextTime += time_15s;
>     scheduler.DeferTask(ltaNextTime, PRIORITY_SYSTEM+1, dispatch_btech, 0, 0);
> 
> 
>     btechconf.config_file = StringClone("btech.conf");
>     btechconf.hcode_db = StringClone("data/hcode.db");
>     btechconf.econ_db = StringClone("data/econ.db");
>     btechconf.mech_db = StringClone("mechs");
>     btechconf.map_db = StringClone("maps");
>     btechconf.have_specials = 1;
>     
>     FILE *fp = fopen(btechconf.config_file, "rb");
>     if (fp == NULL) 
>         return; // add log entry
> 
>     char *buf = alloc_lbuf("local_startup");
>     fgets(buf, LBUF_SIZE, fp);
>     while(!feof(fp)) {
>         char *zp = buf;
>         // Remove comments.  Anything after the '#' is a comment except if it
>         // matches:  whitespace + '#' + digit.
>         //
>         while (*zp != '\0')
>             if (*zp == '#' && (zp <= buf || !mux_isspace(zp[-1]) || !mux_isdigit(zp[1]))) 
>                 *zp = '\0';     // found a comment
>             else
>                 zp++;
>         
>         // Trim trailing spaces.
>         //
>         while (buf < zp && mux_isspace(zp[-1])) 
>             *(--zp) = '\0';
>         
>         // Process line.
>         //
>         char *cp = buf;
> 
>         // Trim leading spaces.
>         //
>         while (mux_isspace(*cp)) 
>             cp++;
>         
>         // Skip over command.
>         //
>         char *ap;
>         for (ap = cp; *ap && !mux_isspace(*ap); ap++) {   
>             ; // Nothing.
>         }
>         
>         // Terminate command.
>         //
>         if (*ap)   
>             *ap++ = '\0';
>         
>         // Skip spaces between command and argument.
>         //
>         while (mux_isspace(*ap)) 
>             ap++;
> 
>         if (*cp) {
>             CONF2 *tp;
>             int i;
>             char *buff = 0;
> 
>             // Search the config parameter table for the command. If we find
>             // it, call the handler to parse the argument.
>             //
>             for (tp = btechconftable; tp->pname; tp++) {
>                 if (!strcmp(tp->pname, cp)) {
>                     buff = alloc_lbuf("local_startup");
>                     strcpy(buff, ap);
>                     i = tp->interpreter(tp->loc, ap, tp->pExtra, tp->nExtra, GOD, cp);
>                 }
>             }
>         }
> 
>         fgets(buf, LBUF_SIZE, fp);
>     }
>     free_lbuf(buf);
>     fclose(fp);
> }
> 
> // This is called prior to the game syncronizing its own state to its own
> // database.  If you depend on the the core database to store your data, you
> // need to checkpoint your changes here. The write-protection
> // mechanism in MUX is not turned on at this point.  You are guaranteed
> // to not be a fork()-ed dumping process.
> //
> void local_presync_database(void)
> {
> }
> 
> // Like the above routine except that it called from the SIGSEGV handler.
> // At this point, your choices are limited. You can attempt to use the core
> // database. The core won't stop you, but it is risky.
> //
> void local_presync_database_sigsegv(void)
> {
18,20c340,354
< // Called prior to the game database being dumped.   Called by the
< // periodic dump timer, @restart, @shutdown, etc.  The argument
< // dump_type is one of the 5 DUMP_I_x defines declared in externs.h
---
> // This is called prior to the game database writing out it's own database.
> // This is typically only called from the fork()-ed process so write-
> // protection is in force and you will be unable to modify the game's
> // database for you own needs.  You can however, use this point to maintain
> // your own dump file.
> //
> // The caveat is that it is possible the game will crash while you are doing
> // this, or it is already in the process of crashing.  You may be called
> // reentrantly.  Therefore, it is recommended that you follow the pattern in
> // dump_database_internal() and write your database to a temporary file, and
> // then if completed successfully, move your temporary over the top of your
> // old database.
> //
> // The argument dump_type is one of the 5 DUMP_I_x defines declared in
> // externs.h
23a358,371
>     python->Save();
> 
>     SaveSpecialObjects(dump_type);
> }
> 
> // The function is called when the dumping process has completed. Typically,
> // this will be called from within a signal handler. Your ability to do
> // anything interesting from within a signal handler is severly limited.
> // This is also called at the end of the dumping process if either no dumping
> // child was created or if the child finished quickly. In fact, this
> // may be called twice at the end of the same dump.
> //
> void local_dump_complete_signal(void)
> {
30a379,381
>     delete python;
> 
>     ResetSpecialObjects();
72a424,488
>     if(Marker9(object)) 
>         DisposeSpecialObject(GOD, object);
> }
> 
> // btmux specific stuff below here:
> //
> int local_handled_flag(dbref target, dbref player, FLAG flag, int fflags, bool reset)
> {
>     if (flag & MARK_9) {
>         if(reset) {
>             c_Hardcode(target);
>             DisposeSpecialObject(player, target);
>         } else {
>             s_Hardcode(target);
>             CreateNewSpecialObject(player, target);
>         }
>         return 1;
>     } else
>         return 0;
> }
> 
> int local_handled_command(dbref executor, char *pCommand)
> {
>     if(HandledCommand(executor, Location(executor), pCommand)) 
>         return 1;
>     else {
>         char *buffer = alloc_lbuf("local_handled_command");
>         char *p = pCommand;
>         char *q = buffer;
>         char *s;
>         int x;
> 
>         if(p[0] == ',') {
>             *p++;
>             if(*p) {
>                 python->Run(executor, p);
>                 return 1;
>             } else {
>                 python->Run(executor, "\n");
>                 return 1;
>             }
>         }
>     
>         x = 0;
>         strncpy(q, p, LBUF_SIZE);
>         while(!mux_isspace(*p) && *p) {    // forward to a space
>             *p++; x++;
>         }
>     
>         q[x] = '\0';        // q is everything before the space
> 
>         if(string_compare(q,"@python") == 0)
>             if(*p) {
>                 *p++;
>                 free_lbuf(q);
>                 python->Run(executor, p);
>                 return 1;
>             } else {
>                 python->Run(executor, "\n");
>                 return 1;
>             }
>         free_lbuf(q);
>     }
> 
>     return 0;
Only in .: local.o
diff /home/nick/sandbox/mux2.4.20/mux/src/log.cpp ./log.cpp
3c3
< // $Id: log.cpp,v 1.7 2003/02/17 01:59:21 sdennis Exp $
---
> // $Id: log.cpp,v 1.8 2005/10/22 16:21:47 sdennis Exp $
150a151,160
> void DCL_CDECL log_printf(const char *fmt, ...)
> {
>     va_list ap;
>     va_start(ap, fmt);
>     char aTempBuffer[SIZEOF_LOG_BUFFER];
>     int nString = mux_vsnprintf(aTempBuffer, SIZEOF_LOG_BUFFER, fmt, ap);
>     va_end(ap);
>     Log.WriteBuffer(nString, aTempBuffer);
> }
> 
Only in .: log.o
diff /home/nick/sandbox/mux2.4.20/mux/src/look.cpp ./look.cpp
3c3
< // $Id: look.cpp,v 1.33 2005/10/09 19:49:56 sdennis Exp $
---
> // $Id: look.cpp,v 1.40 2005/10/27 03:22:39 sdennis Exp $
861,864c861,862
<     dbref aowner;
<     int ca, aflags;
<     ATTR *pattr;
<     char *as, *buf;
---
>     bool bFoundCommands = false;
>     bool bFoundListens  = false;
866,867c864,865
<     ATTR cattr;
<     for (ca = atr_head(thing, &as); ca; ca = atr_next(&as))
---
>     char *as;
>     for (int ca = atr_head(thing, &as); ca; ca = atr_next(&as))
874c872,873
<         pattr = atr_num(ca);
---
> 
>         ATTR *pattr = atr_num(ca);
879a879
>         ATTR cattr;
891c891,914
<         buf = atr_get(thing, ca, &aowner, &aflags);
---
>         int   aflags;
>         dbref aowner;
>         char *buf = atr_get(thing, ca, &aowner, &aflags);
> 
>         if (!(aflags & AF_NOPROG))
>         {
>             if (  AMATCH_CMD    == buf[0]
>                || AMATCH_LISTEN == buf[0])
>             {
>                 char *s = strchr(buf+1, ':');
>                 if (s)
>                 {
>                     if (AMATCH_CMD == buf[0])
>                     {
>                         bFoundCommands = true;
>                     }
>                     else
>                     {
>                         bFoundListens = true;
>                     }
>                 }
>             }
>         }
> 
898,899c921
<                     hashaddLEN(&ca, sizeof(ca), pattr,
<                         &mudstate.parent_htab);
---
>                     hashaddLEN(&ca, sizeof(ca), pattr, &mudstate.parent_htab);
905a928,949
> 
>     if (bFoundCommands)
>     {
>         mudstate.bfNoCommands.Clear(thing);
>         mudstate.bfCommands.Set(thing);
>     }
>     else
>     {
>         mudstate.bfCommands.Clear(thing);
>         mudstate.bfNoCommands.Set(thing);
>     }
> 
>     if (bFoundListens)
>     {
>         mudstate.bfNoListens.Clear(thing);
>         mudstate.bfListens.Set(thing);
>     }
>     else
>     {
>         mudstate.bfListens.Clear(thing);
>         mudstate.bfNoListens.Set(thing);
>     }
2053,2056c2097,2102
<     dbref aowner, parent;
<     int atr, aflags, lev;
<     char *buf, *buf2, *bp, *as, *buff, *s;
<     ATTR *ap;
---
>     if (  Can_Hide(what)
>        && Hidden(what)
>        && !See_Hidden(player))
>     {
>         return;
>     }
2065,2068c2111
<     if (  (key & SWEEP_LISTEN)
<        && (  (  isExit(what)
<              || is_loc)
<           && Audible(what)))
---
>     if (key & SWEEP_LISTEN)
2070,2075c2113,2117
<         canhear = true;
<     }
<     else if (key & SWEEP_LISTEN)
<     {
<         buff = NULL;
<         if (Monitor(what))
---
>         if (  (  (  isExit(what)
>                  || is_loc)
>               && Audible(what))
>            || H_Listen(what)
>            || mudstate.bfListens.IsSet(what))
2077c2119
<             buff = alloc_lbuf("Hearer");
---
>             canhear = true;
2079,2080c2121,2122
< 
<         for (atr = atr_head(what, &as); atr; atr = atr_next(&as))
---
>         else if (  !mudstate.bfNoListens.IsSet(what)
>                 && Monitor(what))
2082,2087c2124,2128
<             if (atr == A_LISTEN)
<             {
<                 canhear = true;
<                 break;
<             }
<             if (Monitor(what))
---
>             bool bFoundCommands = false;
> 
>             char *as;
>             char *buff = alloc_lbuf("sweep_check.Hearer");
>             for (int atr = atr_head(what, &as); atr; atr = atr_next(&as))
2089c2130
<                 ap = atr_num(atr);
---
>                 ATTR *ap = atr_num(atr);
2095a2137,2138
>                 int   aflags;
>                 dbref aowner;
2098,2101c2141
<                 // Make sure we can execute it.
<                 //
<                 if (  (buff[0] != AMATCH_LISTEN)
<                    || (aflags & AF_NOPROG))
---
>                 if (aflags & AF_NOPROG)
2106,2112c2146,2148
<                 // Make sure there's a : in it.
<                 //
<                 for (s = buff + 1; *s && (*s != ':'); s++)
<                 {
<                     ; // Nothing.
<                 }
<                 if (s)
---
>                 char *s = NULL;
>                 if (  AMATCH_CMD    == buff[0]
>                    || AMATCH_LISTEN == buff[0])
2114,2115c2150,2162
<                     canhear = true;
<                     break;
---
>                     s = strchr(buff+1, ':');
>                     if (s)
>                     {
>                         if (AMATCH_CMD == buff[0])
>                         {
>                             bFoundCommands = true;
>                         }
>                         else
>                         {
>                             canhear = true;
>                             break;
>                         }
>                     }
2118,2120d2164
<         }
<         if (buff)
<         {
2121a2166,2185
> 
>             if (canhear)
>             {
>                 mudstate.bfListens.Set(what);
>             }
>             else
>             {
>                 mudstate.bfNoListens.Set(what);
>             }
> 
>             if (bFoundCommands)
>             {
>                 mudstate.bfNoCommands.Clear(what);
>                 mudstate.bfCommands.Set(what);
>             }
>             else
>             {
>                 mudstate.bfCommands.Clear(what);
>                 mudstate.bfNoCommands.Set(what);
>             }
2123a2188
> 
2128a2194,2195
>         dbref parent;
>         int lev;     
2141a2209
> 
2154a2223
> 
2166a2236
> 
2173,2174c2243,2244
<         buf = alloc_lbuf("sweep_check.types");
<         bp = buf;
---
>         char *buf = alloc_lbuf("sweep_check.types");
>         char *bp = buf;
2179a2250
> 
2183a2255
> 
2187a2260
> 
2193a2267
> 
2197a2272
> 
2202a2278
> 
2210c2286
<             buf2 = alloc_lbuf("sweep_check.name");
---
>             char *buf2 = alloc_lbuf("sweep_check.name");
2212c2288,2291
<             for (bp = buf2; *bp && (*bp != ';'); bp++) ;
---
>             for (bp = buf2; *bp && (*bp != ';'); bp++)
>             {
>                 ; // Nothing.
>             }
2242a2322
>     {
2243a2324
>     }
2244a2326
>     {
2245a2328
>     }
2246a2330
>     {
2247a2332
>     }
Only in .: look.o
diff /home/nick/sandbox/mux2.4.20/mux/src/mail.cpp ./mail.cpp
3c3
< // $Id: mail.cpp,v 1.51 2005/07/27 02:57:52 sdennis Exp $
---
> // $Id: mail.cpp,v 1.52 2005/10/23 20:11:07 sdennis Exp $
3642,3650c3642
<     char *bufMsg = alloc_lbuf("add_mail_message");
<     char *bpMsg = bufMsg;
<     char *strMsg = arg2;
<     mux_exec(bufMsg, &bpMsg, player, player, player,
<              EV_NO_COMPRESS | EV_FCHECK | EV_EVAL, &strMsg, (char **)NULL, 0);
<     *bpMsg = '\0';
< 
<     mail_to_list(player, make_numlist(player, bufDest, false), bpSubject, bufMsg, 0, false);
<     free_lbuf(bufMsg);
---
>     mail_to_list(player, make_numlist(player, bufDest, false), bpSubject, arg2, 0, false);
Only in .: mail.o
Only in .: map.bits.o
Only in .: map.coding.o
Only in .: map.conditions.o
Only in .: map.dynamic.o
Only in .: map.los.o
Only in .: map.o
Only in .: map.obj.o
diff /home/nick/sandbox/mux2.4.20/mux/src/match.cpp ./match.cpp
3c3
< // $Id: match.cpp,v 1.6 2005/08/05 15:27:43 sdennis Exp $
---
> // $Id: match.cpp,v 1.7 2005/10/19 23:10:00 rmg Exp $
449,450c449
<        && (  Has_exits(md.player)
<           || isRoom(md.player)))
---
>        && Has_exits(md.player))
Only in .: match.o
Only in .: mech.advanced.o
Only in .: mech.ammodump.o
Only in .: mech.avail.o
Only in .: mech.bth.o
Only in .: mech.build.o
Only in .: mech.c3.misc.o
Only in .: mech.c3.o
Only in .: mech.c3i.o
Only in .: mech.combat.misc.o
Only in .: mech.combat.missile.o
Only in .: mech.combat.o
Only in .: mech.consistency.o
Only in .: mech.contacts.o
Only in .: mech.custom.o
Only in .: mech.damage.o
Only in .: mech.ecm.o
Only in .: mech.enhanced.criticals.o
Only in .: mech.events.o
Only in .: mech.fire.o
Only in .: mech.hitloc.o
Only in .: mech.ice.o
Only in .: mech.lite.o
Only in .: mech.los.o
Only in .: mech.lostracer.o
Only in .: mech.maps.o
Only in .: mech.mechref_ident.o
Only in .: mech.move.o
Only in .: mech.notify.o
Only in .: mech.ood.o
Only in .: mech.partnames.o
Only in .: mech.physical.o
Only in .: mech.pickup.o
Only in .: mech.restrict.o
Only in .: mech.scan.o
Only in .: mech.sensor.functions.o
Only in .: mech.sensor.o
Only in .: mech.spot.o
Only in .: mech.startup.o
Only in .: mech.stat.o
Only in .: mech.status.o
Only in .: mech.tag.o
Only in .: mech.tech.commands.o
Only in .: mech.tech.damages.o
Only in .: mech.tech.do.o
Only in .: mech.tech.events.o
Only in .: mech.tech.o
Only in .: mech.tech.repairs.o
Only in .: mech.tech.saverepair.o
Only in .: mech.tic.o
Only in .: mech.update.o
Only in .: mech.utils.o
Only in .: mechfile.o
Only in .: mechrep.o
Only in .: mguests.o
Only in .: mine.o
Only in .: move.o
diff /home/nick/sandbox/mux2.4.20/mux/src/mudconf.h ./mudconf.h
3c3
< // $Id: mudconf.h,v 1.32 2005/10/12 04:33:30 sdennis Exp $
---
> // $Id: mudconf.h,v 1.33 2005/10/16 20:48:14 sdennis Exp $
402a403,410
> 
>     CBitField bfNoListens;      // Cache knowledge that there are no ^-Commands.
>     CBitField bfNoCommands;     // Cache knowledge that there are no $-Commands.
>     CBitField bfCommands;       // Cache knowledge that there are $-Commands.
>     CBitField bfListens;        // Cache knowledge that there are ^-Commands.
> 
>     CBitField bfReport;         // Used for LROOMS.
>     CBitField bfTraverse;       // Used for LROOMS.
Only in .: mux_tree.o
Only in .: muxcli.o
Only in .: mydiff
Only in .: myfifo.o
Only in .: netcommon.o
Only in .: netmux
Only in .: netmux~
Only in .: object.o
Only in .: pcombat.o
Only in .: pcre.o
Only in .: player.o
diff /home/nick/sandbox/mux2.4.20/mux/src/player_c.cpp ./player_c.cpp
1,4c1,11
< // player_c.cpp -- Player cache routines.
< //
< // $Id: player_c.cpp,v 1.11 2005/06/11 19:11:46 sdennis Exp $
< //
---
> /*! \file player_c.cpp
>  * Player cache routines.
>  *
>  * $Id: player_c.cpp,v 1.16 2005/10/30 11:27:05 sdennis Exp $
>  *
>  * Frequenty-used items which appear on every object generally find a home in
>  * the db[] structure managed in db.cpp. However, there are a few items
>  * related only to players which are still accessed frequently enough that
>  * they should be cached. These items are money, current number of queued
>  * commands, and the limit on the number of queued commands.
>  */
13c20,24
< typedef struct player_cache {
---
> /*! \brief structure to hold cached data for player-type objects.
>  */
> 
> typedef struct player_cache
> {
15,18c26,29
<     int money;
<     int queue;
<     int qmax;
<     int cflags;
---
>     int   money;
>     int   queue;
>     int   qmax;
>     int   cflags;
21a33,34
> /*! \brief Hash Table which maps player dbref to PCACHE entry.
>  */
22a36,38
> 
> /*! \brief The head of a singly-linked list of all PCACHE entries.
>  */
27a44,52
> /*! \brief Initializes the player cache.
>  *
>  * This is called once to initialize the player cache and supporting
>  * data structures:  Player cache structures are pooled, the Hash Table
>  * initializes itself, and the singly-linked list is started.
>  *
>  * \return         None.
>  */
> 
33a59,71
> /*! \brief Updates player cache items from the database.
>  *
>  * The Money and QueueMax attributes are used to initialize the corresponding
>  * items in the player cache.  If a Money attribute does not exist for some
>  * strange reason, it it initialized to zero and marked as dirty. If a
>  * QueueMax attribute doesn't exist or is negative, then the game will
>  * choose a reasonable limit later in QueueMax().
>  *
>  * \param player   player object to begin caching.
>  * \param pp       pointer to PCACHE structure.
>  * \return         None.
>  */
> 
59a98,107
> /*! \brief Returns a player's cache record.
>  *
>  * Whether created from scratch or found in the cache, pcache_find() always
>  * returns a valid player cache record for the requested player object dbref.
>  * This function uses Hash Table access primarily, but it maintains the
>  * singly-linked list as well.
>  *
>  * \param player   player object dbref.
>  * \return         Pointer to new or existing player cache record.
>  */
61c109
< PCACHE *pcache_find(dbref player)
---
> static PCACHE *pcache_find(dbref player)
63,67d110
<     if (  !Good_obj(player)
<        || !OwnsOthers(player))
<     {
<         return NULL;
<     }
85,93c128,132
< void pcache_reload(dbref player)
< {
<     PCACHE *pp = pcache_find(player);
<     if (!pp)
<     {
<         return;
<     }
<     pcache_reload1(player, pp);
< }
---
> /*! \brief Saves any dirty player data items to the database.
>  *
>  * \param pp       pointer to potentially dirty PCACHE structure.
>  * \return         None.
>  */
97,98d135
<     IBUF tbuf;
< 
100a138
>         IBUF tbuf;
102a141,158
>         pp->cflags &= ~PF_MONEY_CH;
>     }
> }
> 
> /*! \brief Re-initializes Money and QueueMax items from the database.
>  *
>  * \param player   player object dbref.
>  * \return         None.
>  */
> 
> void pcache_reload(dbref player)
> {
>     if (  Good_obj(player)
>        && OwnsOthers(player))
>     {
>         PCACHE *pp = pcache_find(player);
>         pcache_save(pp);
>         pcache_reload1(player, pp);
104d159
<     pp->cflags &= ~PF_MONEY_CH;
106a162,174
> /*! \brief Ages and trims the player cache of stale entries.
>  *
>  * pcache_trim() relies primarily on the singly-linked list, but it also
>  * maintains the Hash Table. To be trimmed, a player cache record must
>  * not have outstanding commands in the command queue.
>  *
>  * The one level of aging is accomplished with PR_REF.  On the first pass
>  * through the linked list, the PR_REF bit is removed. On the second pass
>  * through the list, the record is trimmed.
>  *
>  * \return         None.
>  */
> 
117c185,186
<             // This entry either has outstanding commands in the queue or we need to let it age.
---
>             // This entry either has outstanding commands in the queue or we
>             // need to let it age.
142a212,219
> /*! \brief Flushes any dirty player items to the database.
>  *
>  * The primary access is via the singly-linked list. Upon return, all the
>  * player cache records are marked as clean.
>  *
>  * \return         None.
>  */
> 
152a230,238
> /*! \brief Adjusts the count of queued commands up or down.
>  *
>  * cque.cpp uses this as it schedules and performs queued commands.
>  *
>  * \param player   dbref of player object responsible for command.
>  * \param adj      new (+) or completed (-) commands being queued.
>  * \return         None.
>  */
> 
155c241,242
<     if (OwnsOthers(player))
---
>     if (  Good_obj(player)
>        && OwnsOthers(player))
158,162c245,246
<         if (pp)
<         {
<             pp->queue += adj;
<             return pp->queue;
<         }
---
>         pp->queue += adj;
>         return pp->queue;
166a251,262
> /*! \brief Returns the player's upper limit of queued commands.
>  *
>  * If a QueueMax is set on the player, we use that. Otherwise, there is
>  * a configurable game-wide limit (given by player_queue_limit) unless the
>  * player is a Wizard in which case, we reason that well behaved Wizard code
>  * should be able to schedule as much work as there are objects in the
>  * database -- larger game, more work to be expected in the queue.
>  *
>  * \param player   dbref of player object.
>  * \return         None.
>  */
> 
170c266,267
<     if (OwnsOthers(player))
---
>     if (  Good_obj(player)
>        && OwnsOthers(player))
173c270
<         if (pp)
---
>         if (pp->qmax >= 0)
175,179c272,280
<             if (pp->qmax >= 0)
<             {
<                 m = pp->qmax;
<             }
<             else
---
>             m = pp->qmax;
>         }
>         else
>         {
>             // @queuemax was not valid so we use the game-wide limit.
>             //
>             m = mudconf.queuemax;
>             if (  Wizard(player)
>                && m < mudstate.db_top + 1)
181,188c282
<                 // @queuemax was not valid so we use the game-wide limit.
<                 //
<                 m = mudconf.queuemax;
<                 if (  Wizard(player)
<                    && m < mudstate.db_top + 1)
<                 {
<                     m = mudstate.db_top + 1;
<                 }
---
>                 m = mudstate.db_top + 1;
194a289,294
> /*! \brief Returns how many coins are in a player's purse.
>  *
>  * \param player   dbref of player object.
>  * \return         None.
>  */
> 
205c305,306
<     else if (OwnsOthers(obj))
---
>     else if (  Good_obj(obj)
>             && OwnsOthers(obj))
208,211c309
<         if (pp)
<         {
<             return pp->money;
<         }
---
>         return pp->money;
215a314,323
> /*! \brief Sets the number of coins in a player's purse.
>  *
>  * This changes the number of coins a player holds and sets this attribute
>  * as dirty so that it will be updated in the attribute database later.
>  *
>  * \param player   dbref of player object responsible for command.
>  * \param howfew   Number of coins
>  * \return         None.
>  */
> 
224c332,333
<     else if (OwnsOthers(obj))
---
>     else if (  Good_obj(obj)
>             && OwnsOthers(obj))
227,231c336,337
<         if (pp)
<         {
<             pp->money = howfew;
<             pp->cflags |= PF_MONEY_CH;
<         }
---
>         pp->money = howfew;
>         pp->cflags |= PF_MONEY_CH;
Only in .: player_c.o
diff /home/nick/sandbox/mux2.4.20/mux/src/powers.cpp ./powers.cpp
3c3
< // $Id: powers.cpp,v 1.11 2005/10/12 04:31:46 sdennis Exp $
---
> // $Id: powers.cpp,v 1.13 2005/10/27 02:08:11 sdennis Exp $
112a113,115
> #ifdef FIRANMUX
>     {"immutable",       POW_IMMUTABLE,  POWER_EXT, 0, ph_wiz},
> #endif
147c150,154
<         hashaddLEN(nbuf, strlen(nbuf), fp, &mudstate.powers_htab);
---
>        
>         if (!hashfindLEN(nbuf, strlen(nbuf), &mudstate.powers_htab))
>         {
>             hashaddLEN(nbuf, strlen(nbuf), fp, &mudstate.powers_htab);
>         }
diff /home/nick/sandbox/mux2.4.20/mux/src/powers.h ./powers.h
3c3
< // $Id: powers.h,v 1.6 2005/10/12 04:30:17 sdennis Exp $
---
> // $Id: powers.h,v 1.7 2005/10/24 15:48:36 sdennis Exp $
49a50,52
> #ifdef FIRANMUX
> #define POW_IMMUTABLE   0x00000002  /* Can not change */
> #endif
107a111,113
> #ifdef FIRANMUX
> #define Immutable(c)        ((Powers2(c) & POW_IMMUTABLE) != 0)
> #endif
Only in .: powers.o
diff /home/nick/sandbox/mux2.4.20/mux/src/predicates.cpp ./predicates.cpp
3c3
< // $Id: predicates.cpp,v 1.68 2005/10/12 04:30:17 sdennis Exp $
---
> // $Id: predicates.cpp,v 1.72 2005/10/24 15:48:36 sdennis Exp $
618,619c618
<     if (  !could_hear
<        && can_hear)
---
>     if (could_hear != can_hear)
621c620
<         buff = alloc_lbuf("handle_ears.grow");
---
>         buff = alloc_lbuf("handle_ears");
632,642c631,632
<         notify_check(thing, thing, tprintf("%s grow%s ears and can now hear.",
<             buff, (gender == 4) ? "" : "s"),
<             (MSG_ME | MSG_NBR | MSG_LOC | MSG_INV));
<         free_lbuf(buff);
<     }
<     else if (  could_hear
<             && !can_hear)
<     {
<         buff = alloc_lbuf("handle_ears.lose");
<         strcpy(buff, Name(thing));
<         if (isExit(thing))
---
> 
>         if (can_hear)
644,648c634,645
<             for (bp = buff; *bp && *bp != ';'; bp++)
<             {
<                 ; // Nothing.
<             }
<             *bp = '\0';
---
>             notify_check(thing, thing,
>                          tprintf("%s grow%s ears and can now hear.",
>                                  buff, (gender == 4) ? "" : "s"),
>                          (MSG_ME | MSG_NBR | MSG_LOC | MSG_INV));
>         }
>         else
>         {
>             notify_check(thing, thing,
>                          tprintf("%s lose%s %s ears and become%s deaf.",
>                                  buff, (gender == 4) ? "" : "s",
>                                  poss[gender], (gender == 4) ? "" : "s"),
>                          (MSG_ME | MSG_NBR | MSG_LOC | MSG_INV));
650,654d646
<         gender = get_gender(thing);
<         notify_check(thing, thing,
<             tprintf("%s lose%s %s ears and become%s deaf.", buff,
<             (gender == 4) ? "" : "s", poss[gender], (gender == 4) ? "" : "s"),
<             (MSG_ME | MSG_NBR | MSG_LOC | MSG_INV));
1444a1437,1438
>     local_presync_database();
> 
1913a1908,1910
> #ifdef FIRANMUX
>        || Immutable(target)
> #endif
2091a2089,2094
>     if (  Can_Hide(thing)
>        && Hidden(thing)
>        && !See_Hidden(player))
>     {
>         return false;
>     }
Only in .: predicates.o
Only in .: python.cpp
Only in .: python.h
Only in .: python.o
Only in .: quota.o
Only in .: rob.o
Only in .: scen.o
Only in .: set.o
Only in .: sha1.o
Only in .: slave
Only in .: slave.o
Only in .: spath.o
Only in .: speech.o
Only in .: sqlshared.o
Only in .: sqlslave
Only in .: sqlslave.o
Only in .: stringutil.o
Only in .: strtod.o
diff /home/nick/sandbox/mux2.4.20/mux/src/svdhash.cpp ./svdhash.cpp
3c3
< // $Id: svdhash.cpp,v 1.37 2005/10/13 15:18:28 sdennis Exp $
---
> // $Id: svdhash.cpp,v 1.40 2005/10/24 03:12:46 sdennis Exp $
705,706c705,707
< //        iDir = FindNextKey(iDir, hash) every time after than until iDir == HP_DIR_EMPTY
< //        to interate through all the records with the desired hash key.
---
> //        iDir = FindNextKey(iDir, hash) every time after than until
> //        iDir == HP_DIR_EMPTY to interate through all the records with the
> //        desired hash key.
718c719
<     int nDirSize = m_pHeader->m_nDirSize;
---
>     const int nDirSize = m_pHeader->m_nDirSize;
722d722
<     int di = m_pHeader->m_Primes[nHash & 15];
724d723
<     m_nProbesLeft = nDirSize;
725a725,754
>     if (sOffset < HP_DIR_DELETED)
>     {
>         HP_PHEAPNODE pNode = (HP_PHEAPNODE)(m_pHeapStart + sOffset);
>         if (pNode->u.s.nHash == nHash)
>         {
>             m_nProbesLeft = nDirSize - 1;
>             *numchecks = 1;
>             return iDir;
>         }
>     }
>     else if (HP_DIR_EMPTY == sOffset)
>     {
>         m_nProbesLeft = nDirSize;
>         *numchecks = 0;
>         return HP_DIR_EMPTY;
>     }
> 
>     //    HP_DIR_DELETED == sOffset
>     // || pNode->u.s.nHash != nHash
> 
>     m_nProbesLeft = nDirSize - 1;
>     int di = m_pHeader->m_Primes[nHash & 15];
> 
>     iDir += di;
>     if (iDir >= nDirSize)
>     {
>         iDir -= nDirSize;
>     }
>     sOffset = m_pDirectory[iDir];
> 
Only in .: svdhash.o
Only in .: svdrand.o
Only in .: svdreport.o
Only in .: template.o
Only in .: timer.o
Only in .: timeutil.o
Common subdirectories: /home/nick/sandbox/mux2.4.20/mux/src/tools and ./tools
Only in .: tree.o
Only in .: unparse.o
Only in .: unsplit
diff /home/nick/sandbox/mux2.4.20/mux/src/vattr.cpp ./vattr.cpp
3c3
< // $Id: vattr.cpp,v 1.10 2005/06/02 04:09:05 sdennis Exp $
---
> // $Id: vattr.cpp,v 1.11 2005/10/16 04:31:33 sdennis Exp $
249c249,250
<     // Traverse every attribute on every object and make sure that attribute is represented in the attribute table.
---
>     // Traverse every attribute on every object and make sure that attribute is
>     // represented in the attribute table.
318c319,320
<     // Traverse every attribute on every object and make sure that attribute is represented attribute database.
---
>     // Traverse every attribute on every object and make sure that attribute is
>     // represented attribute database.
Only in .: vattr.o
Only in .: version.o
Only in .: walkdb.o
Only in .: wild.o
Only in .: wiz.o
